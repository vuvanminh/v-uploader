{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///v-uploader.js","webpack:///webpack/bootstrap e05517980d34ba7ccf1d","webpack:///src/Uploader.vue","webpack:///./src/index.js","webpack:///./src/Uploader.vue","webpack:///./node_modules/vue-loader/lib/component-normalizer.js","webpack:///./node_modules/fine-uploader/lib/traditional.js","webpack:///./node_modules/fine-uploader/fine-uploader/fine-uploader.js","webpack:///./node_modules/holderjs/holder.js","webpack:///./src/constants.js","webpack:///./src/Uploader.vue?42b1"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_fine_uploader__","__WEBPACK_IMPORTED_MODULE_0_fine_uploader___default","__WEBPACK_IMPORTED_MODULE_1_holderjs__","__WEBPACK_IMPORTED_MODULE_1_holderjs___default","__WEBPACK_IMPORTED_MODULE_2__constants__","props","language","type","String","default","preview","Boolean","previewImg","buttonText","buttonIcon","previewWidth","Number","previewHeight","multiple","uploadFileObjName","itemLimit","fileSizeLimit","fileTypeExts","imageMaxHeight","imageMaxWidth","imageMinHeight","imageMinWidth","beforeUpload","Function","uploadFileUrl","deleteFileUrl","showMessage","undefined","data","uploadedFiles","deleteIndexs","options","callback","singleUploadImg","ui","uploaderClass","v-uploader","single-mode","multiple-mode","watch","val","beforeMount","that","imgHolder","thumbnail","success","push","url","$emit","mounted","deleteFile","endpoint","template","$refs","uploadArea","element","multipleUpload","message","callbacks","onDelete","id","filter","index","includes","onAllComplete","succeeded","failed","validation","onSubmit","a","FineUploader","run","images","simpleImg","button","upload","onError","errorReason","xhr","FineUploaderBasic","value","__WEBPACK_IMPORTED_MODULE_0__Uploader_vue__","Plugin","install","Vue","arguments","length","keys","uploader","component","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Uploader_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b4b4387_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Uploader_vue__","normalizeComponent","Component","rawScriptExports","compiledTemplate","functionalTemplate","injectStyles","scopeId","moduleIdentifier","esModule","scriptExports","render","staticRenderFns","_compiled","functional","_scopeId","hook","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","existing","beforeCreate","_injectStyles","h","concat","__WEBPACK_AMD_DEFINE_RESULT__","global","qq","hide","style","display","attach","fn","addEventListener","attachEvent","detach","removeEventListener","detachEvent","contains","descendant","compareDocumentPosition","insertBefore","elementB","parentNode","remove","removeChild","css","styles","Error","opacity","filters","Math","round","extend","hasClass","considerParent","re","RegExp","test","className","addClass","removeClass","replace","getByClass","first","candidates","result","querySelector","querySelectorAll","getElementsByTagName","each","idx","getFirstByClass","children","child","firstChild","nodeType","nextSibling","setText","text","innerText","textContent","clearText","hasAttribute","attrName","attrVal","exec","getAttribute","canvasToBlob","canvas","mime","quality","dataUriToBlob","toDataURL","dataUri","arrayBuffer","byteString","intArray","mimeString","split","indexOf","atob","decodeURI","ArrayBuffer","Uint8Array","character","charCodeAt","BlobBuilder","window","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","blobBuilder","append","getBlob","Blob","log","level","console","isObject","variable","toString","isFunction","isArray","buffer","constructor","isItemList","maybeItemList","isNodeList","maybeNodeList","item","namedItem","isString","maybeString","trimStr","string","trim","format","str","args","Array","slice","newStr","nextIdxToReplace","strBefore","substring","strAfter","isFile","maybeFile","File","isFileList","maybeFileList","FileList","isFileOrInput","maybeFileOrInput","isInput","maybeInput","notFile","evaluateType","normalizedType","toLowerCase","HTMLInputElement","tagName","isBlob","maybeBlob","isXhrUploadSupported","input","document","createElement","FormData","createXhrInstance","XMLHttpRequest","ActiveXObject","error","isFolderDropSupported","dataTransfer","items","webkitGetAsEntry","isFileChunkingSupported","androidStock","webkitSlice","mozSlice","sliceBlob","fileOrBlob","start","end","arrayBufferToHex","bytesAsHex","bytes","byt","byteAsHexStr","readBlobToHex","blob","startOffset","initialBlob","fileReader","FileReader","promise","Promise","onload","onerror","failure","readAsArrayBuffer","second","extendNested","prop","override","target","sourceFn","super_","source","srcPropName","srcPropVal","arr","elt","from","len","getUniqueId","r","random","ie","navigator","userAgent","ie7","ie8","ie10","ie11","edge","safari","vendor","chrome","opera","firefox","windows","platform","android","ios6","ios","ios7","ios8","ios800","iosChrome","iosSafari","iosSafariWebView","preventDefault","e","returnValue","toElement","div","html","innerHTML","iterableItem","keyOrIndex","Storage","key","getItem","charAt","bind","oldFunc","newArgs","apply","obj2url","obj","temp","prefixDone","uristrings","prefix","nextObj","nextTemp","encodeURIComponent","join","obj2FormData","formData","arrayKeyName","obj2Inputs","form","setAttribute","appendChild","parseJson","json","JSON","parse","eval","getExtension","filename","extIdx","lastIndexOf","substr","getFilename","blobOrFileInput","fileName","DisposeSupport","disposers","dispose","disposer","shift","addDisposer","disposeFunction","version","supportedFeatures","isCrossOriginXhrSupported","withCredentials","isXdrSupported","XDomainRequest","supportsUploading","supportsUploadingBlobs","supportsFileDrop","supportsAjaxFileUploading","supportsFolderDrop","supportsChunking","supportsResume","supportsUploadViaPaste","supportsUploadCors","supportsDeleteFileXdr","supportsDeleteFileCorsXhr","supportsDeleteFileCors","supportsFolderSelection","supportsImagePreviews","supportsUploadProgress","tempInput","supported","disabled","ex","span","localStorage","setItem","match","postMessage","webkitdirectory","ajaxUploading","blobUploading","canDetermineSize","chunking","deleteFileCors","deleteFileCorsXdr","deleteFileCorsXhr","dialogElement","HTMLDialogElement","fileDrop","folderDrop","folderSelection","imagePreviews","imageValidation","itemSizeValidation","pause","progressBar","resume","scaling","tiffPreviews","unlimitedScaledImageSize","uploading","uploadCors","uploadCustomHeaders","uploadNonMultipart","uploadViaPaste","isGenericPromise","maybePromise","then","successArgs","failureArgs","successCallbacks","failureCallbacks","doneCallbacks","state","onSuccess","onFailure","done","BlobProxy","referenceBlob","onCreate","create","UploadButton","createInput","BUTTON_ID_ATTR_NAME","buttonId","title","setMultiple","folders","acceptFiles","position","right","top","fontFamily","fontSize","margin","padding","cursor","height","disposeSupport","onChange","hoverClass","focusClass","ios8BrowserCrashWorkaround","overflow","direction","getInput","getButtonId","isMultiple","optInput","removeAttribute","setAcceptFiles","reset","UploadData","uploaderProxy","getDataByIds","idOrIds","entries","getDataByUuids","uuids","uuid","byUuid","getDataByStatus","status","statusResults","statuses","statusEnum","statusResultIndexes","byStatus","dataIndex","byProxyGroupId","byBatchId","addFile","spec","SUBMITTING","originalName","size","file","batchId","proxyGroupId","onBeforeStatusChange","onStatusChange","retrieve","optionalFilter","removeFileRef","record","setStatus","newStatus","oldStatus","byStatusOldStatusIndex","splice","uuidChanged","newUuid","oldUuid","updateName","newName","updateSize","newSize","setParentId","targetId","parentId","getIdsInProxyGroup","getIdsInBatch","SUBMITTED","REJECTED","QUEUED","CANCELED","PAUSED","UPLOADING","UPLOAD_FINALIZING","UPLOAD_RETRYING","UPLOAD_SUCCESSFUL","UPLOAD_FAILED","DELETE_FAILED","DELETING","DELETED","basePublicApi","addBlobs","blobDataOrArray","params","addFiles","addInitialFiles","cannedFileList","cannedFile","_addCannedFile","_maybeHandleIos8SafariWorkaround","_storedIds","_currentBatchId","processBlob","_handleNewFile","_options","blobs","defaultName","verifiedFiles","processBlobData","blobData","processCanvas","processCanvasData","canvasData","normalizedQuality","processFileOrInput","fileOrInput","files","fileContainer","_prepareItemsForUpload","cancel","uploadData","_uploadData","getName","_handler","cancelAll","storedIdsCopy","storedFileId","clearStoredFiles","continueUpload","enabled","_uploadFile","_onSubmitDelete","doesExist","fileOrBlobId","isValid","drawThumbnail","fileId","imgOrCanvas","maxSize","fromServer","customResizeFunction","fileOrUrl","promiseToReturn","_imageGenerator","_thumbnailUrls","scale","getFile","container","generate","modifiedContainer","reason","getButton","_getButton","_buttonIdsForFileIds","getEndpoint","_endpointStore","uploadDataRecord","getInProgress","getParentId","uploadDataEntry","getUploads","getResumableFilesData","getSize","getNetUploads","_netUploaded","getRemainingAllowedItems","allowedItems","_currentItemLimit","_netUploadedOrQueued","getUuid","isResumable","hasResumeRecord","debug","pauseUpload","expunge","_autoRetries","_retryTimeouts","_preventRetries","_buttons","_paramsStore","_pasteHandler","session","refreshOnReset","_refreshSessionData","_succeededSinceLastAllComplete","_failedSinceLastAllComplete","_totalProgress","_customResumeDataStore","retry","_manualRetry","scaleImage","specs","Scaler","setCustomHeaders","headers","_customHeadersStore","set","setCustomResumeData","setDeleteFileCustomHeaders","_deleteFileCustomHeadersStore","setDeleteFileEndpoint","_deleteFileEndpointStore","setDeleteFileParams","_deleteFileParamsStore","setEndpoint","setForm","elementOrId","_updateFormSupportAndParams","setItemLimit","newItemLimit","setName","setParams","setUuid","_onDeleteComplete","errorMessage","uploadStoredFiles","_itemError","_uploadStoredFiles","basePrivateApi","sessionData","deleteFileEndpoint","deleteFileParams","thumbnailUrl","_annotateWithButtonId","associatedInput","qqButtonId","_getButtonId","_batchError","_createDeleteHandler","DeleteFileAjaxRequester","method","toUpperCase","maxConnections","uuidParamName","request","uuidName","customHeaders","paramsStore","endpointStore","cors","_onDelete","onDeleteComplete","xhrOrXdr","isError","_createPasteHandler","PasteSupport","targetElement","paste","pasteReceived","_handleCheckedCallback","onPasteReceived","_handlePasteSuccess","identifier","_createStore","initialValue","_readOnlyValues_","store","catchall","perIdReadOnlyValues","readOnlyValues","copy","orig","getReadOnlyValues","includeReadOnlyValues","values","addReadOnly","_createUploadDataTracker","_onUploadStatusChange","_maybeAllComplete","setTimeout","_createUploadButton","accept","allowedExtensions","classes","buttonFocus","buttonHover","workarounds","ios8BrowserCrash","iosEmptyVideos","_isAllowedExtension","inputName","_onInputChange","fileInputTitle","_disposeSupport","_createUploadHandler","additionalOptions","namespace","lastOnProgress","preventRetryParam","preventRetryResponseProperty","onProgress","loaded","total","_onProgress","onComplete","retVal","_onComplete","onCancel","cancelFinalizationEffort","_onCancel","onUploadPrep","_onUploadPrep","onUpload","_onUpload","onUploadResult","onUploadChunk","chunkData","_onUploadChunk","onUploadChunkResult","partIndex","onUploadChunkSuccess","_onUploadChunkSuccess","onResume","customResumeData","onAutoRetry","responseJSON","_onAutoRetry","onUuidChanged","setSize","_setSize","getDataByUuid","isQueued","isInProgress","getCustomResumeData","_getCustomResumeData","UploadHandlerController","_fileOrBlobRejected","_formatSize","sizeSymbols","max","toFixed","_generateExtraButtonSpecs","_extraButtonSpecs","extraButtons","extraButtonOptionEntry","extraButtonSpec","_initExtraButton","extraButtonsSpec","_defaultButtonId","buttonOrFileInputOrFile","inputs","fileInput","fileBlobOrInput","_getNotFinished","_getValidationBase","_getValidationDescriptor","fileWrapper","_getValidationDescriptors","fileWrappers","fileDescriptors","_handleCameraAccess","camera","optionRoot","details","callbackRetVal","successParam","newFileWrapperList","actualFile","handler","_customNewFileHandler","_handleNewFileGeneric","addFileToHandler","_trackButton","fileList","extSuppliedName","extension","_handleDeleteSuccess","_handleDeleteFailed","_initFormSupportAndParams","_formSupport","FormSupport","attachedToForm","getFormInputsAsObject","autoUpload","newAutoUpload","newEndpoint","_isDeletePossible","expected","allowXdr","allowed","valid","allowedExt","extRegex","code","maybeNameOrNames","replacement","extensionsForMessage","placeholderMatch","messages","names","validationBase","allowedExtension","formatFileName","sizeLimit","minSizeLimit","placeholder","_onBeforeManualRetry","notFinished","_onAllComplete","ios8SafariUploads","alert","unsupportedBrowserIos8Safari","_maybeParseAndSendUploadError","response","defaultResponseError","_maybeProcessNextItemAfterOnValidateCallback","validItem","stopOnFirstInvalidFile","validationDescriptor","onValidate","_onValidateCallbackSuccess","_onValidateCallbackFailure","successful","_shouldAutoRetry","retryWaitPeriod","autoAttemptDelay","_onBeforeAutoRetry","onManualRetry","clearTimeout","storedItemIndex","fileIndex","onIndividualProgress","_onSubmit","_onSubmitCallbackSuccess","_onSubmitted","onSubmitted","_storeForLater","onSuccessCallback","additionalMandatedParams","adjustedOnSuccessCallback","onSubmitDelete","_deleteHandler","sendDelete","_onTotalProgress","onTotalProgress","enableAuto","_onValidateBatchCallbackFailure","_onValidateBatchCallbackSuccess","validationDescriptors","proposedNetFilesUploadedOrQueued","tooManyItemsError","nextIndex","_validateFileOrBlobData","_upload","onValidateBatch","_preventLeaveInProgress","event","onLeave","Session","_session","addFileRecord","refresh","_sessionRequestComplete","onSessionRequestComplete","onNewSize","maxAutoAttempts","formElementOrId","idToUpload","stillSubmitting","validityChecker","allowEmpty","ImageValidation","validate","image","errorCode","_wrapCallbacks","safeCallback","errorMsg","exception","callbackName","callbackFunc","disableCancelForFormUploads","warnBeforeUnload","filenameParam","forceMultipart","omitDefaultParams","paramsInBody","requireSuccessJson","totalFileSizeName","maxHeight","maxWidth","minHeight","minWidth","maybeXhr","maybeXhrOrXdr","attemptNumber","fileOrBlobData","typeError","sizeError","minSizeError","emptyError","noFilesError","maxHeightImageError","maxWidthImageError","minHeightImageError","minWidthImageError","retryFailTooManyItems","concurrent","mandatory","paramNames","partByteOffset","chunkSize","totalFileSize","totalParts","partSize","jsonPayload","resetOnStatus","recordsExpireIn","resuming","customKeys","fileOrBlobName","sendCredentials","interceptSubmit","customResizer","sendOriginal","orient","defaultType","defaultQuality","failureText","includeExif","sizes","ImageGenerator","_scaler","handleNewFile","TotalProgress","entry","AjaxRequester","isSimpleMethod","containsNonSimpleHeaders","containsNonSimple","header","isXdr","getCorsAjaxTransport","ontimeout","onprogress","getXhrOrXdr","suppliedXhr","requestData","dequeue","nextId","queue","sendRequest","xdrError","isResponseSuccessful","getParams","onDemandParams","additionalParams","mandatedParams","optXhr","payload","onSend","createUrl","additionalQueryParams","getXdrLoadHandler","getXdrErrorHandler","onreadystatechange","getXhrReadyStateChangeHandler","registerForUploadProgress","open","setHeaders","send","shouldParamsBeInQueryString","contentType","stringify","addToPath","readyState","lengthComputable","onDemandHeaders","additionalHeaders","allHeaders","acceptHeader","setRequestHeader","allowXRequestedWithAndCacheControl","responseCode","successfulResponseCodes","prepareToSend","validMethods","DELETE","PATCH","POST","PUT","GET","initTransport","path","cacheBuster","withPath","appendToPath","withParams","withQueryParams","_additionalQueryParams_","withHeaders","withPayload","thePayload","withCacheBuster","qqtimestamp","Date","getTime","canceled","UploadHandler","proxy","fileState","fileItem","getThirdPartyFileId","_getFileState","_setThirdPartyFileId","thirdPartyFileId","_wasCanceled","preventRetryResponse","controller","chunkingPossible","concurrentChunkingPossible","chunked","chunkIdx","_getChunkData","attemptingResume","chunkProgress","_getChunkDataForCallback","finalize","finalizeChunks","normaizedResponse","normalizeResponse","_maybeDeletePersistedChunkData","cleanup","normalizedResponse","handleFailure","clearCachedChunk","inProgressIdx","responseToReport","inProgressChunksArray","inProgress","remaining","unshift","ignoreFailure","_getXhrs","ckid","ckXhr","abort","_cancelled","moveInProgressToRemaining","connectionManager","free","hasMoreParts","nextPart","nextIdx","_getTotalChunks","reevaluateChunking","sendNext","inProgressChunks","available","requestOverrides","uploadChunkData","overrides","uploadChunk","inProgressChunkIdx","_maybePersistChunkedState","clearXhr","_open","_openChunks","_waiting","openChunkEntriesCount","openChunksCount","openChunkIndexes","dontAllowNext","allowNext","waitingIndex","connectionsIndex","getProxyOrBlob","getWaitingOrConnected","waitingOrConnected","chunks","parseInt","isUsingConnection","pop","openChunksEntry","simple","uploadFile","maybeNewUuid","_clearXhrs","getProxy","initHandler","handlerType","traditional","handlerModuleSubtype","onFinalizing","_removeExpiredChunkingRecords","isDeferredEligibleForUpload","maybeDefer","generatedBlob","updateBlob","maybeSendDeferredFiles","errorResponse","idsInGroup","uploadedThisId","idInGroup","now","originalResponse","_shouldChunkThisFile","blobToUpload","cancelRetVal","isProxied","_getLocalStorageId","isAttemptingResume","WindowReceiveMessage","callbackWrapperDetachers","receiveMessage","onMessageCallbackWrapper","stopReceivingMessages","detacher","FormUploadHandler","expungeFile","detachLoadEvents","isCors","postMessageCallbackTimers","corsMessageReceiver","iframe","getElementById","_getIframeName","getFileIdForIframeName","iframeName","initIframeForUpload","body","registerPostMessageCallback","onloadCallbacks","onloadCallback","_parseJsonResponse","_detachLoadEvent","formHandlerInstanceId","_attachLoadEvent","responseDescriptor","contentDocument","_createIframe","_initFormForUpload","targetName","innerHtmlOrMessage","XhrUploadHandler","xhrId","ajaxRequester","_getAjaxRequester","getChunkSize","chunkFiles","resumeEnabled","blobOrProxy","_initTempState","_maybePrepareForResume","cachedChunks","tempState","xhrs","ajaxRequesters","responseParser","lastChunkIdx","_getXhr","resumableFilesData","_iterateResumeRecords","notResumable","optInProgress","optRemaining","chunkingState","reverse","paused","totalChunks","parts","newBlob","chunkId","_createXhr","optChunkIdx","_registerXhr","chunkIndex","fileSize","startBytes","endBytes","part","count","startByte","endByte","localStorageId","forEach","_getMimeType","_getPersistableData","ceil","_markNotResumable","removeItem","persistedData","lastUpdated","_registerProgressHandler","progressCalculator","totalSuccessfullyLoadedForFile","loadedForRequest","totalForRequest","estActualChunkLoaded","totalLoadedForFile","chunkLoaded","optAjaxRequester","xhrsId","expirationDays","expirationDate","setDate","getDate","requester","_method","detectSubsampling","img","ctx","iw","naturalWidth","ih","naturalHeight","width","getContext","drawImage","getImageData","detectVerticalSquash","alpha","ratio","sy","ey","py","renderImageToDataURL","doSquash","renderImageToCanvas","maybeCalculateDownsampledDimensions","origHeight","origWidth","newHeight","sqrt","newWidth","modifiedDimensions","save","resize","renderImageToCanvasWithCustomResizer","imageHeight","imageWidth","orientation","targetHeight","targetWidth","transformCoordinate","tmpCtx","sx","dx","tmpCanvas","vertSquashRatio","dw","dh","dy","clearRect","restore","qqImageRendered","resizeInfo","sourceCanvas","sourceCanvasContext","targetCanvas","translate","rotate","PI","MegaPixImage","srcImage","errorCallback","Image","URL","createObjectURL","webkitURL","src","listeners","imageLoadListeners","opt","imgWidth","imgHeight","optionsKey","optionsValue","oldTargetSrc","onrender","isImg","el","isCanvas","isImgCorsSupported","crossOrigin","isCanvasSupported","determineMimeOfFileName","nameWithPath","pathSegments","isCrossOrigin","targetProtocol","targetHostname","targetPort","targetAnchor","href","protocol","port","hostname","location","registerImgLoadListeners","registerCanvasDrawImageListener","registerThumbnailRenderedListener","registered","draw","drawPreview","Identify","megapixErrorHandler","isPreviewable","dummyExif","exif","Exif","mpImg","Orientation","failureMsg","drawOnCanvasOrImgFromUrl","canvasOrImg","tempImg","tempImgRender","drawOnImgFromUrlWithCssScaling","drawFromUrl","fileBlobOrUrl","_testing","parseLittleEndian","hex","pow","seekToApp1","offset","theOffset","thePromise","segmentLength","getApp1Offset","isLittleEndian","app1Start","getDirEntryCount","littleEndian","getIfd","dirEntries","getDirEntries","ifdHex","getTagValues","tagsToFind","TAG_IDS","vals","tagValHex","tagValLength","idHex","tagsToFindIdx","TAG_INFO","274","parser","onParseFailure","app1Offset","dirEntryCount","tagValues","isIdentifiable","magicBytes","questionableBytes","identifiable","magicBytesEntries","magicBytesArrayEntry","previewable","isPreviewableSync","PREVIEWABLE_MIME_TYPES","fileMime","isRecognizedImage","image/jpeg","image/gif","image/png","image/bmp","image/tiff","hasNonZeroLimits","limits","atLeastOne","limit","getWidthHeight","sizeDetermination","getFailingLimit","dimensions","failingLimit","limitName","limitValue","limitMatcher","dimensionPropName","actualValue","validationEffort","isJsonResponseValid","handleFileItems","fileItems","someItemsIgnored","err","refreshEffort","refreshCompleteCallback","requesterOptions","SessionAjaxRequester","queryServer","responseText","includeOriginal","failedToScaleText","_getSortedSizes","getFileRecords","originalFileUuid","originalFileName","originalBlobOrBlobData","records","originalBlob","sizeRecord","outputType","_determineOutputType","requestedType","refType","_getName","_generateScaledImage","failedText","api","scaledIds","originalId","blobSize","scaledId","qqparentuuid","qqparentsize","param","scalingEffort","scalingOptions","scaler","referenceType","scaledVersionProperties","startOfExt","versionType","scaledName","scaledExt","nameAppendage","sort","b","sourceFile","imageGenerator","scaledImageDataUri","signalSuccess","_insertExifHeader","scaledImageDataUriWithExif","originalImage","reader","insertionEffort","originalImageDataUri","ExifRestorer","readAsDataURL","_dataUriToBlob","_createBlob","KEY_STR","encode64","chr1","chr2","enc1","enc2","enc3","output","chr3","enc4","isNaN","origFileBase64","resizedFileBase64","rawImage","decode64","segments","slice2Segments","exifManipulation","exifArray","getExifArray","newImageArray","insertExif","seg","x","imageData","buf","separatePoint","mae","ato","array","rawImageArray","head","endPoint","perFileProgress","totalLoaded","totalSize","lastLoadedSent","lastTotalSent","callbackProxy","noRetryableFiles","retryable","none","failedId","updateTotalProgress","onNew","newLoaded","newTotal","oldLoaded","oldTotal","isImage","unregisterPasteHandler","detachPasteHandler","clipboardData","getAsFile","startUpload","determineNewEndpoint","formEl","validateForm","nativeSubmit","checkValidity","maybeUploadOnSubmit","submit","_form2Obj","notIrrelevantType","irrelevantTypes","radioOrCheckbox","ignoreValue","checked","selectValue","select","selected","elements","getIframeContentJson","doc","innerHtml","contentWindow","nodeValue","createForm","responseFromMessage","multipart","addChunkingSpecificParams","allChunksDoneRequester","AllChunksDoneAjaxRequester","createReadyStateChangedHandler","onUploadOrChunkComplete","getChunksCompleteParams","isErrorUploadResponse","parseResponse","sendChunksCompleteRequest","complete","setParamsAndGetEntityToSend","entityToSendParams","xhrOverrides","customParams","defaultParams","xhrOverrideParams","setUploadHeaders","headersOptions","headerOverrides","headerName","headerValue","extraHeaders","uploadChunkParams","toSend","promises","endpointHandler","DragAndDrop","uploadDroppedFiles","uploadDropZone","filesAsArray","dropLog","dropDisabled","processingDroppedFilesComplete","getElement","traverseFileTree","parseEntryPromise","qqPath","extractDirectoryPath","droppedFiles","fileError","fullPath","isDirectory","getFilesInDirectory","entriesLeft","indexOfNameInFullPath","accumEntries","existingPromise","dirReader","createReader","readEntries","newEntries","handleDataTransfer","pendingFolderPromises","handleDataTransferPromise","processingDroppedFiles","allowMultipleItems","dropError","setupDropzone","dropArea","dropZone","UploadDropZone","HIDE_ZONES_EVENT_NAME","onEnter","dropActive","stopPropagation","onLeaveNotDescendants","onDrop","HIDE_BEFORE_ENTER_ATTR","uploadDropZones","isFileDrag","dragEvent","fileDrag","types","leavingDocumentOut","y","dropZoneElements","dropZones","maybeHideDropZones","HTMLElement","setupExtraDropzone","removeDropzone","dzs","targetEl","errorSpecifics","dragoverShouldBeCanceled","isValidFileDrag","effectTest","dt","isSafari","effectAllowed","isOrSetDropDisabled","isDisabled","preventDrop","triggerHidezonesEvent","triggerUsingOldApi","hideZonesEvent","createEvent","initEvent","CustomEvent","dispatchEvent","dropOutsideDisabled","dropEffect","effect","relatedTarget","elementFromPoint","clientX","clientY","uiPublicApi","_parent","_templating","addCacheToDom","clearFiles","addExtraDropzone","_dnd","removeExtraDropzone","getItemByFileId","isHiddenForever","getFileContainer","_setupDragAndDrop","_totalFilesInBatch","_filesInBatchAddedToUi","_setupClickAndEditEventHandlers","formattedFilename","updateFilename","uploadPaused","continued","uploadContinued","getId","fileContainerOrChildEl","getFileId","getDropTarget","qqDropTarget","uiPrivateApi","_removeFileItem","removeFile","_fileButtonsClickHandler","FileButtonsClickHandler","_bindFileButtonsClickEvent","_focusinEventSupported","_isEditFilenameEnabled","_filenameClickHandler","_bindFilenameClickEvent","_filenameInputFocusInHandler","_bindFilenameInputFocusInEvent","_filenameInputFocusHandler","_bindFilenameInputFocusEvent","dragAndDrop","extraDropzones","templating","defaultDropZone","getDropZone","showDropProcessing","hideDropProcessing","errorData","lvl","onDeleteFile","onRetry","onPause","onContinue","onGetName","isEditFilenamePossible","FilenameClickHandler","FilenameInputFocusHandler","_filenameEditHandler","onGetUploadStatus","onSetName","onEditingStatusChange","isEditing","qqInput","getEditInput","qqFileContainer","hideFilename","hideEditIcon","showFilename","showEditIcon","markFilenameEditable","hideRetry","setStatusText","_classes","retrying","hidePause","FilenameInputFocusInHandler","hideSpinner","resetTotalProgress","reportDirectoryPaths","qqpath","_addToList","addHandler","updateProgress","hideCancel","hideProgress","waitingForResponse","_displayFileSize","completeUpload","_markFileAsSuccessful","fail","showCancel","isRetryPossible","showRetry","_controlFailureTextDisplay","parentRetVal","newResult","showDeleteButton","_maybeUpdateThumbnail","showSpinner","allowPause","retryNumForDisplay","maxAuto","retryNote","_showCancelLink","showAutoRetryNote","autoRetryNote","resetProgress","_onSubmitDeleteSuccess","forceConfirm","_showDeleteConfirm","_sendDeleteRequest","deletingFailedText","hideDeleteButton","deletingStatusText","confirmMessage","deleteRequestArgs","showConfirm","canned","prependData","prependIndex","dontDisplay","hideScaled","prependFiles","disableCancel","_handledProxyGroup","_clearList","addFileToCache","updateThumbnail","thumbnails","generatePreview","fileSizeOnSubmit","loadedSize","sizeForDisplay","_formatProgress","uploadedSize","formatProgress","mode","responseProperty","failureReason","failedUploadTextDisplay","failUpload","enableTooltip","_showTooltip","_setupPastePrompt","namePromptMessage","defaultVal","showPrompt","placeholders","waitUntilResponse","listElement","editable","tooManyFilesError","unsupportedBrowser","promptForName","maxCount","notAvailablePath","waitingPath","timeBetweenThumbs","hasDialog","showDialog","confirm","defaultValue","prompt","Templating","templateIdOrEl","containerEl","fileContainerEl","maxThumbs","waitUntilUpdate","thumbnailNotAvailable","waitingForThumbnail","renderFailure","isEditElementsExist","isRetryElementExist","templateDom","showThumbnails","serverScale","fileBatch","content","createDocumentFragment","map","isCancelDisabled","generatedThumbnails","thumbnailQueueMonitorRunning","thumbGenerationQueue","thumbnailMaxSize","selectorClasses","alertDialog","dialogCancelButton","confirmDialog","dialogMessage","dialogOkButton","promptDialog","drop","list","progressBarContainer","totalProgressBarContainer","totalProgressBar","spinner","continueButton","deleteButton","statusText","editFilenameInput","editNameIcon","dropText","dropProcessing","dropProcessingSpinner","previewGeneration","cachedThumbnailNotAvailableImg","cachedWaitingForThumbnailImg","displayWaitingImg","waitingImgPlacement","maybeScalePlaceholderViaCss","show","generateNewPreview","getThumbnail","qqThumbnailId","maybeSetDisplayNotAvailableImg","generateNextQueuedPreview","queuedThumbRequest","update","processUpdateQueuedPreviewRequest","processNewQueuedPreviewRequest","getCancel","getTemplateEl","getContinue","getDialog","getDelete","getDropProcessing","getEditIcon","getPause","getProgress","getRetry","getSpinner","cssClass","previewing","notAvailableImgPlacement","prependFile","parentEl","beforeEl","optFileOrBlob","relatedThumbnailId","useCachedPreview","showWaitingImg","setProgressBarWidth","percent","bar","progressBarSelector","targetThumbnailId","cachedThumbnailId","targetThumbnail","cachedThumbnail","scriptEl","scriptHtml","fileListNode","tempTemplateEl","fileListEl","defaultButton","dropTextEl","uploaderEl","cloneNode","fileTemplate","notAvailableUrl","waitingUrl","updatedImg","hideTotalProgress","cantRenderEl","prependInfo","hideForever","batch","thumb","fileEl","fileNameEl","waitingImg","currentNode","getFileList","filenameEl","isFileName","icon","isEditIcon","isEditInput","isCancel","allowContinueButton","isPause","isContinueButton","isDeleteButton","isRetry","textEl","dialog","messageEl","inputEl","cancelBtn","okBtn","closeHandler","cancelClickHandler","okClickHandler","close","showModal","UiEventHandler","protectedApi","eventType","srcElement","onHandled","attachTo","getFileIdFromItem","qqFileId","getDisposeSupport","examineEvent","buttonHandlers","buttonType","firstLetterCapButtonType","inheritedInternalApi","handleFilenameEdit","FilenameEditHandler","handleInputFocus","getFilenameSansExtension","filenameSansExt","getOriginalExtension","origName","handleNameUpdate","newFilenameInputEl","origExtension","registerInputBlurHandler","registerInputEnterKeyHandler","keyCode","which","focusInput","focus","selectors","documentElement","_qsa","styleSheet","cssText","scrollBy","getElementsByClassName","classNames","TypeError","ret","fun","t","thisp","B64_ALPHABET","bits","fromCharCode","btoa","o1","o2","o3","e1","e2","e3","e4","out","proto","__proto__","performance","nowOffset","timing","navigationStart","requestAnimationFrame","webkitRequestAnimationFrame","webkitCancelAnimationFrame","cancelAnimationFrame","mozRequestAnimationFrame","mozCancelAnimationFrame","prepareImageElement","engineSettings","holderFlags","parseURL","domain","prepareDOMElement","flags","instanceOptions","holder","theme","App","settings","themes","gray","stylesheets","firstQuestionMark","basics","holderURL","dimensionData","fluid","querystring","utils","truthy","ratioWidth","parseFloat","ratioHeight","floor","auto","bg","parseColor","fg","autoFg","textmode","font","align","lineWrap","nowrap","outline","vars","cache","themeKeys","_theme","prepSettings","_engineSettings","dimensionsCaption","holderTemplateRe","nodeName","textLines","k","encodeHtmlEntity","holderTemplateMatches","noFontFallback","setup","supportsCanvas","renderer","reRender","DOM","setAttr","data-background-src","domProps","dataAttr","holderData","alt","renderSettings","holderSettings","backgroundColor","resizeUpdate","resizableImages","updateResizableElements","setInitialDimensions","getRenderedImage","sgCanvasRenderer","sceneGraph","svgRenderer","supportsSVG","scene","buildSceneGraph","backgroundImage","noBackgroundSize","backgroundSize","data-holder-rendered","finalizeLine","line","defaults","family","textSize","units","weight","fontweight","noWrap","exactDimensions","lineWrapRatio","sceneMargin","maxLineWidth","SceneGraph","Shape","holderBg","Rect","fill","outlineColor","Color","properties","lighten","lighterThan","toHex","holderTextColor","holderBgColor","lightColor","darkColor","blendAlpha","holderTextGroup","Group","moveTo","tpdata","textPositionData","stagingRenderer","leading","boundingBox","textNode","lineCount","lineKey","offsetX","offsetY","lineIndex","words","word","Text","newline","spaceWidth","stageWidth","stageHeight","bigSide","smallSide","min","dimensionCheck","fluidConfig","setInvisible","fluidHeight","fluidWidth","initialDimensions","visibilityCheck","renderableImages","invisibleImages","Holder","invisibleId","debounce","debounceTimer","resizeEvent","onDomReady","SVG","constants","SVG_NS","svg_ns","addTheme","addImage","getNodeArray","node","newEl","setResizeUpdate","userOptions","preempted","renderers","bgnodes","stylenodes","objects","svgXMLStylesheet","styleNode","attributes","rel","proxyLink","stylesheetURL","host","pathname","search","bgNode","getComputedStyle","getPropertyValue","dataBackgroundImage","rawURL","holderString","holderStringIndex","fragment","objectAttr","dataSrc","objectHasSrcURL","objectHasDataSrcURL","imageAttr","rendered","imageHasSrc","imageHasDataSrcURL","imageRendered","imageExists","exists","social","industrial","sky","vine","lava","svg","stagingText","stagingTextNode","graph","rootNode","firstTimeSetup","initSVG","createTextNode","visibility","left","htgProps","cssProps","font-weight","font-size","font-family","stagingTextBBox","getBBox","newlines","computedNoSpaceLength","getComputedTextLength","diffLength","wordWidths","decodeHtmlEntity","bbox","flag","regex","visibilityCheckStarted","createElementNS","createSVGRect","Turbolinks","win","ready","isReady","defer","completed","w3c","LOAD","READYSTATE","COMPLETE","REMOVEEVENTLISTENER","DOMCONTENTLOADED","FALSE","DETACHEVENT","ONREADYSTATECHANGE","ONLOAD","wait","DOMContentLoaded","docElem","_top","frameElement","doScroll","doScrollCheck","encode","decode","decodeURIComponent","arrayRegex","objectRegex","pairs","isBuffer","_isBuffer","valueOf","sceneProperties","merge","nodeCount","SceneNode","z","RootNode","charCode","dec","clientHeight","clientWidth","retval","hexre","rgbre","rgbare","canvasRatio","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","defs","initialize","webkitMatchesSelector","childNodes","viewBox","preserveAspectRatio","svgStringToDataURI","svgString","base64","unescape","serializeSVG","XMLSerializer","serializer","svgCSS","xml","createXML","csspi","createProcessingInstruction","serializeToString","svgText","tag","attrs","DOMParser","parseFromString","NodeList","Node","HTMLCollection","color","original","rgb2hex","g","decimal","hsl2rgb","H","C","abs","X","raw","u","v","rgb","yuv","multiplier","cm","bm","cr","cg","cb","addHash","Ca","Cb","convertShape","shape","templates","textCss","outlinePath","bgWidth","bgHeight","outlineWidth","outlineOffsetWidth","shaven","stylesheetXml","stylesheet","holderId","textGroup","wordTags","wordKey","wordTag","outlineProperties","stroke-width","stroke","sceneContent","xmlns","returnObject","replacer","HTMLString","attributeKey","doesEscape","sugarString","tags","attr","reference","class","subArray","escapeHtml","matchHtmlRegExp","escape","lastIndex","dpr","textBaseline","fillStyle","fillRect","strokeStyle","lineWidth","lineTo","fillText","isMeteorPackage","Meteor","Package","buildOptions","getI18n","fileSize2Bytes","thousand","baseUnit","kb","mb","gb","tmpCode","sizeNumber","num","i18n","cn","choseFileButton","dropHere","fileTypes","vi","en","_this","sizeLimitStr","_vm","_h","$createElement","_c","_self","_e","staticClass","ref","_v","_s","directives","rawName","expression","staticStyle","qq-drop-area-text","_m","role","aria-live","aria-relevant","aria-valuenow","aria-valuemin","aria-valuemax","qq-max-size","qq-server-scale","aria-label","tabindex","qq-hide-dropzone","esExports"],"mappings":"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","file":"v-uploader.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"vUploader\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vUploader\"] = factory();\n\telse\n\t\troot[\"vUploader\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"vUploader\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vUploader\"] = factory();\n\telse\n\t\troot[\"vUploader\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fine_uploader__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fine_uploader___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fine_uploader__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_holderjs__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_holderjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_holderjs__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants__ = __webpack_require__(7);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n    name: \"v-uploader\",\n    props: {\n        language: {\n            type: String,\n            default: 'cn'\n        },\n        //show preview box in single upload mode\n        preview: {\n            type: Boolean,\n            default: true\n        },\n        previewImg: String,\n        buttonText: String,\n        buttonIcon: {\n            type: Boolean,\n            default: true\n        },\n        previewWidth: {\n            type: Number,\n            default: 200\n        },\n        previewHeight: {\n            type: Number,\n            default: 150\n        },\n        /**\n         * file upload type\n         * true: multiple file upload\n         * false: single file upload(default)\n         */\n        multiple: {\n            type: Boolean,\n            default: false\n        },\n        //upload file object name\n        uploadFileObjName: {\n            type: String,\n            default: 'uploadFileObj'\n        },\n        //Maximum number of items that can be potentially uploaded in this session.\n        //set 0 to unlimited\n        itemLimit: {\n            type: Number,\n            default: 0\n        },\n        //upload file size limit\n        fileSizeLimit: {\n            type: String,\n            default: '5MB'\n        },\n        // allow to upload file types\n        fileTypeExts: {\n            type: String,\n            default: 'jpeg,jpg,gif,png'\n        },\n        imageMaxHeight: {\n            type: Number,\n            default: 0\n        },\n        imageMaxWidth: {\n            type: Number,\n            default: 0\n        },\n        imageMinHeight: {\n            type: Number,\n            default: 0\n        },\n        imageMinWidth: {\n            type: Number,\n            default: 0\n        },\n        /**\n         * the callback before file upload\n         *\n         * @param id - file id\n         * @param name - file name\n         *\n         * @return boolean - return false to abort file upload\n         */\n        beforeUpload: Function,\n        //file uploader service url\n        uploadFileUrl: {\n            type: String,\n            default: ''\n        },\n        //file delete service url\n        deleteFileUrl: {\n            type: String,\n            default: ''\n        },\n        //set the way to show upload message(upload fail message)\n        showMessage: {\n            type: Function,\n            default: undefined\n        }\n    },\n    data: function data() {\n        return {\n            uploadedFiles: [],\n            deleteIndexs: [],\n\n            options: {},\n            /**\n             * upload success callback\n             * @param id - file id\n             * @param name - file name\n             * @param json - uploaded file detail info\n             */\n            callback: undefined,\n\n            singleUploadImg: '',\n            ui: {},\n            //fileSizeLimit: 0,\n            uploaderClass: {\n                'v-uploader': true,\n                'single-mode': false,\n                'multiple-mode': false\n            }\n        };\n    },\n\n    watch: {\n        previewImg: function previewImg(val) {\n            if (val) this.singleUploadImg = val;\n        }\n    },\n    beforeMount: function beforeMount() {\n        var that = this;\n        if (this.multiple) this.uploaderClass['multiple-mode'] = true;else this.uploaderClass['single-mode'] = true;\n\n        this.ui = __WEBPACK_IMPORTED_MODULE_2__constants__[\"b\" /* getI18n */](this.language);\n        var imgHolder = 'holder.js/' + this.previewWidth + 'x' + this.previewHeight + '?text=' + this.ui.thumbnail + '&size=16';\n        this.singleUploadImg = this.previewImg ? this.previewImg : imgHolder;\n\n        if (!this.multiple) {\n            this.callback = function (data) {\n                if (data && typeof data.success !== 'undefined' && data.success) {\n                    if (that.preview) that.singleUploadImg = data.url;\n                    that.$emit('done', [data]);\n                }\n            };\n        } else {\n            this.callback = function (data) {\n                if (data && typeof data.success !== 'undefined' && data.success) {\n                    that.uploadedFiles.push(data);\n                }\n            };\n        }\n        this.options = __WEBPACK_IMPORTED_MODULE_2__constants__[\"a\" /* buildOptions */].call(this);\n    },\n    mounted: function mounted() {\n        var that = this;\n\n        if (!this.multiple) {\n            if (this.preview && !this.previewImg) __WEBPACK_IMPORTED_MODULE_1_holderjs___default.a.run({ images: this.$refs.simpleImg });\n            this.options.button = this.$refs.upload;\n            //upload error callback\n            //basic mode work only\n            that.options.callbacks.onError = function (id, name, errorReason, xhr) {\n                if (that.showMessage && typeof that.showMessage === 'function') that.showMessage(that, errorReason);\n            };\n            if (this.beforeUpload && typeof this.beforeUpload === 'function') that.options.callbacks.onSubmit = this.beforeUpload;\n            new __WEBPACK_IMPORTED_MODULE_0_fine_uploader___default.a.FineUploaderBasic(that.options);\n        } else {\n            that.options.deleteFile.endpoint = this.deleteFileUrl;\n            that.options.template = this.$refs.uploadArea;\n            that.options.element = this.$refs.multipleUpload;\n            that.options.showMessage = function (message) {\n                if (that.showMessage && typeof that.showMessage === 'function') that.showMessage(that, message);\n            };\n            that.options.callbacks.onDelete = function (id) {\n                that.deleteIndexs.push(id);\n                that.$emit('done', that.uploadedFiles.filter(function (val, index) {\n                    return !that.deleteIndexs.includes(index);\n                }));\n            };\n            that.options.callbacks.onAllComplete = function (succeeded, failed) {\n                that.$emit('done', that.uploadedFiles);\n            };\n            if (this.itemLimit) this.options.validation.itemLimit = this.itemLimit;\n            if (this.beforeUpload && typeof this.beforeUpload === 'function') that.options.callbacks.onSubmit = this.beforeUpload;\n            new __WEBPACK_IMPORTED_MODULE_0_fine_uploader___default.a.FineUploader(that.options);\n        }\n    }\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__ = __webpack_require__(2);\n\n\nvar Plugin = {\n    install: function install(Vue) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (Object.keys(options).length) {\n            if (typeof options.language === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.language.default = options.language;\n            if (typeof options.preview === 'boolean') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.preview.default = options.preview;\n            if (typeof options.buttonText === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.buttonText.default = options.buttonText;\n            if (typeof options.buttonIcon === 'boolean') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.buttonIcon.default = options.buttonIcon;\n            if (typeof options.previewWidth === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.previewWidth.default = options.previewWidth;\n            if (typeof options.previewHeight === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.previewHeight.default = options.previewHeight;\n            if (typeof options.multiple === 'boolean') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.multiple.default = options.multiple;\n            if (typeof options.uploadFileObjName === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.uploadFileObjName.default = options.uploadFileObjName;\n            if (typeof options.itemLimit === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.itemLimit.default = options.itemLimit;\n            if (typeof options.fileSizeLimit === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.fileSizeLimit.default = options.fileSizeLimit;\n            if (typeof options.fileTypeExts === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.fileTypeExts.default = options.fileTypeExts;\n            if (typeof options.imageMaxHeight === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.imageMaxHeight.default = options.imageMaxHeight;\n            if (typeof options.imageMaxWidth === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.imageMaxWidth.default = options.imageMaxWidth;\n            if (typeof options.imageMinHeight === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.imageMinHeight.default = options.imageMinHeight;\n            if (typeof options.imageMinWidth === 'number') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.imageMinWidth.default = options.imageMinWidth;\n\n            if (typeof options.uploadFileUrl === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.uploadFileUrl.default = options.uploadFileUrl;\n            if (typeof options.deleteFileUrl === 'string') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.deleteFileUrl.default = options.deleteFileUrl;\n            if (typeof options.showMessage === 'function') __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].props.showMessage.default = options.showMessage;\n        }\n        Vue.component(__WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */].name, __WEBPACK_IMPORTED_MODULE_0__Uploader_vue__[\"a\" /* default */]);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Plugin);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Uploader_vue__ = __webpack_require__(0);\n/* unused harmony namespace reexport */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b4b4387_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Uploader_vue__ = __webpack_require__(8);\nvar normalizeComponent = __webpack_require__(3)\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Uploader_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b4b4387_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_Uploader_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Component.exports);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(5);\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;// Fine Uploader 5.16.2 - MIT licensed. http://fineuploader.com\n(function(global) {\n    var qq = function(element) {\n        \"use strict\";\n        return {\n            hide: function() {\n                element.style.display = \"none\";\n                return this;\n            },\n            attach: function(type, fn) {\n                if (element.addEventListener) {\n                    element.addEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + type, fn);\n                }\n                return function() {\n                    qq(element).detach(type, fn);\n                };\n            },\n            detach: function(type, fn) {\n                if (element.removeEventListener) {\n                    element.removeEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.detachEvent(\"on\" + type, fn);\n                }\n                return this;\n            },\n            contains: function(descendant) {\n                if (!descendant) {\n                    return false;\n                }\n                if (element === descendant) {\n                    return true;\n                }\n                if (element.contains) {\n                    return element.contains(descendant);\n                } else {\n                    return !!(descendant.compareDocumentPosition(element) & 8);\n                }\n            },\n            insertBefore: function(elementB) {\n                elementB.parentNode.insertBefore(element, elementB);\n                return this;\n            },\n            remove: function() {\n                element.parentNode.removeChild(element);\n                return this;\n            },\n            css: function(styles) {\n                if (element.style == null) {\n                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n                }\n                if (styles.opacity != null) {\n                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                    }\n                }\n                qq.extend(element.style, styles);\n                return this;\n            },\n            hasClass: function(name, considerParent) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n            },\n            addClass: function(name) {\n                if (!qq(element).hasClass(name)) {\n                    element.className += \" \" + name;\n                }\n                return this;\n            },\n            removeClass: function(name) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n                return this;\n            },\n            getByClass: function(className, first) {\n                var candidates, result = [];\n                if (first && element.querySelector) {\n                    return element.querySelector(\".\" + className);\n                } else if (element.querySelectorAll) {\n                    return element.querySelectorAll(\".\" + className);\n                }\n                candidates = element.getElementsByTagName(\"*\");\n                qq.each(candidates, function(idx, val) {\n                    if (qq(val).hasClass(className)) {\n                        result.push(val);\n                    }\n                });\n                return first ? result[0] : result;\n            },\n            getFirstByClass: function(className) {\n                return qq(element).getByClass(className, true);\n            },\n            children: function() {\n                var children = [], child = element.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        children.push(child);\n                    }\n                    child = child.nextSibling;\n                }\n                return children;\n            },\n            setText: function(text) {\n                element.innerText = text;\n                element.textContent = text;\n                return this;\n            },\n            clearText: function() {\n                return qq(element).setText(\"\");\n            },\n            hasAttribute: function(attrName) {\n                var attrVal;\n                if (element.hasAttribute) {\n                    if (!element.hasAttribute(attrName)) {\n                        return false;\n                    }\n                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n                } else {\n                    attrVal = element[attrName];\n                    if (attrVal === undefined) {\n                        return false;\n                    }\n                    return /^false$/i.exec(attrVal) == null;\n                }\n            }\n        };\n    };\n    (function() {\n        \"use strict\";\n        qq.canvasToBlob = function(canvas, mime, quality) {\n            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n        };\n        qq.dataUriToBlob = function(dataUri) {\n            var arrayBuffer, byteString, createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                } else {\n                    return new Blob([ data ], {\n                        type: mime\n                    });\n                }\n            }, intArray, mimeString;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return createBlob(arrayBuffer, mimeString);\n        };\n        qq.log = function(message, level) {\n            if (window.console) {\n                if (!level || level === \"info\") {\n                    window.console.log(message);\n                } else {\n                    if (window.console[level]) {\n                        window.console[level](message);\n                    } else {\n                        window.console.log(\"<\" + level + \"> \" + message);\n                    }\n                }\n            }\n        };\n        qq.isObject = function(variable) {\n            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n        };\n        qq.isFunction = function(variable) {\n            return typeof variable === \"function\";\n        };\n        qq.isArray = function(value) {\n            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n        };\n        qq.isItemList = function(maybeItemList) {\n            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n        };\n        qq.isNodeList = function(maybeNodeList) {\n            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n        };\n        qq.isString = function(maybeString) {\n            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n        };\n        qq.trimStr = function(string) {\n            if (String.prototype.trim) {\n                return string.trim();\n            }\n            return string.replace(/^\\s+|\\s+$/g, \"\");\n        };\n        qq.format = function(str) {\n            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n            qq.each(args, function(idx, val) {\n                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n                newStr = strBefore + val + strAfter;\n                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n                if (nextIdxToReplace < 0) {\n                    return false;\n                }\n            });\n            return newStr;\n        };\n        qq.isFile = function(maybeFile) {\n            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n        };\n        qq.isFileList = function(maybeFileList) {\n            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n        };\n        qq.isFileOrInput = function(maybeFileOrInput) {\n            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n        };\n        qq.isInput = function(maybeInput, notFile) {\n            var evaluateType = function(type) {\n                var normalizedType = type.toLowerCase();\n                if (notFile) {\n                    return normalizedType !== \"file\";\n                }\n                return normalizedType === \"file\";\n            };\n            if (window.HTMLInputElement) {\n                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            if (maybeInput.tagName) {\n                if (maybeInput.tagName.toLowerCase() === \"input\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        qq.isBlob = function(maybeBlob) {\n            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n                return true;\n            }\n        };\n        qq.isXhrUploadSupported = function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n        };\n        qq.createXhrInstance = function() {\n            if (window.XMLHttpRequest) {\n                return new XMLHttpRequest();\n            }\n            try {\n                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            } catch (error) {\n                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n                return null;\n            }\n        };\n        qq.isFolderDropSupported = function(dataTransfer) {\n            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n        };\n        qq.isFileChunkingSupported = function() {\n            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n        };\n        qq.sliceBlob = function(fileOrBlob, start, end) {\n            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n            return slicer.call(fileOrBlob, start, end);\n        };\n        qq.arrayBufferToHex = function(buffer) {\n            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n            qq.each(bytes, function(idx, byt) {\n                var byteAsHexStr = byt.toString(16);\n                if (byteAsHexStr.length < 2) {\n                    byteAsHexStr = \"0\" + byteAsHexStr;\n                }\n                bytesAsHex += byteAsHexStr;\n            });\n            return bytesAsHex;\n        };\n        qq.readBlobToHex = function(blob, startOffset, length) {\n            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n            fileReader.onload = function() {\n                promise.success(qq.arrayBufferToHex(fileReader.result));\n            };\n            fileReader.onerror = promise.failure;\n            fileReader.readAsArrayBuffer(initialBlob);\n            return promise;\n        };\n        qq.extend = function(first, second, extendNested) {\n            qq.each(second, function(prop, val) {\n                if (extendNested && qq.isObject(val)) {\n                    if (first[prop] === undefined) {\n                        first[prop] = {};\n                    }\n                    qq.extend(first[prop], val, true);\n                } else {\n                    first[prop] = val;\n                }\n            });\n            return first;\n        };\n        qq.override = function(target, sourceFn) {\n            var super_ = {}, source = sourceFn(super_);\n            qq.each(source, function(srcPropName, srcPropVal) {\n                if (target[srcPropName] !== undefined) {\n                    super_[srcPropName] = target[srcPropName];\n                }\n                target[srcPropName] = srcPropVal;\n            });\n            return target;\n        };\n        qq.indexOf = function(arr, elt, from) {\n            if (arr.indexOf) {\n                return arr.indexOf(elt, from);\n            }\n            from = from || 0;\n            var len = arr.length;\n            if (from < 0) {\n                from += len;\n            }\n            for (;from < len; from += 1) {\n                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n        qq.getUniqueId = function() {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n                return v.toString(16);\n            });\n        };\n        qq.ie = function() {\n            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n        };\n        qq.ie7 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n        };\n        qq.ie8 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n        };\n        qq.ie10 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n        };\n        qq.ie11 = function() {\n            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n        };\n        qq.edge = function() {\n            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n        };\n        qq.safari = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n        };\n        qq.chrome = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n        };\n        qq.opera = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n        };\n        qq.firefox = function() {\n            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n        };\n        qq.windows = function() {\n            return navigator.platform === \"Win32\";\n        };\n        qq.android = function() {\n            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n        };\n        qq.androidStock = function() {\n            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n        };\n        qq.ios6 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n        };\n        qq.ios7 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n        };\n        qq.ios8 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n        };\n        qq.ios800 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n        };\n        qq.ios = function() {\n            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n        };\n        qq.iosChrome = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n        };\n        qq.iosSafari = function() {\n            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n        };\n        qq.iosSafariWebView = function() {\n            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n        };\n        qq.preventDefault = function(e) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n        };\n        qq.toElement = function() {\n            var div = document.createElement(\"div\");\n            return function(html) {\n                div.innerHTML = html;\n                var element = div.firstChild;\n                div.removeChild(element);\n                return element;\n            };\n        }();\n        qq.each = function(iterableItem, callback) {\n            var keyOrIndex, retVal;\n            if (iterableItem) {\n                if (window.Storage && iterableItem.constructor === window.Storage) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isString(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (keyOrIndex in iterableItem) {\n                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                            if (retVal === false) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        qq.bind = function(oldFunc, context) {\n            if (qq.isFunction(oldFunc)) {\n                var args = Array.prototype.slice.call(arguments, 2);\n                return function() {\n                    var newArgs = qq.extend([], args);\n                    if (arguments.length) {\n                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                    }\n                    return oldFunc.apply(context, newArgs);\n                };\n            }\n            throw new Error(\"first parameter must be a function!\");\n        };\n        qq.obj2url = function(obj, temp, prefixDone) {\n            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n                }\n            };\n            if (!prefixDone && temp) {\n                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n                uristrings.push(temp);\n                uristrings.push(qq.obj2url(obj));\n            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n                qq.each(obj, function(idx, val) {\n                    add(val, idx);\n                });\n            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n                qq.each(obj, function(prop, val) {\n                    add(val, prop);\n                });\n            } else {\n                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n            }\n            if (temp) {\n                return uristrings.join(prefix);\n            } else {\n                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n            }\n        };\n        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n            if (!formData) {\n                formData = new FormData();\n            }\n            qq.each(obj, function(key, val) {\n                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n                if (qq.isObject(val)) {\n                    qq.obj2FormData(val, formData, key);\n                } else if (qq.isFunction(val)) {\n                    formData.append(key, val());\n                } else {\n                    formData.append(key, val);\n                }\n            });\n            return formData;\n        };\n        qq.obj2Inputs = function(obj, form) {\n            var input;\n            if (!form) {\n                form = document.createElement(\"form\");\n            }\n            qq.obj2FormData(obj, {\n                append: function(key, val) {\n                    input = document.createElement(\"input\");\n                    input.setAttribute(\"name\", key);\n                    input.setAttribute(\"value\", val);\n                    form.appendChild(input);\n                }\n            });\n            return form;\n        };\n        qq.parseJson = function(json) {\n            if (window.JSON && qq.isFunction(JSON.parse)) {\n                return JSON.parse(json);\n            } else {\n                return eval(\"(\" + json + \")\");\n            }\n        };\n        qq.getExtension = function(filename) {\n            var extIdx = filename.lastIndexOf(\".\") + 1;\n            if (extIdx > 0) {\n                return filename.substr(extIdx, filename.length - extIdx);\n            }\n        };\n        qq.getFilename = function(blobOrFileInput) {\n            if (qq.isInput(blobOrFileInput)) {\n                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n            } else if (qq.isFile(blobOrFileInput)) {\n                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                    return blobOrFileInput.fileName;\n                }\n            }\n            return blobOrFileInput.name;\n        };\n        qq.DisposeSupport = function() {\n            var disposers = [];\n            return {\n                dispose: function() {\n                    var disposer;\n                    do {\n                        disposer = disposers.shift();\n                        if (disposer) {\n                            disposer();\n                        }\n                    } while (disposer);\n                },\n                attach: function() {\n                    var args = arguments;\n                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n                },\n                addDisposer: function(disposeFunction) {\n                    disposers.push(disposeFunction);\n                }\n            };\n        };\n    })();\n    (function() {\n        \"use strict\";\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return qq;\n            }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = qq;\n        } else {\n            global.qq = qq;\n        }\n    })();\n    (function() {\n        \"use strict\";\n        qq.Error = function(message) {\n            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n        };\n        qq.Error.prototype = new Error();\n    })();\n    qq.version = \"5.16.2\";\n    qq.supportedFeatures = function() {\n        \"use strict\";\n        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n        function testSupportsFileInputElement() {\n            var supported = true, tempInput;\n            try {\n                tempInput = document.createElement(\"input\");\n                tempInput.type = \"file\";\n                qq(tempInput).hide();\n                if (tempInput.disabled) {\n                    supported = false;\n                }\n            } catch (ex) {\n                supported = false;\n            }\n            return supported;\n        }\n        function isChrome14OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n        }\n        function isCrossOriginXhrSupported() {\n            if (window.XMLHttpRequest) {\n                var xhr = qq.createXhrInstance();\n                return xhr.withCredentials !== undefined;\n            }\n            return false;\n        }\n        function isXdrSupported() {\n            return window.XDomainRequest !== undefined;\n        }\n        function isCrossOriginAjaxSupported() {\n            if (isCrossOriginXhrSupported()) {\n                return true;\n            }\n            return isXdrSupported();\n        }\n        function isFolderSelectionSupported() {\n            return document.createElement(\"input\").webkitdirectory !== undefined;\n        }\n        function isLocalStorageSupported() {\n            try {\n                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n            } catch (error) {\n                return false;\n            }\n        }\n        function isDragAndDropSupported() {\n            var span = document.createElement(\"span\");\n            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n        }\n        supportsUploading = testSupportsFileInputElement();\n        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n        supportsFolderDrop = supportsFileDrop && function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n        }();\n        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n        supportsDeleteFileXdr = isXdrSupported();\n        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n        supportsFolderSelection = isFolderSelectionSupported();\n        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n        supportsUploadProgress = function() {\n            if (supportsAjaxFileUploading) {\n                return !qq.androidStock() && !qq.iosChrome();\n            }\n            return false;\n        }();\n        return {\n            ajaxUploading: supportsAjaxFileUploading,\n            blobUploading: supportsUploadingBlobs,\n            canDetermineSize: supportsAjaxFileUploading,\n            chunking: supportsChunking,\n            deleteFileCors: supportsDeleteFileCors,\n            deleteFileCorsXdr: supportsDeleteFileXdr,\n            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n            dialogElement: !!window.HTMLDialogElement,\n            fileDrop: supportsFileDrop,\n            folderDrop: supportsFolderDrop,\n            folderSelection: supportsFolderSelection,\n            imagePreviews: supportsImagePreviews,\n            imageValidation: supportsImagePreviews,\n            itemSizeValidation: supportsAjaxFileUploading,\n            pause: supportsChunking,\n            progressBar: supportsUploadProgress,\n            resume: supportsResume,\n            scaling: supportsImagePreviews && supportsUploadingBlobs,\n            tiffPreviews: qq.safari(),\n            unlimitedScaledImageSize: !qq.ios(),\n            uploading: supportsUploading,\n            uploadCors: supportsUploadCors,\n            uploadCustomHeaders: supportsAjaxFileUploading,\n            uploadNonMultipart: supportsAjaxFileUploading,\n            uploadViaPaste: supportsUploadViaPaste\n        };\n    }();\n    qq.isGenericPromise = function(maybePromise) {\n        \"use strict\";\n        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n    };\n    qq.Promise = function() {\n        \"use strict\";\n        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n        qq.extend(this, {\n            then: function(onSuccess, onFailure) {\n                if (state === 0) {\n                    if (onSuccess) {\n                        successCallbacks.push(onSuccess);\n                    }\n                    if (onFailure) {\n                        failureCallbacks.push(onFailure);\n                    }\n                } else if (state === -1) {\n                    onFailure && onFailure.apply(null, failureArgs);\n                } else if (onSuccess) {\n                    onSuccess.apply(null, successArgs);\n                }\n                return this;\n            },\n            done: function(callback) {\n                if (state === 0) {\n                    doneCallbacks.push(callback);\n                } else {\n                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n                }\n                return this;\n            },\n            success: function() {\n                state = 1;\n                successArgs = arguments;\n                if (successCallbacks.length) {\n                    qq.each(successCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                return this;\n            },\n            failure: function() {\n                state = -1;\n                failureArgs = arguments;\n                if (failureCallbacks.length) {\n                    qq.each(failureCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                return this;\n            }\n        });\n    };\n    qq.BlobProxy = function(referenceBlob, onCreate) {\n        \"use strict\";\n        qq.extend(this, {\n            referenceBlob: referenceBlob,\n            create: function() {\n                return onCreate(referenceBlob);\n            }\n        });\n    };\n    qq.UploadButton = function(o) {\n        \"use strict\";\n        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n            acceptFiles: null,\n            element: null,\n            focusClass: \"qq-upload-button-focus\",\n            folders: false,\n            hoverClass: \"qq-upload-button-hover\",\n            ios8BrowserCrashWorkaround: false,\n            multiple: false,\n            name: \"qqfile\",\n            onChange: function(input) {},\n            title: null\n        }, input, buttonId;\n        qq.extend(options, o);\n        buttonId = qq.getUniqueId();\n        function createInput() {\n            var input = document.createElement(\"input\");\n            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n            input.setAttribute(\"title\", options.title);\n            self.setMultiple(options.multiple, input);\n            if (options.folders && qq.supportedFeatures.folderSelection) {\n                input.setAttribute(\"webkitdirectory\", \"\");\n            }\n            if (options.acceptFiles) {\n                input.setAttribute(\"accept\", options.acceptFiles);\n            }\n            input.setAttribute(\"type\", \"file\");\n            input.setAttribute(\"name\", options.name);\n            qq(input).css({\n                position: \"absolute\",\n                right: 0,\n                top: 0,\n                fontFamily: \"Arial\",\n                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n                margin: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                opacity: 0\n            });\n            !qq.ie7() && qq(input).css({\n                height: \"100%\"\n            });\n            options.element.appendChild(input);\n            disposeSupport.attach(input, \"change\", function() {\n                options.onChange(input);\n            });\n            disposeSupport.attach(input, \"mouseover\", function() {\n                qq(options.element).addClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"mouseout\", function() {\n                qq(options.element).removeClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"focus\", function() {\n                qq(options.element).addClass(options.focusClass);\n            });\n            disposeSupport.attach(input, \"blur\", function() {\n                qq(options.element).removeClass(options.focusClass);\n            });\n            return input;\n        }\n        qq(options.element).css({\n            position: \"relative\",\n            overflow: \"hidden\",\n            direction: \"ltr\"\n        });\n        qq.extend(this, {\n            getInput: function() {\n                return input;\n            },\n            getButtonId: function() {\n                return buttonId;\n            },\n            setMultiple: function(isMultiple, optInput) {\n                var input = optInput || this.getInput();\n                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                    input.setAttribute(\"multiple\", \"\");\n                } else {\n                    if (isMultiple) {\n                        input.setAttribute(\"multiple\", \"\");\n                    } else {\n                        input.removeAttribute(\"multiple\");\n                    }\n                }\n            },\n            setAcceptFiles: function(acceptFiles) {\n                if (acceptFiles !== options.acceptFiles) {\n                    input.setAttribute(\"accept\", acceptFiles);\n                }\n            },\n            reset: function() {\n                if (input.parentNode) {\n                    qq(input).remove();\n                }\n                qq(options.element).removeClass(options.focusClass);\n                input = null;\n                input = createInput();\n            }\n        });\n        input = createInput();\n    };\n    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n    qq.UploadData = function(uploaderProxy) {\n        \"use strict\";\n        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n        function getDataByIds(idOrIds) {\n            if (qq.isArray(idOrIds)) {\n                var entries = [];\n                qq.each(idOrIds, function(idx, id) {\n                    entries.push(data[id]);\n                });\n                return entries;\n            }\n            return data[idOrIds];\n        }\n        function getDataByUuids(uuids) {\n            if (qq.isArray(uuids)) {\n                var entries = [];\n                qq.each(uuids, function(idx, uuid) {\n                    entries.push(data[byUuid[uuid]]);\n                });\n                return entries;\n            }\n            return data[byUuid[uuids]];\n        }\n        function getDataByStatus(status) {\n            var statusResults = [], statuses = [].concat(status);\n            qq.each(statuses, function(index, statusEnum) {\n                var statusResultIndexes = byStatus[statusEnum];\n                if (statusResultIndexes !== undefined) {\n                    qq.each(statusResultIndexes, function(i, dataIndex) {\n                        statusResults.push(data[dataIndex]);\n                    });\n                }\n            });\n            return statusResults;\n        }\n        qq.extend(this, {\n            addFile: function(spec) {\n                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status,\n                    file: spec.file\n                }) - 1;\n                if (spec.batchId) {\n                    data[id].batchId = spec.batchId;\n                    if (byBatchId[spec.batchId] === undefined) {\n                        byBatchId[spec.batchId] = [];\n                    }\n                    byBatchId[spec.batchId].push(id);\n                }\n                if (spec.proxyGroupId) {\n                    data[id].proxyGroupId = spec.proxyGroupId;\n                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                        byProxyGroupId[spec.proxyGroupId] = [];\n                    }\n                    byProxyGroupId[spec.proxyGroupId].push(id);\n                }\n                data[id].id = id;\n                byUuid[spec.uuid] = id;\n                if (byStatus[status] === undefined) {\n                    byStatus[status] = [];\n                }\n                byStatus[status].push(id);\n                spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n                uploaderProxy.onStatusChange(id, null, status);\n                return id;\n            },\n            retrieve: function(optionalFilter) {\n                if (qq.isObject(optionalFilter) && data.length) {\n                    if (optionalFilter.id !== undefined) {\n                        return getDataByIds(optionalFilter.id);\n                    } else if (optionalFilter.uuid !== undefined) {\n                        return getDataByUuids(optionalFilter.uuid);\n                    } else if (optionalFilter.status) {\n                        return getDataByStatus(optionalFilter.status);\n                    }\n                } else {\n                    return qq.extend([], data, true);\n                }\n            },\n            removeFileRef: function(id) {\n                var record = getDataByIds(id);\n                if (record) {\n                    delete record.file;\n                }\n            },\n            reset: function() {\n                data = [];\n                byUuid = {};\n                byStatus = {};\n                byBatchId = {};\n            },\n            setStatus: function(id, newStatus) {\n                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n                data[id].status = newStatus;\n                if (byStatus[newStatus] === undefined) {\n                    byStatus[newStatus] = [];\n                }\n                byStatus[newStatus].push(id);\n                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n            },\n            uuidChanged: function(id, newUuid) {\n                var oldUuid = data[id].uuid;\n                data[id].uuid = newUuid;\n                byUuid[newUuid] = id;\n                delete byUuid[oldUuid];\n            },\n            updateName: function(id, newName) {\n                data[id].name = newName;\n            },\n            updateSize: function(id, newSize) {\n                data[id].size = newSize;\n            },\n            setParentId: function(targetId, parentId) {\n                data[targetId].parentId = parentId;\n            },\n            getIdsInProxyGroup: function(id) {\n                var proxyGroupId = data[id].proxyGroupId;\n                if (proxyGroupId) {\n                    return byProxyGroupId[proxyGroupId];\n                }\n                return [];\n            },\n            getIdsInBatch: function(id) {\n                var batchId = data[id].batchId;\n                return byBatchId[batchId];\n            }\n        });\n    };\n    qq.status = {\n        SUBMITTING: \"submitting\",\n        SUBMITTED: \"submitted\",\n        REJECTED: \"rejected\",\n        QUEUED: \"queued\",\n        CANCELED: \"canceled\",\n        PAUSED: \"paused\",\n        UPLOADING: \"uploading\",\n        UPLOAD_FINALIZING: \"upload finalizing\",\n        UPLOAD_RETRYING: \"retrying upload\",\n        UPLOAD_SUCCESSFUL: \"upload successful\",\n        UPLOAD_FAILED: \"upload failed\",\n        DELETE_FAILED: \"delete failed\",\n        DELETING: \"deleting\",\n        DELETED: \"deleted\"\n    };\n    (function() {\n        \"use strict\";\n        qq.basePublicApi = {\n            addBlobs: function(blobDataOrArray, params, endpoint) {\n                this.addFiles(blobDataOrArray, params, endpoint);\n            },\n            addInitialFiles: function(cannedFileList) {\n                var self = this;\n                qq.each(cannedFileList, function(index, cannedFile) {\n                    self._addCannedFile(cannedFile);\n                });\n            },\n            addFiles: function(data, params, endpoint) {\n                this._maybeHandleIos8SafariWorkaround();\n                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this), processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this), processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this), processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    } else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this), normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                }, self = this, verifiedFiles = [];\n                this._currentBatchId = batchId;\n                if (data) {\n                    normalizeData();\n                    qq.each(data, function(idx, fileContainer) {\n                        if (qq.isFileOrInput(fileContainer)) {\n                            processFileOrInput(fileContainer);\n                        } else if (qq.isBlob(fileContainer)) {\n                            processBlob(fileContainer);\n                        } else if (qq.isObject(fileContainer)) {\n                            if (fileContainer.blob && fileContainer.name) {\n                                processBlobData(fileContainer);\n                            } else if (fileContainer.canvas && fileContainer.name) {\n                                processCanvasData(fileContainer);\n                            }\n                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                            processCanvas(fileContainer);\n                        } else {\n                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                        }\n                    });\n                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n                }\n            },\n            cancel: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n                    this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n                } else {\n                    this._handler.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var storedIdsCopy = [], self = this;\n                qq.extend(storedIdsCopy, this._storedIds);\n                qq.each(storedIdsCopy, function(idx, storedFileId) {\n                    self.cancel(storedFileId);\n                });\n                this._handler.cancelAll();\n            },\n            clearStoredFiles: function() {\n                this._storedIds = [];\n            },\n            continueUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (uploadData.status === qq.status.PAUSED) {\n                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                    this._uploadFile(id);\n                    return true;\n                } else {\n                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            deleteFile: function(id) {\n                return this._onSubmitDelete(id);\n            },\n            doesExist: function(fileOrBlobId) {\n                return this._handler.isValid(fileOrBlobId);\n            },\n            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n                if (this._imageGenerator) {\n                    fileOrUrl = this._thumbnailUrls[fileId];\n                    options = {\n                        customResizeFunction: customResizeFunction,\n                        maxSize: maxSize > 0 ? maxSize : null,\n                        scale: maxSize > 0\n                    };\n                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                        fileOrUrl = this.getFile(fileId);\n                    }\n                    if (fileOrUrl == null) {\n                        promiseToReturn.failure({\n                            container: imgOrCanvas,\n                            error: \"File or URL not found.\"\n                        });\n                    } else {\n                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        }, function failure(container, reason) {\n                            promiseToReturn.failure({\n                                container: container,\n                                error: reason || \"Problem generating thumbnail\"\n                            });\n                        });\n                    }\n                } else {\n                    promiseToReturn.failure({\n                        container: imgOrCanvas,\n                        error: \"Missing image generator module\"\n                    });\n                }\n                return promiseToReturn;\n            },\n            getButton: function(fileId) {\n                return this._getButton(this._buttonIdsForFileIds[fileId]);\n            },\n            getEndpoint: function(fileId) {\n                return this._endpointStore.get(fileId);\n            },\n            getFile: function(fileOrBlobId) {\n                var file = this._handler.getFile(fileOrBlobId);\n                var uploadDataRecord;\n                if (!file) {\n                    uploadDataRecord = this._uploadData.retrieve({\n                        id: fileOrBlobId\n                    });\n                    if (uploadDataRecord) {\n                        file = uploadDataRecord.file;\n                    }\n                }\n                return file || null;\n            },\n            getInProgress: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n                }).length;\n            },\n            getName: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).name;\n            },\n            getParentId: function(id) {\n                var uploadDataEntry = this.getUploads({\n                    id: id\n                }), parentId = null;\n                if (uploadDataEntry) {\n                    if (uploadDataEntry.parentId !== undefined) {\n                        parentId = uploadDataEntry.parentId;\n                    }\n                }\n                return parentId;\n            },\n            getResumableFilesData: function() {\n                return this._handler.getResumableFilesData();\n            },\n            getSize: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).size;\n            },\n            getNetUploads: function() {\n                return this._netUploaded;\n            },\n            getRemainingAllowedItems: function() {\n                var allowedItems = this._currentItemLimit;\n                if (allowedItems > 0) {\n                    return allowedItems - this._netUploadedOrQueued;\n                }\n                return null;\n            },\n            getUploads: function(optionalFilter) {\n                return this._uploadData.retrieve(optionalFilter);\n            },\n            getUuid: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).uuid;\n            },\n            isResumable: function(id) {\n                return this._handler.hasResumeRecord(id);\n            },\n            log: function(str, level) {\n                if (this._options.debug && (!level || level === \"info\")) {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n                } else if (level && level !== \"info\") {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n                }\n            },\n            pauseUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n                    if (this._handler.pause(id)) {\n                        this._uploadData.setStatus(id, qq.status.PAUSED);\n                        return true;\n                    } else {\n                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                    }\n                } else {\n                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            removeFileRef: function(id) {\n                this._handler.expunge(id);\n                this._uploadData.removeFileRef(id);\n            },\n            reset: function() {\n                this.log(\"Resetting uploader...\");\n                this._handler.reset();\n                this._storedIds = [];\n                this._autoRetries = [];\n                this._retryTimeouts = [];\n                this._preventRetries = [];\n                this._thumbnailUrls = [];\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n                this._paramsStore.reset();\n                this._endpointStore.reset();\n                this._netUploadedOrQueued = 0;\n                this._netUploaded = 0;\n                this._uploadData.reset();\n                this._buttonIdsForFileIds = [];\n                this._pasteHandler && this._pasteHandler.reset();\n                this._options.session.refreshOnReset && this._refreshSessionData();\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n                this._totalProgress && this._totalProgress.reset();\n                this._customResumeDataStore.reset();\n            },\n            retry: function(id) {\n                return this._manualRetry(id);\n            },\n            scaleImage: function(id, specs) {\n                var self = this;\n                return qq.Scaler.prototype.scaleImage(id, specs, {\n                    log: qq.bind(self.log, self),\n                    getFile: qq.bind(self.getFile, self),\n                    uploadData: self._uploadData\n                });\n            },\n            setCustomHeaders: function(headers, id) {\n                this._customHeadersStore.set(headers, id);\n            },\n            setCustomResumeData: function(id, data) {\n                this._customResumeDataStore.set(data, id);\n            },\n            setDeleteFileCustomHeaders: function(headers, id) {\n                this._deleteFileCustomHeadersStore.set(headers, id);\n            },\n            setDeleteFileEndpoint: function(endpoint, id) {\n                this._deleteFileEndpointStore.set(endpoint, id);\n            },\n            setDeleteFileParams: function(params, id) {\n                this._deleteFileParamsStore.set(params, id);\n            },\n            setEndpoint: function(endpoint, id) {\n                this._endpointStore.set(endpoint, id);\n            },\n            setForm: function(elementOrId) {\n                this._updateFormSupportAndParams(elementOrId);\n            },\n            setItemLimit: function(newItemLimit) {\n                this._currentItemLimit = newItemLimit;\n            },\n            setName: function(id, newName) {\n                this._uploadData.updateName(id, newName);\n            },\n            setParams: function(params, id) {\n                this._paramsStore.set(params, id);\n            },\n            setUuid: function(id, newUuid) {\n                return this._uploadData.uuidChanged(id, newUuid);\n            },\n            setStatus: function(id, newStatus) {\n                var fileRecord = this.getUploads({\n                    id: id\n                });\n                if (!fileRecord) {\n                    throw new qq.Error(id + \" is not a valid file ID.\");\n                }\n                switch (newStatus) {\n                  case qq.status.DELETED:\n                    this._onDeleteComplete(id, null, false);\n                    break;\n\n                  case qq.status.DELETE_FAILED:\n                    this._onDeleteComplete(id, null, true);\n                    break;\n\n                  default:\n                    var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n                    this.log(errorMessage);\n                    throw new qq.Error(errorMessage);\n                }\n            },\n            uploadStoredFiles: function() {\n                if (this._storedIds.length === 0) {\n                    this._itemError(\"noFilesError\");\n                } else {\n                    this._uploadStoredFiles();\n                }\n            }\n        };\n        qq.basePrivateApi = {\n            _addCannedFile: function(sessionData) {\n                var self = this;\n                return this._uploadData.addFile({\n                    uuid: sessionData.uuid,\n                    name: sessionData.name,\n                    size: sessionData.size,\n                    status: qq.status.UPLOAD_SUCCESSFUL,\n                    onBeforeStatusChange: function(id) {\n                        sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                        sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n                        if (sessionData.thumbnailUrl) {\n                            self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                        }\n                        self._netUploaded++;\n                        self._netUploadedOrQueued++;\n                    }\n                });\n            },\n            _annotateWithButtonId: function(file, associatedInput) {\n                if (qq.isFile(file)) {\n                    file.qqButtonId = this._getButtonId(associatedInput);\n                }\n            },\n            _batchError: function(message) {\n                this._options.callbacks.onError(null, null, message, undefined);\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return new qq.DeleteFileAjaxRequester({\n                    method: this._options.deleteFile.method.toUpperCase(),\n                    maxConnections: this._options.maxConnections,\n                    uuidParamName: this._options.request.uuidName,\n                    customHeaders: this._deleteFileCustomHeadersStore,\n                    paramsStore: this._deleteFileParamsStore,\n                    endpointStore: this._deleteFileEndpointStore,\n                    cors: this._options.cors,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        self._onDeleteComplete(id, xhrOrXdr, isError);\n                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                    }\n                });\n            },\n            _createPasteHandler: function() {\n                var self = this;\n                return new qq.PasteSupport({\n                    targetElement: this._options.paste.targetElement,\n                    callbacks: {\n                        log: qq.bind(self.log, self),\n                        pasteReceived: function(blob) {\n                            self._handleCheckedCallback({\n                                name: \"onPasteReceived\",\n                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                                identifier: \"pasted image\"\n                            });\n                        }\n                    }\n                });\n            },\n            _createStore: function(initialValue, _readOnlyValues_) {\n                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                }, getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                }, includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n                return {\n                    set: function(val, id) {\n                        if (id == null) {\n                            store = {};\n                            catchall = copy(val);\n                        } else {\n                            store[id] = copy(val);\n                        }\n                    },\n                    get: function(id) {\n                        var values;\n                        if (id != null && store[id]) {\n                            values = store[id];\n                        } else {\n                            values = copy(catchall);\n                        }\n                        includeReadOnlyValues(id, values);\n                        return copy(values);\n                    },\n                    addReadOnly: function(id, values) {\n                        if (qq.isObject(store)) {\n                            if (id === null) {\n                                if (qq.isFunction(values)) {\n                                    readOnlyValues = values;\n                                } else {\n                                    readOnlyValues = readOnlyValues || {};\n                                    qq.extend(readOnlyValues, values);\n                                }\n                            } else {\n                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                                qq.extend(perIdReadOnlyValues[id], values);\n                            }\n                        }\n                    },\n                    remove: function(fileId) {\n                        return delete store[fileId];\n                    },\n                    reset: function() {\n                        store = {};\n                        perIdReadOnlyValues = {};\n                        catchall = initialValue;\n                    }\n                };\n            },\n            _createUploadDataTracker: function() {\n                var self = this;\n                return new qq.UploadData({\n                    getName: function(id) {\n                        return self.getName(id);\n                    },\n                    getUuid: function(id) {\n                        return self.getUuid(id);\n                    },\n                    getSize: function(id) {\n                        return self.getSize(id);\n                    },\n                    onStatusChange: function(id, oldStatus, newStatus) {\n                        self._onUploadStatusChange(id, oldStatus, newStatus);\n                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                        self._maybeAllComplete(id, newStatus);\n                        if (self._totalProgress) {\n                            setTimeout(function() {\n                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                            }, 0);\n                        }\n                    }\n                });\n            },\n            _createUploadButton: function(spec) {\n                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n                function allowMultiple() {\n                    if (qq.supportedFeatures.ajaxUploading) {\n                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n                            return false;\n                        }\n                        if (spec.multiple === undefined) {\n                            return self._options.multiple;\n                        }\n                        return spec.multiple;\n                    }\n                    return false;\n                }\n                button = new qq.UploadButton({\n                    acceptFiles: acceptFiles,\n                    element: spec.element,\n                    focusClass: this._options.classes.buttonFocus,\n                    folders: spec.folders,\n                    hoverClass: this._options.classes.buttonHover,\n                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                    multiple: allowMultiple(),\n                    name: this._options.request.inputName,\n                    onChange: function(input) {\n                        self._onInputChange(input);\n                    },\n                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n                });\n                this._disposeSupport.addDisposer(function() {\n                    button.dispose();\n                });\n                self._buttons.push(button);\n                return button;\n            },\n            _createUploadHandler: function(additionalOptions, namespace) {\n                var self = this, lastOnProgress = {}, options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        } else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n                        lastOnProgress[id] = {\n                            loaded: loaded,\n                            total: total\n                        };\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n                        var status = self.getUploads({\n                            id: id\n                        }).status, retVal;\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n                        retVal = self._onComplete(id, name, result, xhr);\n                        if (retVal instanceof qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        } else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        var onUploadResult = self._options.callbacks.onUpload(id, name);\n                        if (qq.isGenericPromise(onUploadResult)) {\n                            self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                            return onUploadResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n                        if (qq.isGenericPromise(onUploadChunkResult)) {\n                            self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                            return onUploadChunkResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._onUploadChunkSuccess(id, chunkData);\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData, customResumeData) {\n                        return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({\n                            uuid: uuid\n                        });\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({\n                            id: id\n                        }).status;\n                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch,\n                    isInProgress: function(id) {\n                        return self.getUploads({\n                            id: id\n                        }).status === qq.status.UPLOADING;\n                    },\n                    getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n                    setStatus: function(id, status) {\n                        self._uploadData.setStatus(id, status);\n                    }\n                };\n                qq.each(this._options.request, function(prop, val) {\n                    options[prop] = val;\n                });\n                options.customHeaders = this._customHeadersStore;\n                if (additionalOptions) {\n                    qq.each(additionalOptions, function(key, val) {\n                        options[key] = val;\n                    });\n                }\n                return new qq.UploadHandlerController(options, namespace);\n            },\n            _fileOrBlobRejected: function(id) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.REJECTED);\n            },\n            _formatSize: function(bytes) {\n                if (bytes === 0) {\n                    return bytes + this._options.text.sizeSymbols[0];\n                }\n                var i = -1;\n                do {\n                    bytes = bytes / 1e3;\n                    i++;\n                } while (bytes > 999);\n                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n            },\n            _generateExtraButtonSpecs: function() {\n                var self = this;\n                this._extraButtonSpecs = {};\n                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n                    if (multiple === undefined) {\n                        multiple = self._options.multiple;\n                    }\n                    if (extraButtonSpec.validation) {\n                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n                    }\n                    qq.extend(extraButtonSpec, {\n                        multiple: multiple,\n                        validation: validation\n                    }, true);\n                    self._initExtraButton(extraButtonSpec);\n                });\n            },\n            _getButton: function(buttonId) {\n                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n                if (extraButtonsSpec) {\n                    return extraButtonsSpec.element;\n                } else if (buttonId === this._defaultButtonId) {\n                    return this._options.button;\n                }\n            },\n            _getButtonId: function(buttonOrFileInputOrFile) {\n                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n                if (fileBlobOrInput instanceof qq.BlobProxy) {\n                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n                }\n                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                    if (qq.isFile(fileBlobOrInput)) {\n                        return fileBlobOrInput.qqButtonId;\n                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n                    qq.each(inputs, function(idx, input) {\n                        if (input.getAttribute(\"type\") === \"file\") {\n                            fileInput = input;\n                            return false;\n                        }\n                    });\n                    if (fileInput) {\n                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                }\n            },\n            _getCustomResumeData: function(fileId) {\n                return this._customResumeDataStore.get(fileId);\n            },\n            _getNotFinished: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n                }).length;\n            },\n            _getValidationBase: function(buttonId) {\n                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n            },\n            _getValidationDescriptor: function(fileWrapper) {\n                if (fileWrapper.file instanceof qq.BlobProxy) {\n                    return {\n                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n                        size: fileWrapper.file.referenceBlob.size\n                    };\n                }\n                return {\n                    name: this.getUploads({\n                        id: fileWrapper.id\n                    }).name,\n                    size: this.getUploads({\n                        id: fileWrapper.id\n                    }).size\n                };\n            },\n            _getValidationDescriptors: function(fileWrappers) {\n                var self = this, fileDescriptors = [];\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n                });\n                return fileDescriptors;\n            },\n            _handleCameraAccess: function() {\n                if (this._options.camera.ios && qq.ios()) {\n                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n                    if (buttonId && buttonId !== this._defaultButtonId) {\n                        optionRoot = this._extraButtonSpecs[buttonId];\n                    }\n                    optionRoot.multiple = false;\n                    if (optionRoot.validation.acceptFiles === null) {\n                        optionRoot.validation.acceptFiles = acceptIosCamera;\n                    } else {\n                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                    }\n                    qq.each(this._buttons, function(idx, button) {\n                        if (button.getButtonId() === buttonId) {\n                            button.setMultiple(optionRoot.multiple);\n                            button.setAcceptFiles(optionRoot.acceptFiles);\n                            return false;\n                        }\n                    });\n                }\n            },\n            _handleCheckedCallback: function(details) {\n                var self = this, callbackRetVal = details.callback();\n                if (qq.isGenericPromise(callbackRetVal)) {\n                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                    return callbackRetVal.then(function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    }, function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        } else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n                }\n                if (callbackRetVal !== false) {\n                    details.onSuccess(callbackRetVal);\n                } else {\n                    if (details.onFailure) {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                        details.onFailure();\n                    } else {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                    }\n                }\n                return callbackRetVal;\n            },\n            _handleNewFile: function(file, batchId, newFileWrapperList) {\n                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                    size = actualFile.size;\n                }\n                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                    uploadData: self._uploadData,\n                    paramsStore: self._paramsStore,\n                    addFileToHandler: function(id, file) {\n                        self._handler.add(id, file);\n                        self._netUploadedOrQueued++;\n                        self._trackButton(id);\n                    }\n                });\n            },\n            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n                var id = this._uploadData.addFile({\n                    uuid: uuid,\n                    name: name,\n                    size: size,\n                    batchId: batchId,\n                    file: file\n                });\n                this._handler.add(id, file);\n                this._trackButton(id);\n                this._netUploadedOrQueued++;\n                fileList.push({\n                    id: id,\n                    file: file\n                });\n            },\n            _handlePasteSuccess: function(blob, extSuppliedName) {\n                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n                if (name == null) {\n                    name = this._options.paste.defaultName;\n                }\n                name += \".\" + extension;\n                this.addFiles({\n                    name: name,\n                    blob: blob\n                });\n            },\n            _handleDeleteSuccess: function(id) {\n                if (this.getUploads({\n                    id: id\n                }).status !== qq.status.DELETED) {\n                    var name = this.getName(id);\n                    this._netUploadedOrQueued--;\n                    this._netUploaded--;\n                    this._handler.expunge(id);\n                    this._uploadData.setStatus(id, qq.status.DELETED);\n                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n                }\n            },\n            _handleDeleteFailed: function(id, xhrOrXdr) {\n                var name = this.getName(id);\n                this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n                this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n                if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n                    this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n                } else {\n                    this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n                }\n            },\n            _initExtraButton: function(spec) {\n                var button = this._createUploadButton({\n                    accept: spec.validation.acceptFiles,\n                    allowedExtensions: spec.validation.allowedExtensions,\n                    element: spec.element,\n                    folders: spec.folders,\n                    multiple: spec.multiple,\n                    title: spec.fileInputTitle\n                });\n                this._extraButtonSpecs[button.getButtonId()] = spec;\n            },\n            _initFormSupportAndParams: function() {\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this._options.request.endpoint = this._formSupport.newEndpoint;\n                    }\n                } else {\n                    this._paramsStore = this._createStore(this._options.request.params);\n                }\n            },\n            _isDeletePossible: function() {\n                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                    return false;\n                }\n                if (this._options.cors.expected) {\n                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n                        return true;\n                    }\n                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                        return true;\n                    }\n                    return false;\n                }\n                return true;\n            },\n            _isAllowedExtension: function(allowed, fileName) {\n                var valid = false;\n                if (!allowed.length) {\n                    return true;\n                }\n                qq.each(allowed, function(idx, allowedExt) {\n                    if (qq.isString(allowedExt)) {\n                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n                        if (fileName.match(extRegex) != null) {\n                            valid = true;\n                            return false;\n                        }\n                    }\n                });\n                return valid;\n            },\n            _itemError: function(code, maybeNameOrNames, item) {\n                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                    if (qq.isString(allowedExtension)) {\n                        allowedExtensions.push(allowedExtension);\n                    }\n                });\n                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n                r(\"{file}\", this._options.formatFileName(name));\n                r(\"{extensions}\", extensionsForMessage);\n                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n                if (placeholderMatch !== null) {\n                    qq.each(placeholderMatch, function(idx, placeholder) {\n                        r(placeholder, names[idx]);\n                    });\n                }\n                this._options.callbacks.onError(null, name, message, undefined);\n                return message;\n            },\n            _manualRetry: function(id, callback) {\n                if (this._onBeforeManualRetry(id)) {\n                    this._netUploadedOrQueued++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    if (callback) {\n                        callback(id);\n                    } else {\n                        this._handler.retry(id);\n                    }\n                    return true;\n                }\n            },\n            _maybeAllComplete: function(id, status) {\n                var self = this, notFinished = this._getNotFinished();\n                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                    this._succeededSinceLastAllComplete.push(id);\n                } else if (status === qq.status.UPLOAD_FAILED) {\n                    this._failedSinceLastAllComplete.push(id);\n                }\n                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                    setTimeout(function() {\n                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                    }, 0);\n                }\n            },\n            _maybeHandleIos8SafariWorkaround: function() {\n                var self = this;\n                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                    setTimeout(function() {\n                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                    }, 0);\n                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n                }\n            },\n            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n                if (!response.success) {\n                    if (xhr && xhr.status !== 200 && !response.error) {\n                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                    } else {\n                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                        this._options.callbacks.onError(id, name, errorReason, xhr);\n                    }\n                }\n            },\n            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n                var self = this;\n                if (items.length > index) {\n                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                        setTimeout(function() {\n                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n                            self._handleCheckedCallback({\n                                name: \"onValidate\",\n                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                            });\n                        }, 0);\n                    } else if (!validItem) {\n                        for (;index < items.length; index++) {\n                            self._fileOrBlobRejected(items[index].id);\n                        }\n                    }\n                }\n            },\n            _onAllComplete: function(successful, failed) {\n                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n            },\n            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n                var self = this;\n                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n                if (self._shouldAutoRetry(id)) {\n                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n                    self._maybeParseAndSendUploadError.apply(self, arguments);\n                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                    self._onBeforeAutoRetry(id, name);\n                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    self._retryTimeouts[id] = setTimeout(function() {\n                        self.log(\"Starting retry for \" + name + \"...\");\n                        if (callback) {\n                            callback(id);\n                        } else {\n                            self._handler.retry(id);\n                        }\n                    }, retryWaitPeriod);\n                    return true;\n                }\n            },\n            _onBeforeAutoRetry: function(id, name) {\n                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n            },\n            _onBeforeManualRetry: function(id) {\n                var itemLimit = this._currentItemLimit, fileName;\n                if (this._preventRetries[id]) {\n                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                    return false;\n                } else if (this._handler.isValid(id)) {\n                    fileName = this.getName(id);\n                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                        return false;\n                    }\n                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                        this._itemError(\"retryFailTooManyItems\");\n                        return false;\n                    }\n                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                    return true;\n                } else {\n                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                    return false;\n                }\n            },\n            _onCancel: function(id, name) {\n                this._netUploadedOrQueued--;\n                clearTimeout(this._retryTimeouts[id]);\n                var storedItemIndex = qq.indexOf(this._storedIds, id);\n                if (!this._options.autoUpload && storedItemIndex >= 0) {\n                    this._storedIds.splice(storedItemIndex, 1);\n                }\n                this._uploadData.setStatus(id, qq.status.CANCELED);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                if (!result.success) {\n                    this._netUploadedOrQueued--;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                        this._preventRetries[id] = true;\n                    }\n                } else {\n                    if (result.thumbnailUrl) {\n                        this._thumbnailUrls[id] = result.thumbnailUrl;\n                    }\n                    this._netUploaded++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n                }\n                this._maybeParseAndSendUploadError(id, name, result, xhr);\n                return result.success ? true : false;\n            },\n            _onDelete: function(id) {\n                this._uploadData.setStatus(id, qq.status.DELETING);\n            },\n            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n                var name = this.getName(id);\n                if (isError) {\n                    this._handleDeleteFailed(id, xhrOrXdr);\n                } else {\n                    this._handleDeleteSuccess(id);\n                }\n            },\n            _onInputChange: function(input) {\n                var fileIndex;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                        this._annotateWithButtonId(input.files[fileIndex], input);\n                    }\n                    this.addFiles(input.files);\n                } else if (input.value.length > 0) {\n                    this.addFiles(input);\n                }\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n            },\n            _onSubmit: function(id, name) {},\n            _onSubmitCallbackSuccess: function(id, name) {\n                this._onSubmit.apply(this, arguments);\n                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n                this._onSubmitted.apply(this, arguments);\n                if (this._options.autoUpload) {\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                    this._uploadFile(id);\n                } else {\n                    this._storeForLater(id);\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                }\n            },\n            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n                if (onSuccessCallback) {\n                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n                }\n                if (this._isDeletePossible()) {\n                    this._handleCheckedCallback({\n                        name: \"onSubmitDelete\",\n                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                        identifier: id\n                    });\n                    return true;\n                } else {\n                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                    return false;\n                }\n            },\n            _onSubmitted: function(id) {},\n            _onTotalProgress: function(loaded, total) {\n                this._options.callbacks.onTotalProgress(loaded, total);\n            },\n            _onUploadPrep: function(id) {},\n            _onUpload: function(id, name) {\n                this._uploadData.setStatus(id, qq.status.UPLOADING);\n            },\n            _onUploadChunk: function(id, chunkData) {},\n            _onUploadChunkSuccess: function(id, chunkData) {\n                if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n                    this._autoRetries[id] = 0;\n                }\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.PAUSED) {\n                    clearTimeout(this._retryTimeouts[id]);\n                }\n            },\n            _onValidateBatchCallbackFailure: function(fileWrappers) {\n                var self = this;\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    self._fileOrBlobRejected(fileWrapper.id);\n                });\n            },\n            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                    if (items.length > 0) {\n                        this._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                        });\n                    } else {\n                        this._itemError(\"noFilesError\");\n                    }\n                } else {\n                    this._onValidateBatchCallbackFailure(items);\n                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n                    this._batchError(errorMessage);\n                }\n            },\n            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n                var nextIndex = index + 1;\n                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n            },\n            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                }, function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                });\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                if (items.length === 0) {\n                    this._itemError(\"noFilesError\");\n                    return;\n                }\n                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n                this._handleCheckedCallback({\n                    name: \"onValidateBatch\",\n                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                    identifier: \"batch validation\"\n                });\n            },\n            _preventLeaveInProgress: function() {\n                var self = this;\n                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                    if (self.getInProgress()) {\n                        e = e || window.event;\n                        e.returnValue = self._options.messages.onLeave;\n                        return self._options.messages.onLeave;\n                    }\n                });\n            },\n            _refreshSessionData: function() {\n                var self = this, options = this._options.session;\n                if (qq.Session && this._options.session.endpoint != null) {\n                    if (!this._session) {\n                        qq.extend(options, {\n                            cors: this._options.cors\n                        });\n                        options.log = qq.bind(this.log, this);\n                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n                        this._session = new qq.Session(options);\n                    }\n                    setTimeout(function() {\n                        self._session.refresh().then(function(response, xhrOrXdr) {\n                            self._sessionRequestComplete();\n                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n                        }, function(response, xhrOrXdr) {\n                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                        });\n                    }, 0);\n                }\n            },\n            _sessionRequestComplete: function() {},\n            _setSize: function(id, newSize) {\n                this._uploadData.updateSize(id, newSize);\n                this._totalProgress && this._totalProgress.onNewSize(id);\n            },\n            _shouldAutoRetry: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n                    if (this._autoRetries[id] === undefined) {\n                        this._autoRetries[id] = 0;\n                    }\n                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                        this._autoRetries[id] += 1;\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _storeForLater: function(id) {\n                this._storedIds.push(id);\n            },\n            _trackButton: function(id) {\n                var buttonId;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    buttonId = this._handler.getFile(id).qqButtonId;\n                } else {\n                    buttonId = this._getButtonId(this._handler.getInput(id));\n                }\n                if (buttonId) {\n                    this._buttonIdsForFileIds[id] = buttonId;\n                }\n            },\n            _updateFormSupportAndParams: function(formElementOrId) {\n                this._options.form.element = formElementOrId;\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this.setEndpoint(this._formSupport.newEndpoint);\n                    }\n                }\n            },\n            _upload: function(id, params, endpoint) {\n                var name = this.getName(id);\n                if (params) {\n                    this.setParams(params, id);\n                }\n                if (endpoint) {\n                    this.setEndpoint(endpoint, id);\n                }\n                this._handleCheckedCallback({\n                    name: \"onSubmit\",\n                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                    identifier: id\n                });\n            },\n            _uploadFile: function(id) {\n                if (!this._handler.upload(id)) {\n                    this._uploadData.setStatus(id, qq.status.QUEUED);\n                }\n            },\n            _uploadStoredFiles: function() {\n                var idToUpload, stillSubmitting, self = this;\n                while (this._storedIds.length) {\n                    idToUpload = this._storedIds.shift();\n                    this._uploadFile(idToUpload);\n                }\n                stillSubmitting = this.getUploads({\n                    status: qq.status.SUBMITTING\n                }).length;\n                if (stillSubmitting) {\n                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                    setTimeout(function() {\n                        self._uploadStoredFiles();\n                    }, 1e3);\n                }\n            },\n            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n                var self = this, file = function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n                validityChecker.then(function() {}, function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                    this._itemError(\"typeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (!this._options.validation.allowEmpty && size === 0) {\n                    this._itemError(\"emptyError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                    this._itemError(\"sizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && size < validationBase.minSizeLimit) {\n                    this._itemError(\"minSizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    });\n                } else {\n                    validityChecker.success();\n                }\n                return validityChecker;\n            },\n            _wrapCallbacks: function() {\n                var self, safeCallback, prop;\n                self = this;\n                safeCallback = function(name, callback, args) {\n                    var errorMsg;\n                    try {\n                        return callback.apply(self, args);\n                    } catch (exception) {\n                        errorMsg = exception.message || exception.toString();\n                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                    }\n                };\n                for (prop in this._options.callbacks) {\n                    (function() {\n                        var callbackName, callbackFunc;\n                        callbackName = prop;\n                        callbackFunc = self._options.callbacks[callbackName];\n                        self._options.callbacks[callbackName] = function() {\n                            return safeCallback(callbackName, callbackFunc, arguments);\n                        };\n                    })();\n                }\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.FineUploaderBasic = function(o) {\n            var self = this;\n            this._options = {\n                debug: false,\n                button: null,\n                multiple: true,\n                maxConnections: 3,\n                disableCancelForFormUploads: false,\n                autoUpload: true,\n                warnBeforeUnload: true,\n                request: {\n                    customHeaders: {},\n                    endpoint: \"/server/upload\",\n                    filenameParam: \"qqfilename\",\n                    forceMultipart: true,\n                    inputName: \"qqfile\",\n                    method: \"POST\",\n                    omitDefaultParams: false,\n                    params: {},\n                    paramsInBody: true,\n                    requireSuccessJson: true,\n                    totalFileSizeName: \"qqtotalfilesize\",\n                    uuidName: \"qquuid\"\n                },\n                validation: {\n                    allowedExtensions: [],\n                    sizeLimit: 0,\n                    minSizeLimit: 0,\n                    itemLimit: 0,\n                    stopOnFirstInvalidFile: true,\n                    acceptFiles: null,\n                    image: {\n                        maxHeight: 0,\n                        maxWidth: 0,\n                        minHeight: 0,\n                        minWidth: 0\n                    },\n                    allowEmpty: false\n                },\n                callbacks: {\n                    onSubmit: function(id, name) {},\n                    onSubmitted: function(id, name) {},\n                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n                    onAllComplete: function(successful, failed) {},\n                    onCancel: function(id, name) {},\n                    onUpload: function(id, name) {},\n                    onUploadChunk: function(id, name, chunkData) {},\n                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                    onResume: function(id, fileName, chunkData, customResumeData) {},\n                    onProgress: function(id, name, loaded, total) {},\n                    onTotalProgress: function(loaded, total) {},\n                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n                    onAutoRetry: function(id, name, attemptNumber) {},\n                    onManualRetry: function(id, name) {},\n                    onValidateBatch: function(fileOrBlobData) {},\n                    onValidate: function(fileOrBlobData) {},\n                    onSubmitDelete: function(id) {},\n                    onDelete: function(id) {},\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                    onPasteReceived: function(blob) {},\n                    onStatusChange: function(id, oldStatus, newStatus) {},\n                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n                },\n                messages: {\n                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                    emptyError: \"{file} is empty, please select files again without it.\",\n                    noFilesError: \"No files to upload.\",\n                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                    maxHeightImageError: \"Image is too tall.\",\n                    maxWidthImageError: \"Image is too wide.\",\n                    minHeightImageError: \"Image is not tall enough.\",\n                    minWidthImageError: \"Image is not wide enough.\",\n                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n                },\n                retry: {\n                    enableAuto: false,\n                    maxAutoAttempts: 3,\n                    autoAttemptDelay: 5,\n                    preventRetryResponseProperty: \"preventRetry\"\n                },\n                classes: {\n                    buttonHover: \"qq-upload-button-hover\",\n                    buttonFocus: \"qq-upload-button-focus\"\n                },\n                chunking: {\n                    enabled: false,\n                    concurrent: {\n                        enabled: false\n                    },\n                    mandatory: false,\n                    paramNames: {\n                        partIndex: \"qqpartindex\",\n                        partByteOffset: \"qqpartbyteoffset\",\n                        chunkSize: \"qqchunksize\",\n                        totalFileSize: \"qqtotalfilesize\",\n                        totalParts: \"qqtotalparts\"\n                    },\n                    partSize: function(id) {\n                        return 2e6;\n                    },\n                    success: {\n                        endpoint: null,\n                        headers: function(id) {\n                            return null;\n                        },\n                        jsonPayload: false,\n                        method: \"POST\",\n                        params: function(id) {\n                            return null;\n                        },\n                        resetOnStatus: []\n                    }\n                },\n                resume: {\n                    enabled: false,\n                    recordsExpireIn: 7,\n                    paramNames: {\n                        resuming: \"qqresume\"\n                    },\n                    customKeys: function(fileId) {\n                        return [];\n                    }\n                },\n                formatFileName: function(fileOrBlobName) {\n                    return fileOrBlobName;\n                },\n                text: {\n                    defaultResponseError: \"Upload failure reason unknown\",\n                    fileInputTitle: \"file input\",\n                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n                },\n                deleteFile: {\n                    enabled: false,\n                    method: \"DELETE\",\n                    endpoint: \"/server/upload\",\n                    customHeaders: {},\n                    params: {}\n                },\n                cors: {\n                    expected: false,\n                    sendCredentials: false,\n                    allowXdr: false\n                },\n                blobs: {\n                    defaultName: \"misc_data\"\n                },\n                paste: {\n                    targetElement: null,\n                    defaultName: \"pasted_image\"\n                },\n                camera: {\n                    ios: false,\n                    button: null\n                },\n                extraButtons: [],\n                session: {\n                    endpoint: null,\n                    params: {},\n                    customHeaders: {},\n                    refreshOnReset: true\n                },\n                form: {\n                    element: \"qq-form\",\n                    autoUpload: false,\n                    interceptSubmit: true\n                },\n                scaling: {\n                    customResizer: null,\n                    sendOriginal: true,\n                    orient: true,\n                    defaultType: null,\n                    defaultQuality: 80,\n                    failureText: \"Failed to scale\",\n                    includeExif: false,\n                    sizes: []\n                },\n                workarounds: {\n                    iosEmptyVideos: true,\n                    ios8SafariUploads: true,\n                    ios8BrowserCrash: false\n                }\n            };\n            qq.extend(this._options, o, true);\n            this._buttons = [];\n            this._extraButtonSpecs = {};\n            this._buttonIdsForFileIds = [];\n            this._wrapCallbacks();\n            this._disposeSupport = new qq.DisposeSupport();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData = this._createUploadDataTracker();\n            this._initFormSupportAndParams();\n            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n            this._endpointStore = this._createStore(this._options.request.endpoint);\n            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n            this._handler = this._createUploadHandler();\n            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n            if (this._options.button) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._options.button,\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._generateExtraButtonSpecs();\n            this._handleCameraAccess();\n            if (this._options.paste.targetElement) {\n                if (qq.PasteSupport) {\n                    this._pasteHandler = this._createPasteHandler();\n                } else {\n                    this.log(\"Paste support module not found\", \"error\");\n                }\n            }\n            this._options.warnBeforeUnload && this._preventLeaveInProgress();\n            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n            this._refreshSessionData();\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n            if (this._scaler.enabled) {\n                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n            }\n            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n                    var entry = self._uploadData.retrieve({\n                        id: id\n                    });\n                    return entry && entry.size || 0;\n                });\n            }\n            this._currentItemLimit = this._options.validation.itemLimit;\n            this._customResumeDataStore = this._createStore();\n        };\n        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n    })();\n    qq.AjaxRequester = function(o) {\n        \"use strict\";\n        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n            acceptHeader: null,\n            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [ 200, 202, 204 ],\n                PATCH: [ 200, 201, 202, 203, 204 ],\n                POST: [ 200, 201, 202, 203, 204 ],\n                PUT: [ 200, 201, 202, 203, 204 ],\n                GET: [ 200 ]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n        qq.extend(options, o);\n        log = options.log;\n        if (qq.indexOf(options.validMethods, options.method) < 0) {\n            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n        }\n        function isSimpleMethod() {\n            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n        }\n        function containsNonSimpleHeaders(headers) {\n            var containsNonSimple = false;\n            qq.each(containsNonSimple, function(idx, header) {\n                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n                    containsNonSimple = true;\n                    return false;\n                }\n            });\n            return containsNonSimple;\n        }\n        function isXdr(xhr) {\n            return options.cors.expected && xhr.withCredentials === undefined;\n        }\n        function getCorsAjaxTransport() {\n            var xhrOrXdr;\n            if (window.XMLHttpRequest || window.ActiveXObject) {\n                xhrOrXdr = qq.createXhrInstance();\n                if (xhrOrXdr.withCredentials === undefined) {\n                    xhrOrXdr = new XDomainRequest();\n                    xhrOrXdr.onload = function() {};\n                    xhrOrXdr.onerror = function() {};\n                    xhrOrXdr.ontimeout = function() {};\n                    xhrOrXdr.onprogress = function() {};\n                }\n            }\n            return xhrOrXdr;\n        }\n        function getXhrOrXdr(id, suppliedXhr) {\n            var xhrOrXdr = requestData[id] && requestData[id].xhr;\n            if (!xhrOrXdr) {\n                if (suppliedXhr) {\n                    xhrOrXdr = suppliedXhr;\n                } else {\n                    if (options.cors.expected) {\n                        xhrOrXdr = getCorsAjaxTransport();\n                    } else {\n                        xhrOrXdr = qq.createXhrInstance();\n                    }\n                }\n                requestData[id].xhr = xhrOrXdr;\n            }\n            return xhrOrXdr;\n        }\n        function dequeue(id) {\n            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n            delete requestData[id];\n            queue.splice(i, 1);\n            if (queue.length >= max && i < max) {\n                nextId = queue[max - 1];\n                sendRequest(nextId);\n            }\n        }\n        function onComplete(id, xdrError) {\n            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n            dequeue(id);\n            if (isError) {\n                log(method + \" request for \" + id + \" has failed\", \"error\");\n            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n                isError = true;\n                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n            }\n            options.onComplete(id, xhr, isError);\n        }\n        function getParams(id) {\n            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n            if (options.paramsStore.get) {\n                params = options.paramsStore.get(id);\n            }\n            if (onDemandParams) {\n                qq.each(onDemandParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            if (mandatedParams) {\n                qq.each(mandatedParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            return params;\n        }\n        function sendRequest(id, optXhr) {\n            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n            options.onSend(id);\n            url = createUrl(id, params, requestData[id].additionalQueryParams);\n            if (isXdr(xhr)) {\n                xhr.onload = getXdrLoadHandler(id);\n                xhr.onerror = getXdrErrorHandler(id);\n            } else {\n                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n            }\n            registerForUploadProgress(id);\n            xhr.open(method, url, true);\n            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n                xhr.withCredentials = true;\n            }\n            setHeaders(id);\n            log(\"Sending \" + method + \" request for \" + id);\n            if (payload) {\n                xhr.send(payload);\n            } else if (shouldParamsBeInQueryString || !params) {\n                xhr.send();\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n                xhr.send(qq.obj2url(params, \"\"));\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n                xhr.send(JSON.stringify(params));\n            } else {\n                xhr.send(params);\n            }\n            return xhr;\n        }\n        function createUrl(id, params, additionalQueryParams) {\n            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n            if (addToPath != undefined) {\n                endpoint += \"/\" + addToPath;\n            }\n            if (shouldParamsBeInQueryString && params) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            if (additionalQueryParams) {\n                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n            }\n            return endpoint;\n        }\n        function getXhrReadyStateChangeHandler(id) {\n            return function() {\n                if (getXhrOrXdr(id).readyState === 4) {\n                    onComplete(id);\n                }\n            };\n        }\n        function registerForUploadProgress(id) {\n            var onProgress = options.onProgress;\n            if (onProgress) {\n                getXhrOrXdr(id).upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        onProgress(id, e.loaded, e.total);\n                    }\n                };\n            }\n        }\n        function getXdrLoadHandler(id) {\n            return function() {\n                onComplete(id);\n            };\n        }\n        function getXdrErrorHandler(id) {\n            return function() {\n                onComplete(id, true);\n            };\n        }\n        function setHeaders(id) {\n            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n            if (!isXdr(xhr)) {\n                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n                if (options.allowXRequestedWithAndCacheControl) {\n                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                    }\n                }\n                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n                }\n                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n                qq.extend(allHeaders, onDemandHeaders);\n                qq.each(allHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        }\n        function isResponseSuccessful(responseCode) {\n            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n        }\n        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n            requestData[id] = {\n                addToPath: addToPath,\n                additionalParams: additionalParams,\n                additionalQueryParams: additionalQueryParams,\n                additionalHeaders: additionalHeaders,\n                payload: payload\n            };\n            var len = queue.push(id);\n            if (len <= options.maxConnections) {\n                return sendRequest(id, optXhr);\n            }\n        }\n        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n        qq.extend(this, {\n            initTransport: function(id) {\n                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n                return {\n                    withPath: function(appendToPath) {\n                        path = appendToPath;\n                        return this;\n                    },\n                    withParams: function(additionalParams) {\n                        params = additionalParams;\n                        return this;\n                    },\n                    withQueryParams: function(_additionalQueryParams_) {\n                        additionalQueryParams = _additionalQueryParams_;\n                        return this;\n                    },\n                    withHeaders: function(additionalHeaders) {\n                        headers = additionalHeaders;\n                        return this;\n                    },\n                    withPayload: function(thePayload) {\n                        payload = thePayload;\n                        return this;\n                    },\n                    withCacheBuster: function() {\n                        cacheBuster = true;\n                        return this;\n                    },\n                    send: function(optXhr) {\n                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n                            params.qqtimestamp = new Date().getTime();\n                        }\n                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                    }\n                };\n            },\n            canceled: function(id) {\n                dequeue(id);\n            }\n        });\n    };\n    qq.UploadHandler = function(spec) {\n        \"use strict\";\n        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n        qq.extend(this, {\n            add: function(id, fileItem) {\n                fileState[id] = fileItem;\n                fileState[id].temp = {};\n            },\n            cancel: function(id) {\n                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n                onCancelRetVal.then(function() {\n                    if (self.isValid(id)) {\n                        fileState[id].canceled = true;\n                        self.expunge(id);\n                    }\n                    cancelFinalizationEffort.success();\n                });\n            },\n            expunge: function(id) {\n                delete fileState[id];\n            },\n            getThirdPartyFileId: function(id) {\n                return fileState[id].key;\n            },\n            isValid: function(id) {\n                return fileState[id] !== undefined;\n            },\n            reset: function() {\n                fileState = {};\n            },\n            _getFileState: function(id) {\n                return fileState[id];\n            },\n            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n                fileState[id].key = thirdPartyFileId;\n            },\n            _wasCanceled: function(id) {\n                return !!fileState[id].canceled;\n            }\n        });\n    };\n    qq.UploadHandlerController = function(o, namespace) {\n        \"use strict\";\n        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n            paramsStore: {},\n            maxConnections: 3,\n            chunking: {\n                enabled: false,\n                multiple: {\n                    enabled: false\n                }\n            },\n            log: function(str, level) {},\n            onProgress: function(id, fileName, loaded, total) {},\n            onComplete: function(id, fileName, response, xhr) {},\n            onCancel: function(id, fileName) {},\n            onUploadPrep: function(id) {},\n            onUpload: function(id, fileName) {},\n            onUploadChunk: function(id, fileName, chunkData) {},\n            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n            onAutoRetry: function(id, fileName, response, xhr) {},\n            onResume: function(id, fileName, chunkData, customResumeData) {},\n            onUuidChanged: function(id, newUuid) {},\n            getName: function(id) {},\n            setSize: function(id, newSize) {},\n            isQueued: function(id) {},\n            getIdsInProxyGroup: function(id) {},\n            getIdsInBatch: function(id) {},\n            isInProgress: function(id) {}\n        }, chunked = {\n            done: function(id, chunkIdx, response, xhr) {\n                var chunkData = handler._getChunkData(id, chunkIdx);\n                handler._getFileState(id).attemptingResume = false;\n                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n                handler._getFileState(id).loaded += chunkData.size;\n                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n            },\n            finalize: function(id) {\n                var size = options.getSize(id), name = options.getName(id);\n                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n                handler.finalizeChunks(id).then(function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                }, function(response, xhr) {\n                    var normalizedResponse = upload.normalizeResponse(response, false);\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n                    if (normalizedResponse.reset || xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0) {\n                        chunked.reset(id);\n                    }\n                    if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n                        upload.cleanup(id, normalizedResponse, xhr);\n                    }\n                });\n            },\n            handleFailure: function(chunkIdx, id, response, xhr) {\n                var name = options.getName(id);\n                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n                if (responseToReport.reset) {\n                    chunked.reset(id);\n                } else {\n                    var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n                    inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n                    if (inProgressIdx >= 0) {\n                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                    }\n                }\n                if (!handler._getFileState(id).temp.ignoreFailure) {\n                    if (concurrentChunkingPossible) {\n                        handler._getFileState(id).temp.ignoreFailure = true;\n                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                            ckXhr.abort();\n                            ckXhr._cancelled = true;\n                        });\n                        handler.moveInProgressToRemaining(id);\n                        connectionManager.free(id, true);\n                    }\n                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                        upload.cleanup(id, responseToReport, xhr);\n                    }\n                }\n            },\n            hasMoreParts: function(id) {\n                return !!handler._getFileState(id).chunking.remaining.length;\n            },\n            nextPart: function(id) {\n                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n                if (nextIdx >= handler._getTotalChunks(id)) {\n                    nextIdx = null;\n                }\n                return nextIdx;\n            },\n            reset: function(id) {\n                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n                handler._maybeDeletePersistedChunkData(id);\n                handler.reevaluateChunking(id);\n                handler._getFileState(id).loaded = 0;\n                handler._getFileState(id).attemptingResume = false;\n            },\n            sendNext: function(id) {\n                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), fileState = handler._getFileState(id), resuming = fileState.attemptingResume, inProgressChunks = fileState.chunking.inProgress || [];\n                if (fileState.loaded == null) {\n                    fileState.loaded = 0;\n                }\n                if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n                    chunked.reset(id);\n                    chunkIdx = chunked.nextPart(id);\n                    chunkData = handler._getChunkData(id, chunkIdx);\n                    resuming = false;\n                }\n                if (chunkIdx == null && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                } else {\n                    inProgressChunks.push(chunkIdx);\n                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n                    if (concurrentChunkingPossible) {\n                        connectionManager.open(id, chunkIdx);\n                    }\n                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                        chunked.sendNext(id);\n                    }\n                    if (chunkData.blob.size === 0) {\n                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                    }\n                    var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n                    onUploadChunkPromise.then(function(requestOverrides) {\n                        if (!options.isInProgress(id)) {\n                            log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n                        } else {\n                            log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                            var uploadChunkData = {\n                                chunkIdx: chunkIdx,\n                                id: id,\n                                overrides: requestOverrides,\n                                resuming: resuming\n                            };\n                            handler.uploadChunk(uploadChunkData).then(function success(response, xhr) {\n                                log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                                handler.clearCachedChunk(id, chunkIdx);\n                                var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                                log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                                chunked.done(id, chunkIdx, responseToReport, xhr);\n                                if (inProgressChunkIdx >= 0) {\n                                    inProgressChunks.splice(inProgressChunkIdx, 1);\n                                }\n                                handler._maybePersistChunkedState(id);\n                                if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                    chunked.finalize(id);\n                                } else if (chunked.hasMoreParts(id)) {\n                                    chunked.sendNext(id);\n                                } else {\n                                    log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                                }\n                            }, function failure(response, xhr) {\n                                chunked.handleFailure(chunkIdx, id, response, xhr);\n                            }).done(function() {\n                                handler.clearXhr(id, chunkIdx);\n                            });\n                        }\n                    }, function(error) {\n                        chunked.handleFailure(chunkIdx, id, error, null);\n                    });\n                }\n            }\n        }, connectionManager = {\n            _open: [],\n            _openChunks: {},\n            _waiting: [],\n            available: function() {\n                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                    openChunkEntriesCount++;\n                    openChunksCount += openChunkIndexes.length;\n                });\n                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n            },\n            free: function(id, dontAllowNext) {\n                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n                delete connectionManager._openChunks[id];\n                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                    delete handler._getFileState(id).file;\n                }\n                if (waitingIndex >= 0) {\n                    connectionManager._waiting.splice(waitingIndex, 1);\n                } else if (allowNext && connectionsIndex >= 0) {\n                    connectionManager._open.splice(connectionsIndex, 1);\n                    nextId = connectionManager._waiting.shift();\n                    if (nextId >= 0) {\n                        connectionManager._open.push(nextId);\n                        upload.start(nextId);\n                    }\n                }\n            },\n            getWaitingOrConnected: function() {\n                var waitingOrConnected = [];\n                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                    if (chunks && chunks.length) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                qq.each(connectionManager._open, function(idx, fileId) {\n                    if (!connectionManager._openChunks[fileId]) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n                return waitingOrConnected;\n            },\n            isUsingConnection: function(id) {\n                return qq.indexOf(connectionManager._open, id) >= 0;\n            },\n            open: function(id, chunkIdx) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.push(id);\n                }\n                if (connectionManager.available()) {\n                    if (chunkIdx == null) {\n                        connectionManager._waiting.pop();\n                        connectionManager._open.push(id);\n                    } else {\n                        (function() {\n                            var openChunksEntry = connectionManager._openChunks[id] || [];\n                            openChunksEntry.push(chunkIdx);\n                            connectionManager._openChunks[id] = openChunksEntry;\n                        })();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            reset: function() {\n                connectionManager._waiting = [];\n                connectionManager._open = [];\n            }\n        }, simple = {\n            send: function(id, name) {\n                var fileState = handler._getFileState(id);\n                if (!fileState) {\n                    log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n                    return;\n                }\n                fileState.loaded = 0;\n                log(\"Sending simple upload request for \" + id);\n                handler.uploadFile(id).then(function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                }, function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, false);\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                });\n            }\n        }, upload = {\n            cancel: function(id) {\n                log(\"Cancelling \" + id);\n                options.paramsStore.remove(id);\n                connectionManager.free(id);\n            },\n            cleanup: function(id, response, optXhr) {\n                var name = options.getName(id);\n                options.onComplete(id, name, response, optXhr);\n                if (handler._getFileState(id)) {\n                    handler._clearXhrs && handler._clearXhrs(id);\n                }\n                connectionManager.free(id);\n            },\n            getProxyOrBlob: function(id) {\n                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n            },\n            initHandler: function() {\n                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n                    getCustomResumeData: options.getCustomResumeData,\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged,\n                    onFinalizing: function(id) {\n                        options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n                    }\n                });\n                if (handler._removeExpiredChunkingRecords) {\n                    handler._removeExpiredChunkingRecords();\n                }\n            },\n            isDeferredEligibleForUpload: function(id) {\n                return options.isQueued(id);\n            },\n            maybeDefer: function(id, blob) {\n                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n                    options.onUploadPrep(id);\n                    log(\"Attempting to generate a blob on-demand for \" + id);\n                    blob.create().then(function(generatedBlob) {\n                        log(\"Generated an on-demand blob for \" + id);\n                        handler.updateBlob(id, generatedBlob);\n                        options.setSize(id, generatedBlob.size);\n                        handler.reevaluateChunking(id);\n                        upload.maybeSendDeferredFiles(id);\n                    }, function(errorMessage) {\n                        var errorResponse = {};\n                        if (errorMessage) {\n                            errorResponse.error = errorMessage;\n                        }\n                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                        upload.maybeSendDeferredFiles(id);\n                        connectionManager.free(id);\n                    });\n                } else {\n                    return upload.maybeSendDeferredFiles(id);\n                }\n                return false;\n            },\n            maybeSendDeferredFiles: function(id) {\n                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n                if (idsInGroup && idsInGroup.length) {\n                    log(\"Maybe ready to upload proxy group file \" + id);\n                    qq.each(idsInGroup, function(idx, idInGroup) {\n                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                            uploadedThisId = idInGroup === id;\n                            upload.now(idInGroup);\n                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                            return false;\n                        }\n                    });\n                } else {\n                    uploadedThisId = true;\n                    upload.now(id);\n                }\n                return uploadedThisId;\n            },\n            maybeNewUuid: function(id, response) {\n                if (response.newUuid !== undefined) {\n                    options.onUuidChanged(id, response.newUuid);\n                }\n            },\n            normalizeResponse: function(originalResponse, successful) {\n                var response = originalResponse;\n                if (!qq.isObject(originalResponse)) {\n                    response = {};\n                    if (qq.isString(originalResponse) && !successful) {\n                        response.error = originalResponse;\n                    }\n                }\n                response.success = successful;\n                return response;\n            },\n            now: function(id) {\n                var name = options.getName(id);\n                if (!controller.isValid(id)) {\n                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n                }\n                options.onUpload(id, name).then(function(response) {\n                    if (response && response.pause) {\n                        options.setStatus(id, qq.status.PAUSED);\n                        handler.pause(id);\n                        connectionManager.free(id);\n                    } else {\n                        if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                            chunked.sendNext(id);\n                        } else {\n                            simple.send(id, name);\n                        }\n                    }\n                }, function(error) {\n                    error = error || {};\n                    log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n                    if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n                        var response = upload.normalizeResponse(error.responseJSON, false);\n                        upload.cleanup(id, response);\n                    }\n                });\n            },\n            start: function(id) {\n                var blobToUpload = upload.getProxyOrBlob(id);\n                if (blobToUpload) {\n                    return upload.maybeDefer(id, blobToUpload);\n                } else {\n                    upload.now(id);\n                    return true;\n                }\n            }\n        };\n        qq.extend(this, {\n            add: function(id, file) {\n                handler.add.apply(this, arguments);\n            },\n            upload: function(id) {\n                if (connectionManager.open(id)) {\n                    return upload.start(id);\n                }\n                return false;\n            },\n            retry: function(id) {\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = false;\n                }\n                if (connectionManager.isUsingConnection(id)) {\n                    return upload.start(id);\n                } else {\n                    return controller.upload(id);\n                }\n            },\n            cancel: function(id) {\n                var cancelRetVal = handler.cancel(id);\n                if (qq.isGenericPromise(cancelRetVal)) {\n                    cancelRetVal.then(function() {\n                        upload.cancel(id);\n                    });\n                } else if (cancelRetVal !== false) {\n                    upload.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n                if (waitingOrConnected.length) {\n                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                        controller.cancel(waitingOrConnected[i]);\n                    }\n                }\n                connectionManager.reset();\n            },\n            getFile: function(id) {\n                if (handler.getProxy && handler.getProxy(id)) {\n                    return handler.getProxy(id).referenceBlob;\n                }\n                return handler.getFile && handler.getFile(id);\n            },\n            isProxied: function(id) {\n                return !!(handler.getProxy && handler.getProxy(id));\n            },\n            getInput: function(id) {\n                if (handler.getInput) {\n                    return handler.getInput(id);\n                }\n            },\n            reset: function() {\n                log(\"Resetting upload handler\");\n                controller.cancelAll();\n                connectionManager.reset();\n                handler.reset();\n            },\n            expunge: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.expunge(id);\n                }\n            },\n            isValid: function(id) {\n                return handler.isValid(id);\n            },\n            hasResumeRecord: function(id) {\n                var key = handler.isValid(id) && handler._getLocalStorageId && handler._getLocalStorageId(id);\n                if (key) {\n                    return !!localStorage.getItem(key);\n                }\n                return false;\n            },\n            getResumableFilesData: function() {\n                if (handler.getResumableFilesData) {\n                    return handler.getResumableFilesData();\n                }\n                return [];\n            },\n            getThirdPartyFileId: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.getThirdPartyFileId(id);\n                }\n            },\n            pause: function(id) {\n                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                    connectionManager.free(id);\n                    handler.moveInProgressToRemaining(id);\n                    return true;\n                }\n                return false;\n            },\n            isAttemptingResume: function(id) {\n                return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n            },\n            isResumable: function(id) {\n                return !!handler.isResumable && handler.isResumable(id);\n            }\n        });\n        qq.extend(options, o);\n        log = options.log;\n        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n        preventRetryResponse = function() {\n            var response = {};\n            response[options.preventRetryParam] = true;\n            return response;\n        }();\n        upload.initHandler();\n    };\n    qq.WindowReceiveMessage = function(o) {\n        \"use strict\";\n        var options = {\n            log: function(message, level) {}\n        }, callbackWrapperDetachers = {};\n        qq.extend(options, o);\n        qq.extend(this, {\n            receiveMessage: function(id, callback) {\n                var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n                if (window.postMessage) {\n                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n                } else {\n                    log(\"iframe message passing not supported in this browser!\", \"error\");\n                }\n            },\n            stopReceivingMessages: function(id) {\n                if (window.postMessage) {\n                    var detacher = callbackWrapperDetachers[id];\n                    if (detacher) {\n                        detacher();\n                    }\n                }\n            }\n        });\n    };\n    qq.FormUploadHandler = function(spec) {\n        \"use strict\";\n        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n            log: log\n        });\n        function expungeFile(id) {\n            delete detachLoadEvents[id];\n            if (isCors) {\n                clearTimeout(postMessageCallbackTimers[id]);\n                delete postMessageCallbackTimers[id];\n                corsMessageReceiver.stopReceivingMessages(id);\n            }\n            var iframe = document.getElementById(handler._getIframeName(id));\n            if (iframe) {\n                iframe.setAttribute(\"src\", \"javascript:false;\");\n                qq(iframe).remove();\n            }\n        }\n        function getFileIdForIframeName(iframeName) {\n            return iframeName.split(\"_\")[0];\n        }\n        function initIframeForUpload(name) {\n            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n            iframe.setAttribute(\"id\", name);\n            iframe.style.display = \"none\";\n            document.body.appendChild(iframe);\n            return iframe;\n        }\n        function registerPostMessageCallback(iframe, callback) {\n            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n            onloadCallbacks[uuid] = callback;\n            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n                if (handler.getInput(fileId)) {\n                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                        log(errorMessage, \"error\");\n                        callback({\n                            error: errorMessage\n                        });\n                    }, 1e3);\n                }\n            });\n            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n                log(\"Received the following window message: '\" + message + \"'\");\n                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n                if (uuid && onloadCallbacks[uuid]) {\n                    log(\"Handling response for iframe name \" + iframeName);\n                    clearTimeout(postMessageCallbackTimers[iframeName]);\n                    delete postMessageCallbackTimers[iframeName];\n                    handler._detachLoadEvent(iframeName);\n                    onloadCallback = onloadCallbacks[uuid];\n                    delete onloadCallbacks[uuid];\n                    corsMessageReceiver.stopReceivingMessages(iframeName);\n                    onloadCallback(response);\n                } else if (!uuid) {\n                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n                }\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, fileInput) {\n                    super_.add(id, {\n                        input: fileInput\n                    });\n                    fileInput.setAttribute(\"name\", inputName);\n                    if (fileInput.parentNode) {\n                        qq(fileInput).remove();\n                    }\n                },\n                expunge: function(id) {\n                    expungeFile(id);\n                    super_.expunge(id);\n                },\n                isValid: function(id) {\n                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n                }\n            };\n        });\n        qq.extend(this, {\n            getInput: function(id) {\n                return handler._getFileState(id).input;\n            },\n            _attachLoadEvent: function(iframe, callback) {\n                var responseDescriptor;\n                if (isCors) {\n                    registerPostMessageCallback(iframe, callback);\n                } else {\n                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                        log(\"Received response for \" + iframe.id);\n                        if (!iframe.parentNode) {\n                            return;\n                        }\n                        try {\n                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                                return;\n                            }\n                        } catch (error) {\n                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                            responseDescriptor = {\n                                success: false\n                            };\n                        }\n                        callback(responseDescriptor);\n                    });\n                }\n            },\n            _createIframe: function(id) {\n                var iframeName = handler._getIframeName(id);\n                return initIframeForUpload(iframeName);\n            },\n            _detachLoadEvent: function(id) {\n                if (detachLoadEvents[id] !== undefined) {\n                    detachLoadEvents[id]();\n                    delete detachLoadEvents[id];\n                }\n            },\n            _getIframeName: function(fileId) {\n                return fileId + \"_\" + formHandlerInstanceId;\n            },\n            _initFormForUpload: function(spec) {\n                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n                if (paramsInBody) {\n                    qq.obj2Inputs(params, form);\n                } else {\n                    url = qq.obj2url(params, endpoint);\n                }\n                form.setAttribute(\"action\", url);\n                form.setAttribute(\"target\", targetName);\n                form.style.display = \"none\";\n                document.body.appendChild(form);\n                return form;\n            },\n            _parseJsonResponse: function(innerHtmlOrMessage) {\n                var response = {};\n                try {\n                    response = qq.parseJson(innerHtmlOrMessage);\n                } catch (error) {\n                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n                }\n                return response;\n            }\n        });\n    };\n    qq.XhrUploadHandler = function(spec) {\n        \"use strict\";\n        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, getChunkSize = function(id) {\n            var fileState = handler._getFileState(id);\n            if (fileState.chunkSize) {\n                return fileState.chunkSize;\n            } else {\n                var chunkSize = chunking.partSize;\n                if (qq.isFunction(chunkSize)) {\n                    chunkSize = chunkSize(id, getSize(id));\n                }\n                fileState.chunkSize = chunkSize;\n                return chunkSize;\n            }\n        }, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log, getCustomResumeData = proxy.getCustomResumeData;\n        function abort(id) {\n            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n                xhr.onreadystatechange = null;\n                xhr.upload.onprogress = null;\n                xhr.abort();\n                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, blobOrProxy) {\n                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                        super_.add(id, {\n                            file: blobOrProxy\n                        });\n                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n                        super_.add(id, {\n                            proxy: blobOrProxy\n                        });\n                    } else {\n                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                    }\n                    handler._initTempState(id);\n                    resumeEnabled && handler._maybePrepareForResume(id);\n                },\n                expunge: function(id) {\n                    abort(id);\n                    handler._maybeDeletePersistedChunkData(id);\n                    handler._clearXhrs(id);\n                    super_.expunge(id);\n                }\n            };\n        });\n        qq.extend(this, {\n            clearCachedChunk: function(id, chunkIdx) {\n                var fileState = handler._getFileState(id);\n                if (fileState) {\n                    delete fileState.temp.cachedChunks[chunkIdx];\n                }\n            },\n            clearXhr: function(id, chunkIdx) {\n                var tempState = handler._getFileState(id).temp;\n                if (tempState.xhrs) {\n                    delete tempState.xhrs[chunkIdx];\n                }\n                if (tempState.ajaxRequesters) {\n                    delete tempState.ajaxRequesters[chunkIdx];\n                }\n            },\n            finalizeChunks: function(id, responseParser) {\n                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n                if (responseParser) {\n                    return new qq.Promise().success(responseParser(xhr), xhr);\n                }\n                return new qq.Promise().success({}, xhr);\n            },\n            getFile: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).file;\n            },\n            getProxy: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).proxy;\n            },\n            getResumableFilesData: function() {\n                var resumableFilesData = [];\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n                    var data = {\n                        name: uploadData.name,\n                        remaining: uploadData.chunking.remaining,\n                        size: uploadData.size,\n                        uuid: uploadData.uuid\n                    };\n                    if (uploadData.key) {\n                        data.key = uploadData.key;\n                    }\n                    if (uploadData.customResumeData) {\n                        data.customResumeData = uploadData.customResumeData;\n                    }\n                    resumableFilesData.push(data);\n                });\n                return resumableFilesData;\n            },\n            isAttemptingResume: function(id) {\n                return handler._getFileState(id).attemptingResume;\n            },\n            isResumable: function(id) {\n                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n            },\n            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n                var fileState = handler._getFileState(id) || {}, chunkingState = fileState.chunking || {}, inProgress = optInProgress || chunkingState.inProgress, remaining = optRemaining || chunkingState.remaining;\n                if (inProgress) {\n                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                    inProgress.reverse();\n                    qq.each(inProgress, function(idx, chunkIdx) {\n                        remaining.unshift(chunkIdx);\n                    });\n                    inProgress.length = 0;\n                }\n            },\n            pause: function(id) {\n                if (handler.isValid(id)) {\n                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                    handler._getFileState(id).paused = true;\n                    abort(id);\n                    return true;\n                }\n            },\n            reevaluateChunking: function(id) {\n                if (chunking && handler.isValid(id)) {\n                    var state = handler._getFileState(id), totalChunks, i;\n                    delete state.chunking;\n                    state.chunking = {};\n                    totalChunks = handler._getTotalChunks(id);\n                    if (totalChunks > 1 || chunking.mandatory) {\n                        state.chunking.enabled = true;\n                        state.chunking.parts = totalChunks;\n                        state.chunking.remaining = [];\n                        for (i = 0; i < totalChunks; i++) {\n                            state.chunking.remaining.push(i);\n                        }\n                        handler._initTempState(id);\n                    } else {\n                        state.chunking.enabled = false;\n                    }\n                }\n            },\n            updateBlob: function(id, newBlob) {\n                if (handler.isValid(id)) {\n                    handler._getFileState(id).file = newBlob;\n                }\n            },\n            _clearXhrs: function(id) {\n                var tempState = handler._getFileState(id).temp;\n                qq.each(tempState.ajaxRequesters, function(chunkId) {\n                    delete tempState.ajaxRequesters[chunkId];\n                });\n                qq.each(tempState.xhrs, function(chunkId) {\n                    delete tempState.xhrs[chunkId];\n                });\n            },\n            _createXhr: function(id, optChunkIdx) {\n                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n            },\n            _getAjaxRequester: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n            },\n            _getChunkData: function(id, chunkIndex) {\n                var chunkSize = getChunkSize(id), fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n                cachedChunks[chunkIndex] = blob;\n                return {\n                    part: chunkIndex,\n                    start: startBytes,\n                    end: endBytes,\n                    count: totalChunks,\n                    blob: blob,\n                    size: endBytes - startBytes\n                };\n            },\n            _getChunkDataForCallback: function(chunkData) {\n                return {\n                    partIndex: chunkData.part,\n                    startByte: chunkData.start + 1,\n                    endByte: chunkData.end,\n                    totalParts: chunkData.count\n                };\n            },\n            _getLocalStorageId: function(id) {\n                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = getChunkSize(id), endpoint = getEndpoint(id), customKeys = resume.customKeys(id), localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n                customKeys.forEach(function(key) {\n                    localStorageId += \"-\" + key;\n                });\n                return localStorageId;\n            },\n            _getMimeType: function(id) {\n                return handler.getFile(id).type;\n            },\n            _getPersistableData: function(id) {\n                return handler._getFileState(id).chunking;\n            },\n            _getTotalChunks: function(id) {\n                if (chunking) {\n                    var fileSize = getSize(id), chunkSize = getChunkSize(id);\n                    return Math.ceil(fileSize / chunkSize);\n                }\n            },\n            _getXhr: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.xhrs[chunkIdx];\n            },\n            _getXhrs: function(id) {\n                return handler._getFileState(id).temp.xhrs;\n            },\n            _iterateResumeRecords: function(callback) {\n                if (resumeEnabled) {\n                    qq.each(localStorage, function(key, item) {\n                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                            var uploadData = JSON.parse(item);\n                            callback(key, uploadData);\n                        }\n                    });\n                }\n            },\n            _initTempState: function(id) {\n                handler._getFileState(id).temp = {\n                    ajaxRequesters: {},\n                    chunkProgress: {},\n                    xhrs: {},\n                    cachedChunks: {}\n                };\n            },\n            _markNotResumable: function(id) {\n                handler._getFileState(id).notResumable = true;\n            },\n            _maybeDeletePersistedChunkData: function(id) {\n                var localStorageId;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    if (localStorageId && localStorage.getItem(localStorageId)) {\n                        localStorage.removeItem(localStorageId);\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _maybePrepareForResume: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && state.key === undefined) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = localStorage.getItem(localStorageId);\n                    if (persistedData) {\n                        persistedData = JSON.parse(persistedData);\n                        if (getDataByUuid(persistedData.uuid)) {\n                            handler._markNotResumable(id);\n                        } else {\n                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n                            onUuidChanged(id, persistedData.uuid);\n                            state.key = persistedData.key;\n                            state.chunking = persistedData.chunking;\n                            state.loaded = persistedData.loaded;\n                            state.customResumeData = persistedData.customResumeData;\n                            state.attemptingResume = true;\n                            handler.moveInProgressToRemaining(id);\n                        }\n                    }\n                }\n            },\n            _maybePersistChunkedState: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    var customResumeData = getCustomResumeData(id);\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = {\n                        name: getName(id),\n                        size: getSize(id),\n                        uuid: getUuid(id),\n                        key: state.key,\n                        chunking: state.chunking,\n                        loaded: state.loaded,\n                        lastUpdated: Date.now()\n                    };\n                    if (customResumeData) {\n                        persistedData.customResumeData = customResumeData;\n                    }\n                    try {\n                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                    } catch (error) {\n                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                    }\n                }\n            },\n            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        } else {\n                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n                        }\n                    },\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n                xhr.upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n                        progressCalculator[type](e.loaded, e.total);\n                    }\n                };\n            },\n            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n                tempState.xhrs = tempState.xhrs || {};\n                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n                tempState.xhrs[xhrsId] = xhr;\n                if (optAjaxRequester) {\n                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n                }\n                return xhr;\n            },\n            _removeExpiredChunkingRecords: function() {\n                var expirationDays = resume.recordsExpireIn;\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    var expirationDate = new Date(uploadData.lastUpdated);\n                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n                    if (expirationDate.getTime() <= Date.now()) {\n                        log(\"Removing expired resume record with key \" + key);\n                        localStorage.removeItem(key);\n                    }\n                });\n            },\n            _shouldChunkThisFile: function(id) {\n                var state = handler._getFileState(id);\n                if (state) {\n                    if (!state.chunking) {\n                        handler.reevaluateChunking(id);\n                    }\n                    return state.chunking.enabled;\n                }\n            }\n        });\n    };\n    qq.DeleteFileAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {\n                return {};\n            },\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n        qq.extend(options, o);\n        function getMandatedParams() {\n            if (options.method.toUpperCase() === \"POST\") {\n                return {\n                    _method: \"DELETE\"\n                };\n            }\n            return {};\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"POST\", \"DELETE\" ],\n            method: options.method,\n            endpointStore: options.endpointStore,\n            paramsStore: options.paramsStore,\n            mandatedParams: getMandatedParams(),\n            maxConnections: options.maxConnections,\n            customHeaders: function(id) {\n                return options.customHeaders.get(id);\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendDelete: function(id, uuid, additionalMandatedParams) {\n                var additionalOptions = additionalMandatedParams || {};\n                options.log(\"Submitting delete file request for \" + id);\n                if (options.method === \"DELETE\") {\n                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n                } else {\n                    additionalOptions[options.uuidParamName] = uuid;\n                    requester.initTransport(id).withParams(additionalOptions).send();\n                }\n            }\n        });\n    };\n    (function() {\n        function detectSubsampling(img) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n            if (iw * ih > 1024 * 1024) {\n                canvas.width = canvas.height = 1;\n                ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img, -iw + 1, 0);\n                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n            } else {\n                return false;\n            }\n        }\n        function detectVerticalSquash(img, iw, ih) {\n            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n            canvas.width = 1;\n            canvas.height = ih;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            data = ctx.getImageData(0, 0, 1, ih).data;\n            while (py > sy) {\n                alpha = data[(py - 1) * 4 + 3];\n                if (alpha === 0) {\n                    ey = py;\n                } else {\n                    sy = py;\n                }\n                py = ey + sy >> 1;\n            }\n            ratio = py / ih;\n            return ratio === 0 ? 1 : ratio;\n        }\n        function renderImageToDataURL(img, blob, options, doSquash) {\n            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n                promise.success(canvas.toDataURL(mime, options.quality || .8));\n            });\n            return promise;\n        }\n        function maybeCalculateDownsampledDimensions(spec) {\n            var maxPixels = 5241e3;\n            if (!qq.ios()) {\n                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n            }\n            if (spec.origHeight * spec.origWidth > maxPixels) {\n                return {\n                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n                };\n            }\n        }\n        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n            ctx.save();\n            if (options.resize) {\n                return renderImageToCanvasWithCustomResizer({\n                    blob: blob,\n                    canvas: canvas,\n                    image: img,\n                    imageHeight: ih,\n                    imageWidth: iw,\n                    orientation: options.orientation,\n                    resize: options.resize,\n                    targetHeight: height,\n                    targetWidth: width\n                });\n            }\n            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n                modifiedDimensions = maybeCalculateDownsampledDimensions({\n                    origWidth: width,\n                    origHeight: height\n                });\n                if (modifiedDimensions) {\n                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n                    width = modifiedDimensions.newWidth;\n                    height = modifiedDimensions.newHeight;\n                }\n            }\n            transformCoordinate(canvas, width, height, options.orientation);\n            if (qq.ios()) {\n                (function() {\n                    if (detectSubsampling(img)) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n                    tmpCanvas.width = tmpCanvas.height = d;\n                    tmpCtx = tmpCanvas.getContext(\"2d\");\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                })();\n            } else {\n                ctx.drawImage(img, 0, 0, width, height);\n            }\n            canvas.qqImageRendered && canvas.qqImageRendered();\n            promise.success();\n            return promise;\n        }\n        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n            targetCanvas.height = targetHeight;\n            targetCanvas.width = targetWidth;\n            sourceCanvasContext.drawImage(image, 0, 0);\n            resize({\n                blob: blob,\n                height: targetHeight,\n                image: image,\n                sourceCanvas: sourceCanvas,\n                targetCanvas: targetCanvas,\n                width: targetWidth\n            }).then(function success() {\n                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                promise.success();\n            }, promise.failure);\n            return promise;\n        }\n        function transformCoordinate(canvas, width, height, orientation) {\n            switch (orientation) {\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n\n              default:\n                canvas.width = width;\n                canvas.height = height;\n            }\n            var ctx = canvas.getContext(\"2d\");\n            switch (orientation) {\n              case 2:\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n\n              case 7:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n\n              default:\n                break;\n            }\n        }\n        function MegaPixImage(srcImage, errorCallback) {\n            var self = this;\n            if (window.Blob && srcImage instanceof Blob) {\n                (function() {\n                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                    if (!URL) {\n                        throw Error(\"No createObjectURL function found to create blob url\");\n                    }\n                    img.src = URL.createObjectURL(srcImage);\n                    self.blob = srcImage;\n                    srcImage = img;\n                })();\n            }\n            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n                srcImage.onload = function() {\n                    var listeners = self.imageLoadListeners;\n                    if (listeners) {\n                        self.imageLoadListeners = null;\n                        setTimeout(function() {\n                            for (var i = 0, len = listeners.length; i < len; i++) {\n                                listeners[i]();\n                            }\n                        }, 0);\n                    }\n                };\n                srcImage.onerror = errorCallback;\n                this.imageLoadListeners = [];\n            }\n            this.srcImage = srcImage;\n        }\n        MegaPixImage.prototype.render = function(target, options) {\n            options = options || {};\n            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n            if (this.imageLoadListeners) {\n                this.imageLoadListeners.push(function() {\n                    self.render(target, options);\n                });\n                return;\n            }\n            if (width && !height) {\n                height = imgHeight * width / imgWidth << 0;\n            } else if (height && !width) {\n                width = imgWidth * height / imgHeight << 0;\n            } else {\n                width = imgWidth;\n                height = imgHeight;\n            }\n            if (maxWidth && width > maxWidth) {\n                width = maxWidth;\n                height = imgHeight * width / imgWidth << 0;\n            }\n            if (maxHeight && height > maxHeight) {\n                height = maxHeight;\n                width = imgWidth * height / imgHeight << 0;\n            }\n            opt = {\n                width: width,\n                height: height\n            }, qq.each(options, function(optionsKey, optionsValue) {\n                opt[optionsKey] = optionsValue;\n            });\n            if (tagName === \"img\") {\n                (function() {\n                    var oldTargetSrc = target.src;\n                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n                })();\n            } else if (tagName === \"canvas\") {\n                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n            }\n            if (typeof this.onrender === \"function\") {\n                this.onrender(target);\n            }\n        };\n        qq.MegaPixImage = MegaPixImage;\n    })();\n    qq.ImageGenerator = function(log) {\n        \"use strict\";\n        function isImg(el) {\n            return el.tagName.toLowerCase() === \"img\";\n        }\n        function isCanvas(el) {\n            return el.tagName.toLowerCase() === \"canvas\";\n        }\n        function isImgCorsSupported() {\n            return new Image().crossOrigin !== undefined;\n        }\n        function isCanvasSupported() {\n            var canvas = document.createElement(\"canvas\");\n            return canvas.getContext && canvas.getContext(\"2d\");\n        }\n        function determineMimeOfFileName(nameWithPath) {\n            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n            extension = extension && extension.toLowerCase();\n            switch (extension) {\n              case \"jpeg\":\n              case \"jpg\":\n                return \"image/jpeg\";\n\n              case \"png\":\n                return \"image/png\";\n\n              case \"bmp\":\n                return \"image/bmp\";\n\n              case \"gif\":\n                return \"image/gif\";\n\n              case \"tiff\":\n              case \"tif\":\n                return \"image/tiff\";\n            }\n        }\n        function isCrossOrigin(url) {\n            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n            targetAnchor.href = url;\n            targetProtocol = targetAnchor.protocol;\n            targetPort = targetAnchor.port;\n            targetHostname = targetAnchor.hostname;\n            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n                return true;\n            }\n            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n                return true;\n            }\n            if (targetPort !== window.location.port && !qq.ie()) {\n                return true;\n            }\n            return false;\n        }\n        function registerImgLoadListeners(img, promise) {\n            img.onload = function() {\n                img.onload = null;\n                img.onerror = null;\n                promise.success(img);\n            };\n            img.onerror = function() {\n                img.onload = null;\n                img.onerror = null;\n                log(\"Problem drawing thumbnail!\", \"error\");\n                promise.failure(img, \"Problem drawing thumbnail!\");\n            };\n        }\n        function registerCanvasDrawImageListener(canvas, promise) {\n            canvas.qqImageRendered = function() {\n                promise.success(canvas);\n            };\n        }\n        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n            if (isImg(imgOrCanvas)) {\n                registerImgLoadListeners(imgOrCanvas, promise);\n            } else if (isCanvas(imgOrCanvas)) {\n                registerCanvasDrawImageListener(imgOrCanvas, promise);\n            } else {\n                promise.failure(imgOrCanvas);\n                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n            }\n            return registered;\n        }\n        function draw(fileOrBlob, container, options) {\n            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n            identifier.isPreviewable().then(function(mime) {\n                var dummyExif = {\n                    parse: function() {\n                        return new qq.Promise().success();\n                    }\n                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(function(exif) {\n                        var orientation = exif && exif.Orientation;\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            orientation: orientation,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    }, function(failureMsg) {\n                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    });\n                }\n            }, function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            });\n            return drawPreview;\n        }\n        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n            var tempImg = new Image(), tempImgRender = new qq.Promise();\n            registerThumbnailRenderedListener(tempImg, tempImgRender);\n            if (isCrossOrigin(url)) {\n                tempImg.crossOrigin = \"anonymous\";\n            }\n            tempImg.src = url;\n            tempImgRender.then(function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            }, draw.failure);\n        }\n        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n            registerThumbnailRenderedListener(img, draw);\n            qq(img).css({\n                maxWidth: maxSize + \"px\",\n                maxHeight: maxSize + \"px\"\n            });\n            img.src = url;\n        }\n        function drawFromUrl(url, container, options) {\n            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n            if (scale && isImg(container)) {\n                if (isCanvasSupported()) {\n                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                    } else {\n                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                    }\n                } else {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n            } else if (isCanvas(container)) {\n                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n            } else if (registerThumbnailRenderedListener(container, draw)) {\n                container.src = url;\n            }\n            return draw;\n        }\n        qq.extend(this, {\n            generate: function(fileBlobOrUrl, container, options) {\n                if (qq.isString(fileBlobOrUrl)) {\n                    log(\"Attempting to update thumbnail based on server response.\");\n                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n                } else {\n                    log(\"Attempting to draw client-side image preview.\");\n                    return draw(fileBlobOrUrl, container, options || {});\n                }\n            }\n        });\n        this._testing = {};\n        this._testing.isImg = isImg;\n        this._testing.isCanvas = isCanvas;\n        this._testing.isCrossOrigin = isCrossOrigin;\n        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    };\n    qq.Exif = function(fileOrBlob, log) {\n        \"use strict\";\n        var TAG_IDS = [ 274 ], TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n        function parseLittleEndian(hex) {\n            var result = 0, pow = 0;\n            while (hex.length > 0) {\n                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n                hex = hex.substring(2, hex.length);\n                pow += 8;\n            }\n            return result;\n        }\n        function seekToApp1(offset, promise) {\n            var theOffset = offset, thePromise = promise;\n            if (theOffset === undefined) {\n                theOffset = 2;\n                thePromise = new qq.Promise();\n            }\n            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n                if (match) {\n                    if (match[1] !== \"1\") {\n                        segmentLength = parseInt(hex.slice(4, 8), 16);\n                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n                    } else {\n                        thePromise.success(theOffset);\n                    }\n                } else {\n                    thePromise.failure(\"No EXIF header to be found!\");\n                }\n            });\n            return thePromise;\n        }\n        function getApp1Offset() {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n                if (hex.indexOf(\"ffd8\") !== 0) {\n                    promise.failure(\"Not a valid JPEG!\");\n                } else {\n                    seekToApp1().then(function(offset) {\n                        promise.success(offset);\n                    }, function(error) {\n                        promise.failure(error);\n                    });\n                }\n            });\n            return promise;\n        }\n        function isLittleEndian(app1Start) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n                promise.success(hex === \"4949\");\n            });\n            return promise;\n        }\n        function getDirEntryCount(app1Start, littleEndian) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n                if (littleEndian) {\n                    return promise.success(parseLittleEndian(hex));\n                } else {\n                    promise.success(parseInt(hex, 16));\n                }\n            });\n            return promise;\n        }\n        function getIfd(app1Start, dirEntries) {\n            var offset = app1Start + 20, bytes = dirEntries * 12;\n            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n        }\n        function getDirEntries(ifdHex) {\n            var entries = [], offset = 0;\n            while (offset + 24 <= ifdHex.length) {\n                entries.push(ifdHex.slice(offset, offset + 24));\n                offset += 24;\n            }\n            return entries;\n        }\n        function getTagValues(littleEndian, dirEntries) {\n            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n            qq.each(dirEntries, function(idx, entry) {\n                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n                if (tagsToFindIdx >= 0) {\n                    tagName = TAG_INFO[id].name;\n                    tagValLength = TAG_INFO[id].bytes;\n                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n                    tagsToFind.splice(tagsToFindIdx, 1);\n                }\n                if (tagsToFind.length === 0) {\n                    return false;\n                }\n            });\n            return vals;\n        }\n        qq.extend(this, {\n            parse: function() {\n                var parser = new qq.Promise(), onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n                getApp1Offset().then(function(app1Offset) {\n                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n                    isLittleEndian(app1Offset).then(function(littleEndian) {\n                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n                                log(\"Successfully parsed some EXIF tags\");\n                                parser.success(tagValues);\n                            }, onParseFailure);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n                return parser;\n            }\n        });\n        this._testing = {};\n        this._testing.parseLittleEndian = parseLittleEndian;\n    };\n    qq.Identify = function(fileOrBlob, log) {\n        \"use strict\";\n        function isIdentifiable(magicBytes, questionableBytes) {\n            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                    identifiable = true;\n                    return false;\n                }\n            });\n            return identifiable;\n        }\n        qq.extend(this, {\n            isPreviewable: function() {\n                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n                log(\"First pass: check type attribute of blob object.\");\n                if (this.isPreviewableSync()) {\n                    log(\"Second pass: check for magic bytes in file header.\");\n                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                            if (isIdentifiable(bytes, hex)) {\n                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                    previewable = true;\n                                    identifier.success(mime);\n                                }\n                                return false;\n                            }\n                        });\n                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n                        if (!previewable) {\n                            identifier.failure();\n                        }\n                    }, function() {\n                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                        identifier.failure();\n                    });\n                } else {\n                    identifier.failure();\n                }\n                return identifier;\n            },\n            isPreviewableSync: function() {\n                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                if (isRecognizedImage) {\n                    if (fileMime === \"image/tiff\") {\n                        previewable = qq.supportedFeatures.tiffPreviews;\n                    } else {\n                        previewable = true;\n                    }\n                }\n                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n                return previewable;\n            }\n        });\n    };\n    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n        \"image/jpeg\": \"ffd8ff\",\n        \"image/gif\": \"474946\",\n        \"image/png\": \"89504e\",\n        \"image/bmp\": \"424d\",\n        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n    };\n    qq.ImageValidation = function(blob, log) {\n        \"use strict\";\n        function hasNonZeroLimits(limits) {\n            var atLeastOne = false;\n            qq.each(limits, function(limit, value) {\n                if (value > 0) {\n                    atLeastOne = true;\n                    return false;\n                }\n            });\n            return atLeastOne;\n        }\n        function getWidthHeight() {\n            var sizeDetermination = new qq.Promise();\n            new qq.Identify(blob, log).isPreviewable().then(function() {\n                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (url) {\n                    image.onerror = function() {\n                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                        sizeDetermination.failure();\n                    };\n                    image.onload = function() {\n                        sizeDetermination.success({\n                            width: this.width,\n                            height: this.height\n                        });\n                    };\n                    image.src = url.createObjectURL(blob);\n                } else {\n                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                    sizeDetermination.failure();\n                }\n            }, sizeDetermination.failure);\n            return sizeDetermination;\n        }\n        function getFailingLimit(limits, dimensions) {\n            var failingLimit;\n            qq.each(limits, function(limitName, limitValue) {\n                if (limitValue > 0) {\n                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n                    switch (limitMatcher[1]) {\n                      case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n\n                      case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            });\n            return failingLimit;\n        }\n        this.validate = function(limits) {\n            var validationEffort = new qq.Promise();\n            log(\"Attempting to validate image.\");\n            if (hasNonZeroLimits(limits)) {\n                getWidthHeight().then(function(dimensions) {\n                    var failingLimit = getFailingLimit(limits, dimensions);\n                    if (failingLimit) {\n                        validationEffort.failure(failingLimit);\n                    } else {\n                        validationEffort.success();\n                    }\n                }, validationEffort.success);\n            } else {\n                validationEffort.success();\n            }\n            return validationEffort;\n        };\n    };\n    qq.Session = function(spec) {\n        \"use strict\";\n        var options = {\n            endpoint: null,\n            params: {},\n            customHeaders: {},\n            cors: {},\n            addFileRecord: function(sessionData) {},\n            log: function(message, level) {}\n        };\n        qq.extend(options, spec, true);\n        function isJsonResponseValid(response) {\n            if (qq.isArray(response)) {\n                return true;\n            }\n            options.log(\"Session response is not an array.\", \"error\");\n        }\n        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n            var someItemsIgnored = false;\n            success = success && isJsonResponseValid(fileItems);\n            if (success) {\n                qq.each(fileItems, function(idx, fileItem) {\n                    if (fileItem.uuid == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                    } else if (fileItem.name == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                    } else {\n                        try {\n                            options.addFileRecord(fileItem);\n                            return true;\n                        } catch (err) {\n                            someItemsIgnored = true;\n                            options.log(err.message, \"error\");\n                        }\n                    }\n                    return false;\n                });\n            }\n            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n        }\n        this.refresh = function() {\n            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n                onComplete: refreshCompleteCallback\n            }));\n            requester.queryServer();\n            return refreshEffort;\n        };\n    };\n    qq.SessionAjaxRequester = function(spec) {\n        \"use strict\";\n        var requester, options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, spec);\n        function onComplete(id, xhrOrXdr, isError) {\n            var response = null;\n            if (xhrOrXdr.responseText != null) {\n                try {\n                    response = qq.parseJson(xhrOrXdr.responseText);\n                } catch (err) {\n                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                    isError = true;\n                }\n            }\n            options.onComplete(response, !isError, xhrOrXdr);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: onComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            queryServer: function() {\n                var params = qq.extend({}, options.params);\n                options.log(\"Session query request.\");\n                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n            }\n        });\n    };\n    qq.Scaler = function(spec, log) {\n        \"use strict\";\n        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n        qq.extend(this, {\n            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n                if (identifier.isPreviewableSync()) {\n                    qq.each(sizes, function(idx, sizeRecord) {\n                        var outputType = self._determineOutputType({\n                            defaultType: defaultType,\n                            requestedType: sizeRecord.type,\n                            refType: originalBlob.type\n                        });\n                        records.push({\n                            uuid: qq.getUniqueId(),\n                            name: self._getName(originalFileName, {\n                                name: sizeRecord.name,\n                                type: outputType,\n                                refType: originalBlob.type\n                            }),\n                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                                customResizeFunction: customResizeFunction,\n                                maxSize: sizeRecord.maxSize,\n                                orient: orient,\n                                type: outputType,\n                                quality: defaultQuality,\n                                failedText: failedToScaleText,\n                                includeExif: includeExif,\n                                log: log\n                            }))\n                        });\n                    });\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: includeOriginal ? originalBlob : null\n                    });\n                } else {\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: originalBlob\n                    });\n                }\n                return records;\n            },\n            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                    var blobSize = record.size, id;\n                    if (record.blob instanceof qq.BlobProxy) {\n                        blobSize = -1;\n                    }\n                    id = uploadData.addFile({\n                        uuid: record.uuid,\n                        name: record.name,\n                        size: blobSize,\n                        batchId: batchId,\n                        proxyGroupId: proxyGroupId\n                    });\n                    if (record.blob instanceof qq.BlobProxy) {\n                        scaledIds.push(id);\n                    } else {\n                        originalId = id;\n                    }\n                    if (record.blob) {\n                        addFileToHandler(id, record.blob);\n                        fileList.push({\n                            id: id,\n                            file: record.blob\n                        });\n                    } else {\n                        uploadData.setStatus(id, qq.status.REJECTED);\n                    }\n                });\n                if (originalId !== null) {\n                    qq.each(scaledIds, function(idx, scaledId) {\n                        var params = {\n                            qqparentuuid: uploadData.retrieve({\n                                id: originalId\n                            }).uuid,\n                            qqparentsize: uploadData.retrieve({\n                                id: originalId\n                            }).size\n                        };\n                        params[uuidParamName] = uploadData.retrieve({\n                            id: scaledId\n                        }).uuid;\n                        uploadData.setParentId(scaledId, originalId);\n                        paramsStore.addReadOnly(scaledId, params);\n                    });\n                    if (scaledIds.length) {\n                        (function() {\n                            var param = {};\n                            param[uuidParamName] = uploadData.retrieve({\n                                id: originalId\n                            }).uuid;\n                            paramsStore.addReadOnly(originalId, param);\n                        })();\n                    }\n                }\n            }\n        });\n    };\n    qq.extend(qq.Scaler.prototype, {\n        scaleImage: function(id, specs, api) {\n            \"use strict\";\n            if (!qq.supportedFeatures.scaling) {\n                throw new qq.Error(\"Scaling is not supported in this browser!\");\n            }\n            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n                id: id\n            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [ {\n                    name: \"\",\n                    maxSize: specs.maxSize\n                } ]\n            }, scaler = new qq.Scaler(scalingOptions, log);\n            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n                scalingEffort.failure();\n                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n            } else {\n                qq.bind(function() {\n                    var record = scaler.getFileRecords(uuid, name, file)[0];\n                    if (record && record.blob instanceof qq.BlobProxy) {\n                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                    } else {\n                        log(id + \" is not a scalable image!\", \"error\");\n                        scalingEffort.failure();\n                    }\n                }, this)();\n            }\n            return scalingEffort;\n        },\n        _determineOutputType: function(spec) {\n            \"use strict\";\n            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n            if (!defaultType && !requestedType) {\n                if (referenceType !== \"image/jpeg\") {\n                    return \"image/png\";\n                }\n                return referenceType;\n            }\n            if (!requestedType) {\n                return defaultType;\n            }\n            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n                if (requestedType === \"image/tiff\") {\n                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n                }\n                return requestedType;\n            }\n            return defaultType;\n        },\n        _getName: function(originalName, scaledVersionProperties) {\n            \"use strict\";\n            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n            }\n            if (startOfExt >= 0) {\n                scaledName = originalName.substr(0, startOfExt);\n                if (referenceType !== versionType) {\n                    scaledExt = versionType.split(\"/\")[1];\n                }\n                scaledName += nameAppendage + \".\" + scaledExt;\n            } else {\n                scaledName = originalName + nameAppendage;\n            }\n            return scaledName;\n        },\n        _getSortedSizes: function(sizes) {\n            \"use strict\";\n            sizes = qq.extend([], sizes);\n            return sizes.sort(function(a, b) {\n                if (a.maxSize > b.maxSize) {\n                    return 1;\n                }\n                if (a.maxSize < b.maxSize) {\n                    return -1;\n                }\n                return 0;\n            });\n        },\n        _generateScaledImage: function(spec, sourceFile) {\n            \"use strict\";\n            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n            imageGenerator.generate(sourceFile, canvas, {\n                maxSize: maxSize,\n                orient: orient,\n                customResizeFunction: customResizeFunction\n            }).then(function() {\n                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n                if (includeExif) {\n                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                        scaledImageDataUri = scaledImageDataUriWithExif;\n                        signalSuccess();\n                    }, function() {\n                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                        signalSuccess();\n                    });\n                } else {\n                    signalSuccess();\n                }\n            }, function() {\n                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n                scalingEffort.failure(failedText);\n            });\n            return scalingEffort;\n        },\n        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n            \"use strict\";\n            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n            reader.onload = function() {\n                originalImageDataUri = reader.result;\n                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n            };\n            reader.onerror = function() {\n                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n                insertionEffort.failure();\n            };\n            reader.readAsDataURL(originalImage);\n            return insertionEffort;\n        },\n        _dataUriToBlob: function(dataUri) {\n            \"use strict\";\n            var byteString, mimeString, arrayBuffer, intArray;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return this._createBlob(arrayBuffer, mimeString);\n        },\n        _createBlob: function(data, mime) {\n            \"use strict\";\n            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n            if (blobBuilder) {\n                blobBuilder.append(data);\n                return blobBuilder.getBlob(mime);\n            } else {\n                return new Blob([ data ], {\n                    type: mime\n                });\n            }\n        }\n    });\n    qq.ExifRestorer = function() {\n        var ExifRestorer = {};\n        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n        ExifRestorer.encode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n            do {\n                chr1 = input[i++];\n                chr2 = input[i++];\n                chr3 = input[i++];\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return output;\n        };\n        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n            var expectedBase64Header = \"data:image/jpeg;base64,\";\n            if (!origFileBase64.match(expectedBase64Header)) {\n                return resizedFileBase64;\n            }\n            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n            var segments = this.slice2Segments(rawImage);\n            var image = this.exifManipulation(resizedFileBase64, segments);\n            return expectedBase64Header + this.encode64(image);\n        };\n        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n            return aBuffer;\n        };\n        ExifRestorer.getExifArray = function(segments) {\n            var seg;\n            for (var x = 0; x < segments.length; x++) {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) {\n                    return seg;\n                }\n            }\n            return [];\n        };\n        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n            return array;\n        };\n        ExifRestorer.slice2Segments = function(rawImageArray) {\n            var head = 0, segments = [];\n            while (1) {\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n                    break;\n                }\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n                    head += 2;\n                } else {\n                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n                    segments.push(seg);\n                    head = endPoint;\n                }\n                if (head > rawImageArray.length) {\n                    break;\n                }\n            }\n            return segments;\n        };\n        ExifRestorer.decode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n            if (base64test.exec(input)) {\n                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n            }\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n            do {\n                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n                chr1 = enc1 << 2 | enc2 >> 4;\n                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n                chr3 = (enc3 & 3) << 6 | enc4;\n                buf.push(chr1);\n                if (enc3 != 64) {\n                    buf.push(chr2);\n                }\n                if (enc4 != 64) {\n                    buf.push(chr3);\n                }\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return buf;\n        };\n        return ExifRestorer;\n    }();\n    qq.TotalProgress = function(callback, getSize) {\n        \"use strict\";\n        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        }, noRetryableFiles = function(failed, retryable) {\n            var none = true;\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n            return none;\n        }, onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        }, onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        }, onNew = function(id) {\n            var size = getSize(id);\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {\n                    loaded: 0,\n                    total: size\n                };\n            }\n        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            } else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n            callbackProxy(totalLoaded, totalSize);\n        };\n        qq.extend(this, {\n            onAllComplete: onAllComplete,\n            onStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                    onCancel(id);\n                } else if (newStatus === qq.status.SUBMITTING) {\n                    onNew(id);\n                }\n            },\n            onIndividualProgress: function(id, loaded, total) {\n                updateTotalProgress(id, loaded, total);\n                perFileProgress[id] = {\n                    loaded: loaded,\n                    total: total\n                };\n            },\n            onNewSize: function(id) {\n                onNew(id);\n            },\n            reset: function() {\n                perFileProgress = {};\n                totalLoaded = 0;\n                totalSize = 0;\n            }\n        });\n    };\n    qq.PasteSupport = function(o) {\n        \"use strict\";\n        var options, detachPasteHandler;\n        options = {\n            targetElement: null,\n            callbacks: {\n                log: function(message, level) {},\n                pasteReceived: function(blob) {}\n            }\n        };\n        function isImage(item) {\n            return item.type && item.type.indexOf(\"image/\") === 0;\n        }\n        function registerPasteHandler() {\n            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n                var clipboardData = event.clipboardData;\n                if (clipboardData) {\n                    qq.each(clipboardData.items, function(idx, item) {\n                        if (isImage(item)) {\n                            var blob = item.getAsFile();\n                            options.callbacks.pasteReceived(blob);\n                        }\n                    });\n                }\n            });\n        }\n        function unregisterPasteHandler() {\n            if (detachPasteHandler) {\n                detachPasteHandler();\n            }\n        }\n        qq.extend(options, o);\n        registerPasteHandler();\n        qq.extend(this, {\n            reset: function() {\n                unregisterPasteHandler();\n            }\n        });\n    };\n    qq.FormSupport = function(options, startUpload, log) {\n        \"use strict\";\n        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n        qq.extend(this, {\n            newEndpoint: null,\n            newAutoUpload: autoUpload,\n            attachedToForm: false,\n            getFormInputsAsObject: function() {\n                if (formEl == null) {\n                    return null;\n                }\n                return self._form2Obj(formEl);\n            }\n        });\n        function determineNewEndpoint(formEl) {\n            if (formEl.getAttribute(\"action\")) {\n                self.newEndpoint = formEl.getAttribute(\"action\");\n            }\n        }\n        function validateForm(formEl, nativeSubmit) {\n            if (formEl.checkValidity && !formEl.checkValidity()) {\n                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n                nativeSubmit();\n            } else {\n                return true;\n            }\n        }\n        function maybeUploadOnSubmit(formEl) {\n            var nativeSubmit = formEl.submit;\n            qq(formEl).attach(\"submit\", function(event) {\n                event = event || window.event;\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n                validateForm(formEl, nativeSubmit) && startUpload();\n            });\n            formEl.submit = function() {\n                validateForm(formEl, nativeSubmit) && startUpload();\n            };\n        }\n        function determineFormEl(formEl) {\n            if (formEl) {\n                if (qq.isString(formEl)) {\n                    formEl = document.getElementById(formEl);\n                }\n                if (formEl) {\n                    log(\"Attaching to form element.\");\n                    determineNewEndpoint(formEl);\n                    interceptSubmit && maybeUploadOnSubmit(formEl);\n                }\n            }\n            return formEl;\n        }\n        formEl = determineFormEl(formEl);\n        this.attachedToForm = !!formEl;\n    };\n    qq.extend(qq.FormSupport.prototype, {\n        _form2Obj: function(form) {\n            \"use strict\";\n            var obj = {}, notIrrelevantType = function(type) {\n                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            }, radioOrCheckbox = function(type) {\n                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n            }, ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            }, selectValue = function(select) {\n                var value = null;\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n                return value;\n            };\n            qq.each(form.elements, function(idx, el) {\n                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n                    obj[el.name] = el.value;\n                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                    var value = selectValue(el);\n                    if (value !== null) {\n                        obj[el.name] = value;\n                    }\n                }\n            });\n            return obj;\n        }\n    });\n    qq.traditional = qq.traditional || {};\n    qq.traditional.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log;\n        function getIframeContentJson(id, iframe) {\n            var response, doc, innerHtml;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                log(\"converting iframe's innerHTML to JSON\");\n                log(\"innerHTML = \" + innerHtml);\n                if (innerHtml && innerHtml.match(/^<pre/i)) {\n                    innerHtml = doc.body.firstChild.firstChild.nodeValue;\n                }\n                response = handler._parseJsonResponse(innerHtml);\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n                response = {\n                    success: false\n                };\n            }\n            return response;\n        }\n        function createForm(id, iframe) {\n            var params = options.paramsStore.get(id), method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\", endpoint = options.endpointStore.get(id), name = getName(id);\n            params[options.uuidName] = getUuid(id);\n            params[options.filenameParam] = name;\n            return handler._initFormForUpload({\n                method: method,\n                endpoint: endpoint,\n                params: params,\n                paramsInBody: options.paramsInBody,\n                targetName: iframe.name\n            });\n        }\n        this.uploadFile = function(id) {\n            var input = handler.getInput(id), iframe = handler._createIframe(id), promise = new qq.Promise(), form;\n            form = createForm(id, iframe);\n            form.appendChild(input);\n            handler._attachLoadEvent(iframe, function(responseFromMessage) {\n                log(\"iframe loaded\");\n                var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n                handler._detachLoadEvent(id);\n                if (!options.cors.expected) {\n                    qq(iframe).remove();\n                }\n                if (response.success) {\n                    promise.success(response);\n                } else {\n                    promise.failure(response);\n                }\n            });\n            log(\"Sending upload request for \" + id);\n            form.submit();\n            qq(form).remove();\n            return promise;\n        };\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: options.cors.expected,\n                inputName: options.inputName\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n    };\n    qq.traditional = qq.traditional || {};\n    qq.traditional.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, log = proxy.log, multipart = spec.forceMultipart || spec.paramsInBody, addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id), name = getName(id);\n            if (!spec.omitDefaultParams) {\n                params[spec.chunking.paramNames.partIndex] = chunkData.part;\n                params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n                params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n                params[spec.chunking.paramNames.totalParts] = chunkData.count;\n                params[spec.totalFileSizeName] = size;\n            }\n            if (multipart && !spec.omitDefaultParams) {\n                params[spec.filenameParam] = name;\n            }\n        }, allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            headers: spec.chunking.success.headers,\n            jsonPayload: spec.chunking.success.jsonPayload,\n            log: log,\n            method: spec.chunking.success.method,\n            params: spec.chunking.success.params\n        }), createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    } else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n            return promise;\n        }, getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id), name = getName(id), size = getSize(id);\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n            return params;\n        }, isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([ 200, 201, 202, 203, 204 ], xhr.status) < 0 || spec.requireSuccessJson && !response.success || response.reset;\n        }, onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n            response = parseResponse(true, xhr);\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        }, parseResponse = function(upload, xhr) {\n            var response = {};\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            } catch (error) {\n                upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n            return response;\n        }, sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n            allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function(xhr) {\n                promise.success(parseResponse(false, xhr), xhr);\n            }, function(xhr) {\n                promise.failure(parseResponse(false, xhr), xhr);\n            });\n            return promise;\n        }, setParamsAndGetEntityToSend = function(entityToSendParams) {\n            var fileOrBlob = entityToSendParams.fileOrBlob;\n            var id = entityToSendParams.id;\n            var xhr = entityToSendParams.xhr;\n            var xhrOverrides = entityToSendParams.xhrOverrides || {};\n            var customParams = entityToSendParams.customParams || {};\n            var defaultParams = entityToSendParams.params || {};\n            var xhrOverrideParams = xhrOverrides.params || {};\n            var params;\n            var formData = multipart ? new FormData() : null, method = xhrOverrides.method || spec.method, endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id), name = getName(id), size = getSize(id);\n            if (spec.omitDefaultParams) {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n            } else {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n                qq.extend(params, defaultParams);\n                params[spec.uuidName] = getUuid(id);\n                params[spec.filenameParam] = name;\n                if (multipart) {\n                    params[spec.totalFileSizeName] = size;\n                } else if (!spec.paramsInBody) {\n                    params[spec.inputName] = name;\n                }\n            }\n            if (!spec.paramsInBody) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            xhr.open(method, endpoint, true);\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n            return fileOrBlob;\n        }, setUploadHeaders = function(headersOptions) {\n            var headerOverrides = headersOptions.headerOverrides;\n            var id = headersOptions.id;\n            var xhr = headersOptions.xhr;\n            if (headerOverrides) {\n                qq.each(headerOverrides, function(headerName, headerValue) {\n                    xhr.setRequestHeader(headerName, headerValue);\n                });\n            } else {\n                var extraHeaders = spec.customHeaders.get(id), fileOrBlob = handler.getFile(id);\n                xhr.setRequestHeader(\"Accept\", \"application/json\");\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                if (!multipart) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                    xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n                }\n                qq.each(extraHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        };\n        qq.extend(this, {\n            uploadChunk: function(uploadChunkParams) {\n                var id = uploadChunkParams.id;\n                var chunkIdx = uploadChunkParams.chunkIdx;\n                var overrides = uploadChunkParams.overrides || {};\n                var resuming = uploadChunkParams.resuming;\n                var chunkData = handler._getChunkData(id, chunkIdx), xhr = handler._createXhr(id, chunkIdx), promise, toSend, customParams, params = {};\n                promise = createReadyStateChangedHandler(id, xhr);\n                handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                customParams = spec.paramsStore.get(id);\n                addChunkingSpecificParams(id, params, chunkData);\n                if (resuming) {\n                    params[spec.resume.paramNames.resuming] = true;\n                }\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: chunkData.blob,\n                    id: id,\n                    customParams: customParams,\n                    params: params,\n                    xhr: xhr,\n                    xhrOverrides: overrides\n                });\n                setUploadHeaders({\n                    headerOverrides: overrides.headers,\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            },\n            uploadFile: function(id) {\n                var fileOrBlob = handler.getFile(id), promise, xhr, customParams, toSend;\n                xhr = handler._createXhr(id);\n                handler._registerProgressHandler(id);\n                promise = createReadyStateChangedHandler(id, xhr);\n                customParams = spec.paramsStore.get(id);\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: fileOrBlob,\n                    id: id,\n                    customParams: customParams,\n                    xhr: xhr\n                });\n                setUploadHeaders({\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            }\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"traditional\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                finalizeChunks: function(id) {\n                    proxy.onFinalizing(id);\n                    if (spec.chunking.success.endpoint) {\n                        return sendChunksCompleteRequest(id);\n                    } else {\n                        return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                    }\n                }\n            };\n        });\n    };\n    qq.traditional.AllChunksDoneAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {},\n            method: \"POST\"\n        }, promises = {}, endpointHandler = {\n            get: function(id) {\n                if (qq.isFunction(options.endpoint)) {\n                    return options.endpoint(id);\n                }\n                return options.endpoint;\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n            validMethods: [ options.method ],\n            method: options.method,\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: options.cors,\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure(xhr);\n                } else {\n                    promise.success(xhr);\n                }\n            }\n        }));\n        qq.extend(this, {\n            complete: function(id, xhr, params, headers) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting All Chunks Done request for \" + id);\n                promises[id] = promise;\n                requester.initTransport(id).withParams(options.params(id) || params).withHeaders(options.headers(id) || headers).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.DragAndDrop = function(o) {\n        \"use strict\";\n        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n        options = {\n            dropZoneElements: [],\n            allowMultipleItems: true,\n            classes: {\n                dropActive: null\n            },\n            callbacks: new qq.DragAndDrop.callbacks()\n        };\n        qq.extend(options, o, true);\n        function uploadDroppedFiles(files, uploadDropZone) {\n            var filesAsArray = Array.prototype.slice.call(files);\n            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n            uploadDropZone.dropDisabled(false);\n            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n        }\n        function traverseFileTree(entry) {\n            var parseEntryPromise = new qq.Promise();\n            if (entry.isFile) {\n                entry.file(function(file) {\n                    file.qqPath = extractDirectoryPath(entry);\n                    droppedFiles.push(file);\n                    parseEntryPromise.success();\n                }, function(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            } else if (entry.isDirectory) {\n                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n                    var entriesLeft = entries.length;\n                    qq.each(entries, function(idx, entry) {\n                        traverseFileTree(entry).done(function() {\n                            entriesLeft -= 1;\n                            if (entriesLeft === 0) {\n                                parseEntryPromise.success();\n                            }\n                        });\n                    });\n                    if (!entries.length) {\n                        parseEntryPromise.success();\n                    }\n                }, function readFailure(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            }\n            return parseEntryPromise;\n        }\n        function extractDirectoryPath(entry) {\n            var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.lastIndexOf(name);\n            fullPath = fullPath.substr(0, indexOfNameInFullPath);\n            if (fullPath.charAt(0) === \"/\") {\n                fullPath = fullPath.substr(1);\n            }\n            return fullPath;\n        }\n        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n            dirReader.readEntries(function readSuccess(entries) {\n                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n                if (entries.length) {\n                    setTimeout(function() {\n                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n                    }, 0);\n                } else {\n                    promise.success(newEntries);\n                }\n            }, promise.failure);\n            return promise;\n        }\n        function handleDataTransfer(dataTransfer, uploadDropZone) {\n            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n            options.callbacks.processingDroppedFiles();\n            uploadDropZone.dropDisabled(true);\n            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n                options.callbacks.processingDroppedFilesComplete([]);\n                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n                uploadDropZone.dropDisabled(false);\n                handleDataTransferPromise.failure();\n            } else {\n                droppedFiles = [];\n                if (qq.isFolderDropSupported(dataTransfer)) {\n                    qq.each(dataTransfer.items, function(idx, item) {\n                        var entry = item.webkitGetAsEntry();\n                        if (entry) {\n                            if (entry.isFile) {\n                                droppedFiles.push(item.getAsFile());\n                            } else {\n                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n                                    pendingFolderPromises.pop();\n                                    if (pendingFolderPromises.length === 0) {\n                                        handleDataTransferPromise.success();\n                                    }\n                                }));\n                            }\n                        }\n                    });\n                } else {\n                    droppedFiles = dataTransfer.files;\n                }\n                if (pendingFolderPromises.length === 0) {\n                    handleDataTransferPromise.success();\n                }\n            }\n            return handleDataTransferPromise;\n        }\n        function setupDropzone(dropArea) {\n            var dropZone = new qq.UploadDropZone({\n                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n                element: dropArea,\n                onEnter: function(e) {\n                    qq(dropArea).addClass(options.classes.dropActive);\n                    e.stopPropagation();\n                },\n                onLeaveNotDescendants: function(e) {\n                    qq(dropArea).removeClass(options.classes.dropActive);\n                },\n                onDrop: function(e) {\n                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n                        uploadDroppedFiles(droppedFiles, dropZone);\n                    }, function() {\n                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n                    });\n                }\n            });\n            disposeSupport.addDisposer(function() {\n                dropZone.dispose();\n            });\n            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n            uploadDropZones.push(dropZone);\n            return dropZone;\n        }\n        function isFileDrag(dragEvent) {\n            var fileDrag;\n            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n                if (val === \"Files\") {\n                    fileDrag = true;\n                    return false;\n                }\n            });\n            return fileDrag;\n        }\n        function leavingDocumentOut(e) {\n            if (qq.safari()) {\n                return e.x < 0 || e.y < 0;\n            }\n            return e.x === 0 && e.y === 0;\n        }\n        function setupDragDrop() {\n            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n                setTimeout(function() {\n                    qq.each(dropZones, function(idx, dropZone) {\n                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n                        qq(dropZone).removeClass(options.classes.dropActive);\n                    });\n                }, 10);\n            };\n            qq.each(dropZones, function(idx, dropZone) {\n                var uploadDropZone = setupDropzone(dropZone);\n                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n                    disposeSupport.attach(document, \"dragenter\", function(e) {\n                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n                            qq.each(dropZones, function(idx, dropZone) {\n                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n                                    qq(dropZone).css({\n                                        display: \"block\"\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            disposeSupport.attach(document, \"dragleave\", function(e) {\n                if (leavingDocumentOut(e)) {\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, \"drop\", function(e) {\n                if (isFileDrag(e)) {\n                    e.preventDefault();\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n        }\n        setupDragDrop();\n        qq.extend(this, {\n            setupExtraDropzone: function(element) {\n                options.dropZoneElements.push(element);\n                setupDropzone(element);\n            },\n            removeDropzone: function(element) {\n                var i, dzs = options.dropZoneElements;\n                for (i in dzs) {\n                    if (dzs[i] === element) {\n                        return dzs.splice(i, 1);\n                    }\n                }\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n                qq.each(uploadDropZones, function(idx, dropZone) {\n                    dropZone.dispose();\n                });\n            }\n        });\n        this._testing = {};\n        this._testing.extractDirectoryPath = extractDirectoryPath;\n    };\n    qq.DragAndDrop.callbacks = function() {\n        \"use strict\";\n        return {\n            processingDroppedFiles: function() {},\n            processingDroppedFilesComplete: function(files, targetEl) {},\n            dropError: function(code, errorSpecifics) {\n                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n            },\n            dropLog: function(message, level) {\n                qq.log(message, level);\n            }\n        };\n    };\n    qq.UploadDropZone = function(o) {\n        \"use strict\";\n        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n        options = {\n            element: null,\n            onEnter: function(e) {},\n            onLeave: function(e) {},\n            onLeaveNotDescendants: function(e) {},\n            onDrop: function(e) {}\n        };\n        qq.extend(options, o);\n        element = options.element;\n        function dragoverShouldBeCanceled() {\n            return qq.safari() || qq.firefox() && qq.windows();\n        }\n        function disableDropOutside(e) {\n            if (!dropOutsideDisabled) {\n                if (dragoverShouldBeCanceled) {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        if (e.dataTransfer) {\n                            e.dataTransfer.dropEffect = \"none\";\n                            e.preventDefault();\n                        }\n                    });\n                }\n                dropOutsideDisabled = true;\n            }\n        }\n        function isValidFileDrag(e) {\n            if (!qq.supportedFeatures.fileDrop) {\n                return false;\n            }\n            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n            return dt && effectTest && (dt.files && dt.files.length || !isSafari && dt.types.contains && dt.types.contains(\"Files\") || dt.types.includes && dt.types.includes(\"Files\"));\n        }\n        function isOrSetDropDisabled(isDisabled) {\n            if (isDisabled !== undefined) {\n                preventDrop = isDisabled;\n            }\n            return preventDrop;\n        }\n        function triggerHidezonesEvent() {\n            var hideZonesEvent;\n            function triggerUsingOldApi() {\n                hideZonesEvent = document.createEvent(\"Event\");\n                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n            }\n            if (window.CustomEvent) {\n                try {\n                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n                } catch (err) {\n                    triggerUsingOldApi();\n                }\n            } else {\n                triggerUsingOldApi();\n            }\n            document.dispatchEvent(hideZonesEvent);\n        }\n        function attachEvents() {\n            disposeSupport.attach(element, \"dragover\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n                if (effect === \"move\" || effect === \"linkMove\") {\n                    e.dataTransfer.dropEffect = \"move\";\n                } else {\n                    e.dataTransfer.dropEffect = \"copy\";\n                }\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            disposeSupport.attach(element, \"dragenter\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    options.onEnter(e);\n                }\n            });\n            disposeSupport.attach(element, \"dragleave\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                options.onLeave(e);\n                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n                if (qq(this).contains(relatedTarget)) {\n                    return;\n                }\n                options.onLeaveNotDescendants(e);\n            });\n            disposeSupport.attach(element, \"drop\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    options.onDrop(e);\n                    triggerHidezonesEvent();\n                }\n            });\n        }\n        disableDropOutside();\n        attachEvents();\n        qq.extend(this, {\n            dropDisabled: function(isDisabled) {\n                return isOrSetDropDisabled(isDisabled);\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n            },\n            getElement: function() {\n                return element;\n            }\n        });\n        this._testing = {};\n        this._testing.isValidFileDrag = isValidFileDrag;\n    };\n    (function() {\n        \"use strict\";\n        qq.uiPublicApi = {\n            addInitialFiles: function(cannedFileList) {\n                this._parent.prototype.addInitialFiles.apply(this, arguments);\n                this._templating.addCacheToDom();\n            },\n            clearStoredFiles: function() {\n                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n                this._templating.clearFiles();\n            },\n            addExtraDropzone: function(element) {\n                this._dnd && this._dnd.setupExtraDropzone(element);\n            },\n            removeExtraDropzone: function(element) {\n                if (this._dnd) {\n                    return this._dnd.removeDropzone(element);\n                }\n            },\n            getItemByFileId: function(id) {\n                if (!this._templating.isHiddenForever(id)) {\n                    return this._templating.getFileContainer(id);\n                }\n            },\n            reset: function() {\n                this._parent.prototype.reset.apply(this, arguments);\n                this._templating.reset();\n                if (!this._options.button && this._templating.getButton()) {\n                    this._defaultButtonId = this._createUploadButton({\n                        element: this._templating.getButton(),\n                        title: this._options.text.fileInputTitle\n                    }).getButtonId();\n                }\n                if (this._dnd) {\n                    this._dnd.dispose();\n                    this._dnd = this._setupDragAndDrop();\n                }\n                this._totalFilesInBatch = 0;\n                this._filesInBatchAddedToUi = 0;\n                this._setupClickAndEditEventHandlers();\n            },\n            setName: function(id, newName) {\n                var formattedFilename = this._options.formatFileName(newName);\n                this._parent.prototype.setName.apply(this, arguments);\n                this._templating.updateFilename(id, formattedFilename);\n            },\n            pauseUpload: function(id) {\n                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n                paused && this._templating.uploadPaused(id);\n                return paused;\n            },\n            continueUpload: function(id) {\n                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n                continued && this._templating.uploadContinued(id);\n                return continued;\n            },\n            getId: function(fileContainerOrChildEl) {\n                return this._templating.getFileId(fileContainerOrChildEl);\n            },\n            getDropTarget: function(fileId) {\n                var file = this.getFile(fileId);\n                return file.qqDropTarget;\n            }\n        };\n        qq.uiPrivateApi = {\n            _getButton: function(buttonId) {\n                var button = this._parent.prototype._getButton.apply(this, arguments);\n                if (!button) {\n                    if (buttonId === this._defaultButtonId) {\n                        button = this._templating.getButton();\n                    }\n                }\n                return button;\n            },\n            _removeFileItem: function(fileId) {\n                this._templating.removeFile(fileId);\n            },\n            _setupClickAndEditEventHandlers: function() {\n                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n                this._focusinEventSupported = !qq.firefox();\n                if (this._isEditFilenameEnabled()) {\n                    this._filenameClickHandler = this._bindFilenameClickEvent();\n                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n                }\n            },\n            _setupDragAndDrop: function() {\n                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n                defaultDropZone && dropZoneElements.push(defaultDropZone);\n                return new qq.DragAndDrop({\n                    dropZoneElements: dropZoneElements,\n                    allowMultipleItems: this._options.multiple,\n                    classes: {\n                        dropActive: this._options.classes.dropActive\n                    },\n                    callbacks: {\n                        processingDroppedFiles: function() {\n                            templating.showDropProcessing();\n                        },\n                        processingDroppedFilesComplete: function(files, targetEl) {\n                            templating.hideDropProcessing();\n                            qq.each(files, function(idx, file) {\n                                file.qqDropTarget = targetEl;\n                            });\n                            if (files.length) {\n                                self.addFiles(files, null, null);\n                            }\n                        },\n                        dropError: function(code, errorData) {\n                            self._itemError(code, errorData);\n                        },\n                        dropLog: function(message, level) {\n                            self.log(message, level);\n                        }\n                    }\n                });\n            },\n            _bindFileButtonsClickEvent: function() {\n                var self = this;\n                return new qq.FileButtonsClickHandler({\n                    templating: this._templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onDeleteFile: function(fileId) {\n                        self.deleteFile(fileId);\n                    },\n                    onCancel: function(fileId) {\n                        self.cancel(fileId);\n                    },\n                    onRetry: function(fileId) {\n                        self.retry(fileId);\n                    },\n                    onPause: function(fileId) {\n                        self.pauseUpload(fileId);\n                    },\n                    onContinue: function(fileId) {\n                        self.continueUpload(fileId);\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    }\n                });\n            },\n            _isEditFilenameEnabled: function() {\n                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n            },\n            _filenameEditHandler: function() {\n                var self = this, templating = this._templating;\n                return {\n                    templating: templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onGetUploadStatus: function(fileId) {\n                        return self.getUploads({\n                            id: fileId\n                        }).status;\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    },\n                    onSetName: function(id, newName) {\n                        self.setName(id, newName);\n                    },\n                    onEditingStatusChange: function(id, isEditing) {\n                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n                        if (isEditing) {\n                            qqInput.addClass(\"qq-editing\");\n                            templating.hideFilename(id);\n                            templating.hideEditIcon(id);\n                        } else {\n                            qqInput.removeClass(\"qq-editing\");\n                            templating.showFilename(id);\n                            templating.showEditIcon(id);\n                        }\n                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n                    }\n                };\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n                if (this._isEditFilenameEnabled()) {\n                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n                        this._templating.markFilenameEditable(id);\n                        this._templating.hideEditIcon(id);\n                    }\n                }\n                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n                    this._templating.hideRetry(id);\n                    this._templating.setStatusText(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n                    this._templating.hidePause(id);\n                }\n            },\n            _bindFilenameInputFocusInEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusInHandler(spec);\n            },\n            _bindFilenameInputFocusEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusHandler(spec);\n            },\n            _bindFilenameClickEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameClickHandler(spec);\n            },\n            _storeForLater: function(id) {\n                this._parent.prototype._storeForLater.apply(this, arguments);\n                this._templating.hideSpinner(id);\n            },\n            _onAllComplete: function(successful, failed) {\n                this._parent.prototype._onAllComplete.apply(this, arguments);\n                this._templating.resetTotalProgress();\n            },\n            _onSubmit: function(id, name) {\n                var file = this.getFile(id);\n                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n                    this._paramsStore.addReadOnly(id, {\n                        qqpath: file.qqPath\n                    });\n                }\n                this._parent.prototype._onSubmit.apply(this, arguments);\n                this._addToList(id, name);\n            },\n            _onSubmitted: function(id) {\n                if (this._isEditFilenameEnabled()) {\n                    this._templating.markFilenameEditable(id);\n                    this._templating.showEditIcon(id);\n                    if (!this._focusinEventSupported) {\n                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                    }\n                }\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._parent.prototype._onProgress.apply(this, arguments);\n                this._templating.updateProgress(id, loaded, total);\n                if (total === 0 || Math.round(loaded / total * 100) === 100) {\n                    this._templating.hideCancel(id);\n                    this._templating.hidePause(id);\n                    this._templating.hideProgress(id);\n                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n                    this._displayFileSize(id);\n                } else {\n                    this._displayFileSize(id, loaded, total);\n                }\n            },\n            _onTotalProgress: function(loaded, total) {\n                this._parent.prototype._onTotalProgress.apply(this, arguments);\n                this._templating.updateTotalProgress(loaded, total);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n                function completeUpload(result) {\n                    if (!fileContainer) {\n                        return;\n                    }\n                    templating.setStatusText(id);\n                    qq(fileContainer).removeClass(self._classes.retrying);\n                    templating.hideProgress(id);\n                    if (self.getUploads({\n                        id: id\n                    }).status !== qq.status.UPLOAD_FAILED) {\n                        templating.hideCancel(id);\n                    }\n                    templating.hideSpinner(id);\n                    if (result.success) {\n                        self._markFileAsSuccessful(id);\n                    } else {\n                        qq(fileContainer).addClass(self._classes.fail);\n                        templating.showCancel(id);\n                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n                            qq(fileContainer).addClass(self._classes.retryable);\n                            templating.showRetry(id);\n                        }\n                        self._controlFailureTextDisplay(id, result);\n                    }\n                }\n                if (parentRetVal instanceof qq.Promise) {\n                    parentRetVal.done(function(newResult) {\n                        completeUpload(newResult);\n                    });\n                } else {\n                    completeUpload(result);\n                }\n                return parentRetVal;\n            },\n            _markFileAsSuccessful: function(id) {\n                var templating = this._templating;\n                if (this._isDeletePossible()) {\n                    templating.showDeleteButton(id);\n                }\n                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n                this._maybeUpdateThumbnail(id);\n            },\n            _onUploadPrep: function(id) {\n                this._parent.prototype._onUploadPrep.apply(this, arguments);\n                this._templating.showSpinner(id);\n            },\n            _onUpload: function(id, name) {\n                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n                this._templating.showSpinner(id);\n                return parentRetVal;\n            },\n            _onUploadChunk: function(id, chunkData) {\n                this._parent.prototype._onUploadChunk.apply(this, arguments);\n                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n                    this._templating.allowPause(id);\n                }\n            },\n            _onCancel: function(id, name) {\n                this._parent.prototype._onCancel.apply(this, arguments);\n                this._removeFileItem(id);\n                if (this._getNotFinished() === 0) {\n                    this._templating.resetTotalProgress();\n                }\n            },\n            _onBeforeAutoRetry: function(id) {\n                var retryNumForDisplay, maxAuto, retryNote;\n                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n                this._showCancelLink(id);\n                if (this._options.retry.showAutoRetryNote) {\n                    retryNumForDisplay = this._autoRetries[id];\n                    maxAuto = this._options.retry.maxAutoAttempts;\n                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n                    this._templating.setStatusText(id, retryNote);\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n                }\n            },\n            _onBeforeManualRetry: function(id) {\n                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n                    this._templating.resetProgress(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n                    this._templating.setStatusText(id);\n                    this._templating.showSpinner(id);\n                    this._showCancelLink(id);\n                    return true;\n                } else {\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n                    this._templating.showRetry(id);\n                    return false;\n                }\n            },\n            _onSubmitDelete: function(id) {\n                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n            },\n            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n                if (this._options.deleteFile.forceConfirm) {\n                    this._showDeleteConfirm.apply(this, arguments);\n                } else {\n                    this._sendDeleteRequest.apply(this, arguments);\n                }\n            },\n            _onDeleteComplete: function(id, xhr, isError) {\n                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n                this._templating.hideSpinner(id);\n                if (isError) {\n                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n                    this._templating.showDeleteButton(id);\n                } else {\n                    this._removeFileItem(id);\n                }\n            },\n            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n                this._templating.hideDeleteButton(id);\n                this._templating.showSpinner(id);\n                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n                this._deleteHandler.sendDelete.apply(this, arguments);\n            },\n            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n                retVal = this._options.showConfirm(confirmMessage);\n                if (qq.isGenericPromise(retVal)) {\n                    retVal.then(function() {\n                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                    });\n                } else if (retVal !== false) {\n                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                }\n            },\n            _addToList: function(id, name, canned) {\n                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n                if (this._options.display.prependFiles) {\n                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n                        prependIndex = this._filesInBatchAddedToUi - 1;\n                    }\n                    prependData = {\n                        index: prependIndex\n                    };\n                }\n                if (!canned) {\n                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n                        this._templating.disableCancel();\n                    }\n                    if (!this._options.multiple) {\n                        record = this.getUploads({\n                            id: id\n                        });\n                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n                            this._handler.cancelAll();\n                            this._clearList();\n                            this._handledProxyGroup = null;\n                        }\n                    }\n                }\n                if (canned) {\n                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n                } else {\n                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n                }\n                this._filesInBatchAddedToUi += 1;\n                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n                    this._displayFileSize(id);\n                }\n            },\n            _clearList: function() {\n                this._templating.clearFiles();\n                this.clearStoredFiles();\n            },\n            _displayFileSize: function(id, loadedSize, totalSize) {\n                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n                if (size >= 0) {\n                    if (loadedSize !== undefined && totalSize !== undefined) {\n                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n                    }\n                    this._templating.updateSize(id, sizeForDisplay);\n                }\n            },\n            _formatProgress: function(uploadedSize, totalSize) {\n                var message = this._options.text.formatProgress;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n                r(\"{total_size}\", this._formatSize(totalSize));\n                return message;\n            },\n            _controlFailureTextDisplay: function(id, response) {\n                var mode, responseProperty, failureReason;\n                mode = this._options.failedUploadTextDisplay.mode;\n                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n                if (mode === \"custom\") {\n                    failureReason = response[responseProperty];\n                    if (!failureReason) {\n                        failureReason = this._options.text.failUpload;\n                    }\n                    this._templating.setStatusText(id, failureReason);\n                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n                        this._showTooltip(id, failureReason);\n                    }\n                } else if (mode === \"default\") {\n                    this._templating.setStatusText(id, this._options.text.failUpload);\n                } else if (mode !== \"none\") {\n                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n                }\n            },\n            _showTooltip: function(id, text) {\n                this._templating.getFileContainer(id).title = text;\n            },\n            _showCancelLink: function(id) {\n                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n                    this._templating.showCancel(id);\n                }\n            },\n            _itemError: function(code, name, item) {\n                var message = this._parent.prototype._itemError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _batchError: function(message) {\n                this._parent.prototype._batchError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _setupPastePrompt: function() {\n                var self = this;\n                this._options.callbacks.onPasteReceived = function() {\n                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n                    return self._options.showPrompt(message, defaultVal);\n                };\n            },\n            _fileOrBlobRejected: function(id, name) {\n                this._totalFilesInBatch -= 1;\n                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                this._totalFilesInBatch = items.length;\n                this._filesInBatchAddedToUi = 0;\n                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n            },\n            _maybeUpdateThumbnail: function(fileId) {\n                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n                    id: fileId\n                }).status;\n                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n                this._addToList(id, this.getName(id), true);\n                this._templating.hideSpinner(id);\n                this._templating.hideCancel(id);\n                this._markFileAsSuccessful(id);\n                return id;\n            },\n            _setSize: function(id, newSize) {\n                this._parent.prototype._setSize.apply(this, arguments);\n                this._templating.updateSize(id, this._formatSize(newSize));\n            },\n            _sessionRequestComplete: function() {\n                this._templating.addCacheToDom();\n                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n            }\n        };\n    })();\n    qq.FineUploader = function(o, namespace) {\n        \"use strict\";\n        var self = this;\n        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n        this._parent.apply(this, arguments);\n        qq.extend(this._options, {\n            element: null,\n            button: null,\n            listElement: null,\n            dragAndDrop: {\n                extraDropzones: [],\n                reportDirectoryPaths: false\n            },\n            text: {\n                formatProgress: \"{percent}% of {total_size}\",\n                failUpload: \"Upload failed\",\n                waitingForResponse: \"Processing...\",\n                paused: \"Paused\"\n            },\n            template: \"qq-template\",\n            classes: {\n                retrying: \"qq-upload-retrying\",\n                retryable: \"qq-upload-retryable\",\n                success: \"qq-upload-success\",\n                fail: \"qq-upload-fail\",\n                editable: \"qq-editable\",\n                hide: \"qq-hide\",\n                dropActive: \"qq-upload-drop-area-active\"\n            },\n            failedUploadTextDisplay: {\n                mode: \"default\",\n                responseProperty: \"error\",\n                enableTooltip: true\n            },\n            messages: {\n                tooManyFilesError: \"You may only drop one file\",\n                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n            },\n            retry: {\n                showAutoRetryNote: true,\n                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n            },\n            deleteFile: {\n                forceConfirm: false,\n                confirmMessage: \"Are you sure you want to delete {filename}?\",\n                deletingStatusText: \"Deleting...\",\n                deletingFailedText: \"Delete failed\"\n            },\n            display: {\n                fileSizeOnSubmit: false,\n                prependFiles: false\n            },\n            paste: {\n                promptForName: false,\n                namePromptMessage: \"Please name this image\"\n            },\n            thumbnails: {\n                customResizer: null,\n                maxCount: 0,\n                placeholders: {\n                    waitUntilResponse: false,\n                    notAvailablePath: null,\n                    waitingPath: null\n                },\n                timeBetweenThumbs: 750\n            },\n            scaling: {\n                hideScaled: false\n            },\n            showMessage: function(message) {\n                if (self._templating.hasDialog(\"alert\")) {\n                    return self._templating.showDialog(\"alert\", message);\n                } else {\n                    setTimeout(function() {\n                        window.alert(message);\n                    }, 0);\n                }\n            },\n            showConfirm: function(message) {\n                if (self._templating.hasDialog(\"confirm\")) {\n                    return self._templating.showDialog(\"confirm\", message);\n                } else {\n                    return window.confirm(message);\n                }\n            },\n            showPrompt: function(message, defaultValue) {\n                if (self._templating.hasDialog(\"prompt\")) {\n                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n                } else {\n                    return window.prompt(message, defaultValue);\n                }\n            }\n        }, true);\n        qq.extend(this._options, o, true);\n        this._templating = new qq.Templating({\n            log: qq.bind(this.log, this),\n            templateIdOrEl: this._options.template,\n            containerEl: this._options.element,\n            fileContainerEl: this._options.listElement,\n            button: this._options.button,\n            imageGenerator: this._imageGenerator,\n            classes: {\n                hide: this._options.classes.hide,\n                editable: this._options.classes.editable\n            },\n            limits: {\n                maxThumbs: this._options.thumbnails.maxCount,\n                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n            },\n            placeholders: {\n                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n            },\n            text: this._options.text\n        });\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n        } else {\n            this._wrapCallbacks();\n            this._templating.render();\n            this._classes = this._options.classes;\n            if (!this._options.button && this._templating.getButton()) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._templating.getButton(),\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._setupClickAndEditEventHandlers();\n            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n                this._dnd = this._setupDragAndDrop();\n            }\n            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n                if (qq.PasteSupport) {\n                    this._setupPastePrompt();\n                } else {\n                    this.log(\"Paste support module not found.\", \"error\");\n                }\n            }\n            this._totalFilesInBatch = 0;\n            this._filesInBatchAddedToUi = 0;\n        }\n    };\n    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n    qq.Templating = function(spec) {\n        \"use strict\";\n        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n            content: document.createDocumentFragment(),\n            map: {}\n        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n            log: null,\n            limits: {\n                maxThumbs: 0,\n                timeBetweenThumbs: 750\n            },\n            templateIdOrEl: \"qq-template\",\n            containerEl: null,\n            fileContainerEl: null,\n            button: null,\n            imageGenerator: null,\n            classes: {\n                hide: \"qq-hide\",\n                editable: \"qq-editable\"\n            },\n            placeholders: {\n                waitUntilUpdate: false,\n                thumbnailNotAvailable: null,\n                waitingForThumbnail: null\n            },\n            text: {\n                paused: \"Paused\"\n            }\n        }, selectorClasses = {\n            button: \"qq-upload-button-selector\",\n            alertDialog: \"qq-alert-dialog-selector\",\n            dialogCancelButton: \"qq-cancel-button-selector\",\n            confirmDialog: \"qq-confirm-dialog-selector\",\n            dialogMessage: \"qq-dialog-message-selector\",\n            dialogOkButton: \"qq-ok-button-selector\",\n            promptDialog: \"qq-prompt-dialog-selector\",\n            uploader: \"qq-uploader-selector\",\n            drop: \"qq-upload-drop-area-selector\",\n            list: \"qq-upload-list-selector\",\n            progressBarContainer: \"qq-progress-bar-container-selector\",\n            progressBar: \"qq-progress-bar-selector\",\n            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n            totalProgressBar: \"qq-total-progress-bar-selector\",\n            file: \"qq-upload-file-selector\",\n            spinner: \"qq-upload-spinner-selector\",\n            size: \"qq-upload-size-selector\",\n            cancel: \"qq-upload-cancel-selector\",\n            pause: \"qq-upload-pause-selector\",\n            continueButton: \"qq-upload-continue-selector\",\n            deleteButton: \"qq-upload-delete-selector\",\n            retry: \"qq-upload-retry-selector\",\n            statusText: \"qq-upload-status-text-selector\",\n            editFilenameInput: \"qq-edit-filename-selector\",\n            editNameIcon: \"qq-edit-filename-icon-selector\",\n            dropText: \"qq-upload-drop-area-text-selector\",\n            dropProcessing: \"qq-drop-processing-selector\",\n            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n            thumbnail: \"qq-thumbnail-selector\"\n        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateDom, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n                maxSize: thumbnailMaxSize,\n                scale: serverScale\n            };\n            if (showThumbnails) {\n                if (notAvailableUrl) {\n                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedThumbnailNotAvailableImg.success(updatedImg);\n                    }, function() {\n                        cachedThumbnailNotAvailableImg.failure();\n                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n                    });\n                } else {\n                    cachedThumbnailNotAvailableImg.failure();\n                }\n                if (waitingUrl) {\n                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedWaitingForThumbnailImg.success(updatedImg);\n                    }, function() {\n                        cachedWaitingForThumbnailImg.failure();\n                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n                    });\n                } else {\n                    cachedWaitingForThumbnailImg.failure();\n                }\n            }\n        }, displayWaitingImg = function(thumbnail) {\n            var waitingImgPlacement = new qq.Promise();\n            cachedWaitingForThumbnailImg.then(function(img) {\n                maybeScalePlaceholderViaCss(img, thumbnail);\n                if (!thumbnail.src) {\n                    thumbnail.src = img.src;\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        show(thumbnail);\n                        waitingImgPlacement.success();\n                    };\n                } else {\n                    waitingImgPlacement.success();\n                }\n            }, function() {\n                hide(thumbnail);\n                waitingImgPlacement.success();\n            });\n            return waitingImgPlacement;\n        }, generateNewPreview = function(id, blob, spec) {\n            var thumbnail = getThumbnail(id);\n            log(\"Generating new thumbnail for \" + id);\n            blob.qqThumbnailId = id;\n            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n                generatedThumbnails++;\n                show(thumbnail);\n                previewGeneration[id].success();\n            }, function() {\n                previewGeneration[id].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                }\n            });\n        }, generateNextQueuedPreview = function() {\n            if (thumbGenerationQueue.length) {\n                thumbnailQueueMonitorRunning = true;\n                var queuedThumbRequest = thumbGenerationQueue.shift();\n                if (queuedThumbRequest.update) {\n                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n                } else {\n                    processNewQueuedPreviewRequest(queuedThumbRequest);\n                }\n            } else {\n                thumbnailQueueMonitorRunning = false;\n            }\n        }, getCancel = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.cancel);\n        }, getContinue = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n        }, getDialog = function(type) {\n            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n        }, getDelete = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n        }, getDropProcessing = function() {\n            return getTemplateEl(container, selectorClasses.dropProcessing);\n        }, getEditIcon = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n        }, getFile = function(id) {\n            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n        }, getFilename = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.file);\n        }, getPause = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.pause);\n        }, getProgress = function(id) {\n            if (id == null) {\n                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n            }\n            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n        }, getRetry = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.retry);\n        }, getSize = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.size);\n        }, getSpinner = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.spinner);\n        }, getTemplateEl = function(context, cssClass) {\n            return context && qq(context).getFirstByClass(cssClass);\n        }, getThumbnail = function(id) {\n            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n        }, hide = function(el) {\n            el && qq(el).addClass(options.classes.hide);\n        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n                qq(thumbnail).css({\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight\n                });\n            }\n        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n            cachedThumbnailNotAvailableImg.then(function(img) {\n                previewing.then(function() {\n                    notAvailableImgPlacement.success();\n                }, function() {\n                    maybeScalePlaceholderViaCss(img, thumbnail);\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        notAvailableImgPlacement.success();\n                    };\n                    thumbnail.src = img.src;\n                    show(thumbnail);\n                });\n            });\n            return notAvailableImgPlacement;\n        }, parseAndGetTemplate = function() {\n            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListEl, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n            log(\"Parsing template\");\n            if (options.templateIdOrEl == null) {\n                throw new Error(\"You MUST specify either a template element or ID!\");\n            }\n            if (qq.isString(options.templateIdOrEl)) {\n                scriptEl = document.getElementById(options.templateIdOrEl);\n                if (scriptEl === null) {\n                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n                }\n                scriptHtml = scriptEl.innerHTML;\n            } else {\n                if (options.templateIdOrEl.innerHTML === undefined) {\n                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n                }\n                scriptHtml = options.templateIdOrEl.innerHTML;\n            }\n            scriptHtml = qq.trimStr(scriptHtml);\n            tempTemplateEl = document.createElement(\"div\");\n            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n            if (options.button) {\n                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n                if (defaultButton) {\n                    qq(defaultButton).remove();\n                }\n            }\n            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n                if (dropProcessing) {\n                    qq(dropProcessing).remove();\n                }\n            }\n            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n            if (dropArea && !qq.DragAndDrop) {\n                log(\"DnD module unavailable.\", \"info\");\n                qq(dropArea).remove();\n            }\n            if (!qq.supportedFeatures.fileDrop) {\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n                    qq(dropArea).css({\n                        display: \"none\"\n                    });\n                }\n            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n                dropTextEl && qq(dropTextEl).remove();\n            }\n            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n            if (!showThumbnails) {\n                thumbnail && qq(thumbnail).remove();\n            } else if (thumbnail) {\n                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n            }\n            showThumbnails = showThumbnails && thumbnail;\n            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n            if (fileListNode == null) {\n                throw new Error(\"Could not find the file list container in the template!\");\n            }\n            fileListEl = fileListNode.children[0].cloneNode(true);\n            fileListNode.innerHTML = \"\";\n            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n                document.createElement(\"dialog\");\n            }\n            log(\"Template parsing complete\");\n            return {\n                template: tempTemplateEl,\n                fileTemplate: fileListEl\n            };\n        }, prependFile = function(el, index, fileList) {\n            var parentEl = fileList, beforeEl = parentEl.firstChild;\n            if (index > 0) {\n                beforeEl = qq(parentEl).children()[index].nextSibling;\n            }\n            parentEl.insertBefore(el, beforeEl);\n        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                maxSize: thumbnailMaxSize,\n                orient: true,\n                scale: true\n            };\n            if (qq.supportedFeatures.imagePreviews) {\n                if (thumbnail) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        displayWaitingImg(thumbnail).done(function() {\n                            previewGeneration[id] = new qq.Promise();\n                            previewGeneration[id].done(function() {\n                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                            });\n                            if (relatedThumbnailId != null) {\n                                useCachedPreview(id, relatedThumbnailId);\n                            } else {\n                                generateNewPreview(id, optFileOrBlob, spec);\n                            }\n                        });\n                    }\n                } else {\n                    generateNextQueuedPreview();\n                }\n            } else if (thumbnail) {\n                displayWaitingImg(thumbnail);\n                generateNextQueuedPreview();\n            }\n        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                scale: serverScale,\n                maxSize: thumbnailMaxSize\n            };\n            if (thumbnail) {\n                if (thumbnailUrl) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        if (showWaitingImg) {\n                            displayWaitingImg(thumbnail);\n                        }\n                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n                            show(thumbnail);\n                            generatedThumbnails++;\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        }, function() {\n                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        });\n                    }\n                } else {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                    generateNextQueuedPreview();\n                }\n            }\n        }, setProgressBarWidth = function(id, percent) {\n            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n                bar = qq(bar).getFirstByClass(progressBarSelector);\n            }\n            if (bar) {\n                qq(bar).css({\n                    width: percent + \"%\"\n                });\n                bar.setAttribute(\"aria-valuenow\", percent);\n            }\n        }, show = function(el) {\n            el && qq(el).removeClass(options.classes.hide);\n        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n            previewGeneration[cachedThumbnailId].then(function() {\n                generatedThumbnails++;\n                previewGeneration[targetThumbnailId].success();\n                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n                targetThumbnail.src = cachedThumbnail.src;\n                show(targetThumbnail);\n            }, function() {\n                previewGeneration[targetThumbnailId].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n                }\n            });\n        };\n        qq.extend(options, spec);\n        log = options.log;\n        if (!qq.supportedFeatures.imagePreviews) {\n            options.limits.timeBetweenThumbs = 0;\n            options.limits.maxThumbs = 0;\n        }\n        container = options.containerEl;\n        showThumbnails = options.imageGenerator !== undefined;\n        templateDom = parseAndGetTemplate();\n        cacheThumbnailPlaceholders();\n        qq.extend(this, {\n            render: function() {\n                log(\"Rendering template in DOM.\");\n                generatedThumbnails = 0;\n                container.appendChild(templateDom.template.cloneNode(true));\n                hide(getDropProcessing());\n                this.hideTotalProgress();\n                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n                log(\"Template rendering complete\");\n            },\n            renderFailure: function(message) {\n                var cantRenderEl = qq.toElement(message);\n                container.innerHTML = \"\";\n                container.appendChild(cantRenderEl);\n            },\n            reset: function() {\n                container.innerHTML = \"\";\n                this.render();\n            },\n            clearFiles: function() {\n                fileList.innerHTML = \"\";\n            },\n            disableCancel: function() {\n                isCancelDisabled = true;\n            },\n            addFile: function(id, name, prependInfo, hideForever, batch) {\n                var fileEl = templateDom.fileTemplate.cloneNode(true), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n                if (batch) {\n                    fileBatch.map[id] = fileEl;\n                }\n                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (fileNameEl) {\n                    qq(fileNameEl).setText(name);\n                    fileNameEl.setAttribute(\"title\", name);\n                }\n                fileEl.setAttribute(FILE_ID_ATTR, id);\n                if (prependInfo) {\n                    prependFile(fileEl, prependInfo.index, fileContainer);\n                } else {\n                    fileContainer.appendChild(fileEl);\n                }\n                if (hideForever) {\n                    fileEl.style.display = \"none\";\n                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n                } else {\n                    hide(getProgress(id));\n                    hide(getSize(id));\n                    hide(getDelete(id));\n                    hide(getRetry(id));\n                    hide(getPause(id));\n                    hide(getContinue(id));\n                    if (isCancelDisabled) {\n                        this.hideCancel(id);\n                    }\n                    thumb = getThumbnail(id);\n                    if (thumb && !thumb.src) {\n                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n                            thumb.src = waitingImg.src;\n                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n                                qq(thumb).css({\n                                    maxHeight: waitingImg.style.maxHeight,\n                                    maxWidth: waitingImg.style.maxWidth\n                                });\n                            }\n                            show(thumb);\n                        });\n                    }\n                }\n            },\n            addFileToCache: function(id, name, prependInfo, hideForever) {\n                this.addFile(id, name, prependInfo, hideForever, true);\n            },\n            addCacheToDom: function() {\n                fileList.appendChild(fileBatch.content);\n                fileBatch.content = document.createDocumentFragment();\n                fileBatch.map = {};\n            },\n            removeFile: function(id) {\n                qq(getFile(id)).remove();\n            },\n            getFileId: function(el) {\n                var currentNode = el;\n                if (currentNode) {\n                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n                        currentNode = currentNode.parentNode;\n                    }\n                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n                }\n            },\n            getFileList: function() {\n                return fileList;\n            },\n            markFilenameEditable: function(id) {\n                var filename = getFilename(id);\n                filename && qq(filename).addClass(options.classes.editable);\n            },\n            updateFilename: function(id, name) {\n                var filenameEl = getFilename(id);\n                if (filenameEl) {\n                    qq(filenameEl).setText(name);\n                    filenameEl.setAttribute(\"title\", name);\n                }\n            },\n            hideFilename: function(id) {\n                hide(getFilename(id));\n            },\n            showFilename: function(id) {\n                show(getFilename(id));\n            },\n            isFileName: function(el) {\n                return qq(el).hasClass(selectorClasses.file);\n            },\n            getButton: function() {\n                return options.button || getTemplateEl(container, selectorClasses.button);\n            },\n            hideDropProcessing: function() {\n                hide(getDropProcessing());\n            },\n            showDropProcessing: function() {\n                show(getDropProcessing());\n            },\n            getDropZone: function() {\n                return getTemplateEl(container, selectorClasses.drop);\n            },\n            isEditFilenamePossible: function() {\n                return isEditElementsExist;\n            },\n            hideRetry: function(id) {\n                hide(getRetry(id));\n            },\n            isRetryPossible: function() {\n                return isRetryElementExist;\n            },\n            showRetry: function(id) {\n                show(getRetry(id));\n            },\n            getFileContainer: function(id) {\n                return getFile(id);\n            },\n            showEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).addClass(options.classes.editable);\n            },\n            isHiddenForever: function(id) {\n                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n            },\n            hideEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).removeClass(options.classes.editable);\n            },\n            isEditIcon: function(el) {\n                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n            },\n            getEditInput: function(id) {\n                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n            },\n            isEditInput: function(el) {\n                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n            },\n            updateProgress: function(id, loaded, total) {\n                var bar = getProgress(id), percent;\n                if (bar && total > 0) {\n                    percent = Math.round(loaded / total * 100);\n                    if (percent === 100) {\n                        hide(bar);\n                    } else {\n                        show(bar);\n                    }\n                    setProgressBarWidth(id, percent);\n                }\n            },\n            updateTotalProgress: function(loaded, total) {\n                this.updateProgress(null, loaded, total);\n            },\n            hideProgress: function(id) {\n                var bar = getProgress(id);\n                bar && hide(bar);\n            },\n            hideTotalProgress: function() {\n                this.hideProgress();\n            },\n            resetProgress: function(id) {\n                setProgressBarWidth(id, 0);\n                this.hideTotalProgress(id);\n            },\n            resetTotalProgress: function() {\n                this.resetProgress();\n            },\n            showCancel: function(id) {\n                if (!isCancelDisabled) {\n                    var cancel = getCancel(id);\n                    cancel && qq(cancel).removeClass(options.classes.hide);\n                }\n            },\n            hideCancel: function(id) {\n                hide(getCancel(id));\n            },\n            isCancel: function(el) {\n                return qq(el).hasClass(selectorClasses.cancel, true);\n            },\n            allowPause: function(id) {\n                show(getPause(id));\n                hide(getContinue(id));\n            },\n            uploadPaused: function(id) {\n                this.setStatusText(id, options.text.paused);\n                this.allowContinueButton(id);\n                hide(getSpinner(id));\n            },\n            hidePause: function(id) {\n                hide(getPause(id));\n            },\n            isPause: function(el) {\n                return qq(el).hasClass(selectorClasses.pause, true);\n            },\n            isContinueButton: function(el) {\n                return qq(el).hasClass(selectorClasses.continueButton, true);\n            },\n            allowContinueButton: function(id) {\n                show(getContinue(id));\n                hide(getPause(id));\n            },\n            uploadContinued: function(id) {\n                this.setStatusText(id, \"\");\n                this.allowPause(id);\n                show(getSpinner(id));\n            },\n            showDeleteButton: function(id) {\n                show(getDelete(id));\n            },\n            hideDeleteButton: function(id) {\n                hide(getDelete(id));\n            },\n            isDeleteButton: function(el) {\n                return qq(el).hasClass(selectorClasses.deleteButton, true);\n            },\n            isRetry: function(el) {\n                return qq(el).hasClass(selectorClasses.retry, true);\n            },\n            updateSize: function(id, text) {\n                var size = getSize(id);\n                if (size) {\n                    show(size);\n                    qq(size).setText(text);\n                }\n            },\n            setStatusText: function(id, text) {\n                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n                if (textEl) {\n                    if (text == null) {\n                        qq(textEl).clearText();\n                    } else {\n                        qq(textEl).setText(text);\n                    }\n                }\n            },\n            hideSpinner: function(id) {\n                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n                hide(getSpinner(id));\n            },\n            showSpinner: function(id) {\n                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n                show(getSpinner(id));\n            },\n            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        id: id,\n                        customResizeFunction: customResizeFunction,\n                        optFileOrBlob: optFileOrBlob\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        customResizeFunction: customResizeFunction,\n                        update: true,\n                        id: id,\n                        thumbnailUrl: thumbnailUrl,\n                        showWaitingImg: showWaitingImg\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            hasDialog: function(type) {\n                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n            },\n            showDialog: function(type, message, defaultValue) {\n                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n                    promise.failure();\n                }, cancelClickHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    dialog.close();\n                }, okClickHandler = function() {\n                    dialog.removeEventListener(\"close\", closeHandler);\n                    okBtn.removeEventListener(\"click\", okClickHandler);\n                    dialog.close();\n                    promise.success(inputEl && inputEl.value);\n                };\n                dialog.addEventListener(\"close\", closeHandler);\n                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n                if (inputEl) {\n                    inputEl.value = defaultValue;\n                }\n                messageEl.textContent = message;\n                dialog.showModal();\n                return promise;\n            }\n        });\n    };\n    qq.UiEventHandler = function(s, protectedApi) {\n        \"use strict\";\n        var disposer = new qq.DisposeSupport(), spec = {\n            eventType: \"click\",\n            attachTo: null,\n            onHandled: function(target, event) {}\n        };\n        qq.extend(this, {\n            addHandler: function(element) {\n                addHandler(element);\n            },\n            dispose: function() {\n                disposer.dispose();\n            }\n        });\n        function addHandler(element) {\n            disposer.attach(element, spec.eventType, function(event) {\n                event = event || window.event;\n                var target = event.target || event.srcElement;\n                spec.onHandled(target, event);\n            });\n        }\n        qq.extend(protectedApi, {\n            getFileIdFromItem: function(item) {\n                return item.qqFileId;\n            },\n            getDisposeSupport: function() {\n                return disposer;\n            }\n        });\n        qq.extend(spec, s);\n        if (spec.attachTo) {\n            addHandler(spec.attachTo);\n        }\n    };\n    qq.FileButtonsClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onDeleteFile: function(fileId) {},\n            onCancel: function(fileId) {},\n            onRetry: function(fileId) {},\n            onPause: function(fileId) {},\n            onContinue: function(fileId) {},\n            onGetName: function(fileId) {}\n        }, buttonHandlers = {\n            cancel: function(id) {\n                spec.onCancel(id);\n            },\n            retry: function(id) {\n                spec.onRetry(id);\n            },\n            deleteButton: function(id) {\n                spec.onDeleteFile(id);\n            },\n            pause: function(id) {\n                spec.onPause(id);\n            },\n            continueButton: function(id) {\n                spec.onContinue(id);\n            }\n        };\n        function examineEvent(target, event) {\n            qq.each(buttonHandlers, function(buttonType, handler) {\n                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n                    fileId = spec.templating.getFileId(target);\n                    qq.preventDefault(event);\n                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    handler(fileId);\n                    return false;\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            classes: {\n                file: \"qq-upload-file\",\n                editNameIcon: \"qq-edit-filename-icon\"\n            },\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {}\n        };\n        qq.extend(spec, s);\n        function examineEvent(target, event) {\n            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    qq.preventDefault(event);\n                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n                }\n            }\n        }\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            onGetUploadStatus: function(fileId) {},\n            log: function(message, lvl) {}\n        };\n        if (!inheritedInternalApi) {\n            inheritedInternalApi = {};\n        }\n        function handleInputFocus(target, event) {\n            if (spec.templating.isEditInput(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n                }\n            }\n        }\n        spec.eventType = \"focusin\";\n        spec.onHandled = handleInputFocus;\n        qq.extend(spec, s);\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusHandler = function(spec) {\n        \"use strict\";\n        spec.eventType = \"focus\";\n        spec.attachTo = null;\n        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n    };\n    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {},\n            onSetName: function(fileId, newName) {},\n            onEditingStatusChange: function(fileId, isEditing) {}\n        };\n        function getFilenameSansExtension(fileId) {\n            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n            if (extIdx > 0) {\n                filenameSansExt = filenameSansExt.substr(0, extIdx);\n            }\n            return filenameSansExt;\n        }\n        function getOriginalExtension(fileId) {\n            var origName = spec.onGetName(fileId);\n            return qq.getExtension(origName);\n        }\n        function handleNameUpdate(newFilenameInputEl, fileId) {\n            var newName = newFilenameInputEl.value, origExtension;\n            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n                origExtension = getOriginalExtension(fileId);\n                if (origExtension !== undefined) {\n                    newName = newName + \".\" + origExtension;\n                }\n                spec.onSetName(fileId, newName);\n            }\n            spec.onEditingStatusChange(fileId, false);\n        }\n        function registerInputBlurHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n                handleNameUpdate(inputEl, fileId);\n            });\n        }\n        function registerInputEnterKeyHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n                var code = event.keyCode || event.which;\n                if (code === 13) {\n                    handleNameUpdate(inputEl, fileId);\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n        qq.extend(inheritedInternalApi, {\n            handleFilenameEdit: function(id, target, focusInput) {\n                var newFilenameInputEl = spec.templating.getEditInput(id);\n                spec.onEditingStatusChange(id, true);\n                newFilenameInputEl.value = getFilenameSansExtension(id);\n                if (focusInput) {\n                    newFilenameInputEl.focus();\n                }\n                registerInputBlurHandler(newFilenameInputEl, id);\n                registerInputEnterKeyHandler(newFilenameInputEl, id);\n            }\n        });\n    };\n})(window);\n//# sourceMappingURL=fine-uploader.js.map\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n\nHolder - client side image placeholders\nVersion 2.9.4+cabil\n© 2016 Ivan Malopinsky - http://imsky.co\n\nSite:     http://holderjs.com\nIssues:   https://github.com/imsky/holder/issues\nLicense:  MIT\n\n*/\n(function (window) {\n  if (!window.document) return;\n  var document = window.document;\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n    if (!document.querySelectorAll) {\n      document.querySelectorAll = function (selectors) {\n        var style = document.createElement('style'), elements = [], element;\n        document.documentElement.firstChild.appendChild(style);\n        document._qsa = [];\n\n        style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';\n        window.scrollBy(0, 0);\n        style.parentNode.removeChild(style);\n\n        while (document._qsa.length) {\n          element = document._qsa.shift();\n          element.style.removeAttribute('x-qsa');\n          elements.push(element);\n        }\n        document._qsa = null;\n        return elements;\n      };\n    }\n\n    if (!document.querySelector) {\n      document.querySelector = function (selectors) {\n        var elements = document.querySelectorAll(selectors);\n        return (elements.length) ? elements[0] : null;\n      };\n    }\n\n    if (!document.getElementsByClassName) {\n      document.getElementsByClassName = function (classNames) {\n        classNames = String(classNames).replace(/^|\\s+/g, '.');\n        return document.querySelectorAll(classNames);\n      };\n    }\n\n  //https://github.com/inexorabletash/polyfill\n  // ES5 15.2.3.14 Object.keys ( O )\n  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }\n      var ret = [], p;\n      for (p in o) {\n        if (Object.prototype.hasOwnProperty.call(o, p)) {\n          ret.push(p);\n        }\n      }\n      return ret;\n    };\n  }\n\n  // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function (fun /*, thisp */) {\n      if (this === void 0 || this === null) { throw TypeError(); }\n\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (typeof fun !== \"function\") { throw TypeError(); }\n\n      var thisp = arguments[1], i;\n      for (i = 0; i < len; i++) {\n        if (i in t) {\n          fun.call(thisp, t[i], i, t);\n        }\n      }\n    };\n  }\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n  (function (global) {\n    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    global.atob = global.atob || function (input) {\n      input = String(input);\n      var position = 0,\n          output = [],\n          buffer = 0, bits = 0, n;\n\n      input = input.replace(/\\s/g, '');\n      if ((input.length % 4) === 0) { input = input.replace(/=+$/, ''); }\n      if ((input.length % 4) === 1) { throw Error('InvalidCharacterError'); }\n      if (/[^+/0-9A-Za-z]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        n = B64_ALPHABET.indexOf(input.charAt(position));\n        buffer = (buffer << 6) | n;\n        bits += 6;\n\n        if (bits === 24) {\n          output.push(String.fromCharCode((buffer >> 16) & 0xFF));\n          output.push(String.fromCharCode((buffer >>  8) & 0xFF));\n          output.push(String.fromCharCode(buffer & 0xFF));\n          bits = 0;\n          buffer = 0;\n        }\n        position += 1;\n      }\n\n      if (bits === 12) {\n        buffer = buffer >> 4;\n        output.push(String.fromCharCode(buffer & 0xFF));\n      } else if (bits === 18) {\n        buffer = buffer >> 2;\n        output.push(String.fromCharCode((buffer >> 8) & 0xFF));\n        output.push(String.fromCharCode(buffer & 0xFF));\n      }\n\n      return output.join('');\n    };\n\n    global.btoa = global.btoa || function (input) {\n      input = String(input);\n      var position = 0,\n          out = [],\n          o1, o2, o3,\n          e1, e2, e3, e4;\n\n      if (/[^\\x00-\\xFF]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        o1 = input.charCodeAt(position++);\n        o2 = input.charCodeAt(position++);\n        o3 = input.charCodeAt(position++);\n\n        // 111111 112222 222233 333333\n        e1 = o1 >> 2;\n        e2 = ((o1 & 0x3) << 4) | (o2 >> 4);\n        e3 = ((o2 & 0xf) << 2) | (o3 >> 6);\n        e4 = o3 & 0x3f;\n\n        if (position === input.length + 2) {\n          e3 = 64; e4 = 64;\n        }\n        else if (position === input.length + 1) {\n          e4 = 64;\n        }\n\n        out.push(B64_ALPHABET.charAt(e1),\n                 B64_ALPHABET.charAt(e2),\n                 B64_ALPHABET.charAt(e3),\n                 B64_ALPHABET.charAt(e4));\n      }\n\n      return out.join('');\n    };\n  }(window));\n\n  //https://gist.github.com/jimeh/332357\n  if (!Object.prototype.hasOwnProperty){\n      /*jshint -W001, -W103 */\n      Object.prototype.hasOwnProperty = function(prop) {\n      var proto = this.__proto__ || this.constructor.prototype;\n      return (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);\n    };\n      /*jshint +W001, +W103 */\n  }\n\n  // @license http://opensource.org/licenses/MIT\n  // copyright Paul Irish 2015\n\n\n  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n\n  (function(){\n\n    if ('performance' in window === false) {\n        window.performance = {};\n    }\n    \n    Date.now = (Date.now || function () {  // thanks IE8\n      return new Date().getTime();\n    });\n\n    if ('now' in window.performance === false){\n      \n      var nowOffset = Date.now();\n      \n      if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n      }\n\n      window.performance.now = function now(){\n        return Date.now() - nowOffset;\n      };\n    }\n\n  })();\n\n  //requestAnimationFrame polyfill for older Firefox/Chrome versions\n  if (!window.requestAnimationFrame) {\n    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {\n    //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return webkitRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.webkitCancelAnimationFrame;\n    }(window));\n    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {\n      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return mozRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.mozCancelAnimationFrame;\n    }(window));\n    } else {\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return global.setTimeout(callback, 1000 / 60);\n      };\n\n      global.cancelAnimationFrame = global.clearTimeout;\n    })(window);\n    }\n  }\n})(this);\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Holder\"] = factory();\n\telse\n\t\troot[\"Holder\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2015 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2016 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\t//Libraries and functions\n\tvar onDomReady = __webpack_require__(2);\n\tvar querystring = __webpack_require__(3);\n\n\tvar SceneGraph = __webpack_require__(6);\n\tvar utils = __webpack_require__(7);\n\tvar SVG = __webpack_require__(8);\n\tvar DOM = __webpack_require__(9);\n\tvar Color = __webpack_require__(10);\n\tvar constants = __webpack_require__(11);\n\n\tvar svgRenderer = __webpack_require__(12);\n\tvar sgCanvasRenderer = __webpack_require__(15);\n\n\tvar extend = utils.extend;\n\tvar dimensionCheck = utils.dimensionCheck;\n\n\t//Constants and definitions\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar Holder = {\n\t    version: constants.version,\n\n\t    /**\n\t     * Adds a theme to default settings\n\t     *\n\t     * @param {string} name Theme name\n\t     * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.\n\t     */\n\t    addTheme: function(name, theme) {\n\t        name != null && theme != null && (App.settings.themes[name] = theme);\n\t        delete App.vars.cache.themeKeys;\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Appends a placeholder to an element\n\t     *\n\t     * @param {string} src Placeholder URL string\n\t     * @param el A selector or a reference to a DOM node\n\t     */\n\t    addImage: function(src, el) {\n\t        //todo: use jquery fallback if available for all QSA references\n\t        var nodes = DOM.getNodeArray(el);\n\t        nodes.forEach(function (node) {\n\t            var img = DOM.newEl('img');\n\t            var domProps = {};\n\t            domProps[App.setup.dataAttr] = src;\n\t            DOM.setAttr(img, domProps);\n\t            node.appendChild(img);\n\t        });\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Sets whether or not an image is updated on resize.\n\t     * If an image is set to be updated, it is immediately rendered.\n\t     *\n\t     * @param {Object} el Image DOM element\n\t     * @param {Boolean} value Resizable update flag value\n\t     */\n\t    setResizeUpdate: function(el, value) {\n\t        if (el.holderData) {\n\t            el.holderData.resizeUpdate = !!value;\n\t            if (el.holderData.resizeUpdate) {\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Runs Holder with options. By default runs Holder on all images with \"holder.js\" in their source attributes.\n\t     *\n\t     * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties\n\t     */\n\t    run: function(userOptions) {\n\t        //todo: split processing into separate queues\n\t        userOptions = userOptions || {};\n\t        var engineSettings = {};\n\t        var options = extend(App.settings, userOptions);\n\n\t        App.vars.preempted = true;\n\t        App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;\n\n\t        engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;\n\t        if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {\n\t            engineSettings.renderer = App.setup.supportsSVG ? 'svg' : (App.setup.supportsCanvas ? 'canvas' : 'html');\n\t        }\n\n\t        var images = DOM.getNodeArray(options.images);\n\t        var bgnodes = DOM.getNodeArray(options.bgnodes);\n\t        var stylenodes = DOM.getNodeArray(options.stylenodes);\n\t        var objects = DOM.getNodeArray(options.objects);\n\n\t        engineSettings.stylesheets = [];\n\t        engineSettings.svgXMLStylesheet = true;\n\t        engineSettings.noFontFallback = !!options.noFontFallback;\n\t        engineSettings.noBackgroundSize = !!options.noBackgroundSize;\n\n\t        stylenodes.forEach(function (styleNode) {\n\t            if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {\n\t                var href = styleNode.attributes.href.value;\n\t                //todo: write isomorphic relative-to-absolute URL function\n\t                var proxyLink = DOM.newEl('a');\n\t                proxyLink.href = href;\n\t                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;\n\t                engineSettings.stylesheets.push(stylesheetURL);\n\t            }\n\t        });\n\n\t        bgnodes.forEach(function (bgNode) {\n\t            //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background\n\t            if (!global.getComputedStyle) return;\n\t            var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');\n\t            var dataBackgroundImage = bgNode.getAttribute('data-background-src');\n\t            var rawURL = dataBackgroundImage || backgroundImage;\n\n\t            var holderURL = null;\n\t            var holderString = options.domain + '/';\n\t            var holderStringIndex = rawURL.indexOf(holderString);\n\n\t            if (holderStringIndex === 0) {\n\t                holderURL = rawURL;\n\t            } else if (holderStringIndex === 1 && rawURL[0] === '?') {\n\t                holderURL = rawURL.slice(1);\n\t            } else {\n\t                var fragment = rawURL.substr(holderStringIndex).match(/([^\\\"]*)\"?\\)/);\n\t                if (fragment !== null) {\n\t                    holderURL = fragment[1];\n\t                } else if (rawURL.indexOf('url(') === 0) {\n\t                    throw 'Holder: unable to parse background URL: ' + rawURL;\n\t                }\n\t            }\n\n\t            if (holderURL) {\n\t                var holderFlags = parseURL(holderURL, options);\n\t                if (holderFlags) {\n\t                    prepareDOMElement({\n\t                        mode: 'background',\n\t                        el: bgNode,\n\t                        flags: holderFlags,\n\t                        engineSettings: engineSettings\n\t                    });\n\t                }\n\t            }\n\t        });\n\n\t        objects.forEach(function (object) {\n\t            var objectAttr = {};\n\n\t            try {\n\t                objectAttr.data = object.getAttribute('data');\n\t                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);\n\t            } catch (e) {}\n\n\t            var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;\n\t            var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;\n\n\t            if (objectHasSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.data, object);\n\t            } else if (objectHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);\n\t            }\n\t        });\n\n\t        images.forEach(function (image) {\n\t            var imageAttr = {};\n\n\t            try {\n\t                imageAttr.src = image.getAttribute('src');\n\t                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);\n\t                imageAttr.rendered = image.getAttribute('data-holder-rendered');\n\t            } catch (e) {}\n\n\t            var imageHasSrc = imageAttr.src != null;\n\t            var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;\n\t            var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';\n\n\t            if (imageHasSrc) {\n\t                if (imageAttr.src.indexOf(options.domain) === 0) {\n\t                    prepareImageElement(options, engineSettings, imageAttr.src, image);\n\t                } else if (imageHasDataSrcURL) {\n\t                    //Image has a valid data-src and an invalid src\n\t                    if (imageRendered) {\n\t                        //If the placeholder has already been render, re-render it\n\t                        prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t                    } else {\n\t                        //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't\n\t                        (function(src, options, engineSettings, dataSrc, image) {\n\t                            utils.imageExists(src, function(exists) {\n\t                                if (!exists) {\n\t                                    prepareImageElement(options, engineSettings, dataSrc, image);\n\t                                }\n\t                            });\n\t                        })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);\n\t                    }\n\t                }\n\t            } else if (imageHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t            }\n\t        });\n\n\t        return this;\n\t    }\n\t};\n\n\tvar App = {\n\t    settings: {\n\t        domain: 'holder.js',\n\t        images: 'img',\n\t        objects: 'object',\n\t        bgnodes: 'body .holderjs',\n\t        stylenodes: 'head link.holderjs',\n\t        themes: {\n\t            'gray': {\n\t                bg: '#EEEEEE',\n\t                fg: '#AAAAAA'\n\t            },\n\t            'social': {\n\t                bg: '#3a5a97',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'industrial': {\n\t                bg: '#434A52',\n\t                fg: '#C2F200'\n\t            },\n\t            'sky': {\n\t                bg: '#0D8FDB',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'vine': {\n\t                bg: '#39DBAC',\n\t                fg: '#1E292C'\n\t            },\n\t            'lava': {\n\t                bg: '#F8591A',\n\t                fg: '#1C2846'\n\t            }\n\t        }\n\t    },\n\t    defaults: {\n\t        size: 10,\n\t        units: 'pt',\n\t        scale: 1 / 16\n\t    }\n\t};\n\n\t/**\n\t * Processes provided source attribute and sets up the appropriate rendering workflow\n\t *\n\t * @private\n\t * @param options Instance options from Holder.run\n\t * @param renderSettings Instance configuration\n\t * @param src Image URL\n\t * @param el Image DOM element\n\t */\n\tfunction prepareImageElement(options, engineSettings, src, el) {\n\t    var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);\n\t    if (holderFlags) {\n\t        prepareDOMElement({\n\t            mode: null,\n\t            el: el,\n\t            flags: holderFlags,\n\t            engineSettings: engineSettings\n\t        });\n\t    }\n\t}\n\n\t/**\n\t * Processes a Holder URL and extracts configuration from query string\n\t *\n\t * @private\n\t * @param url URL\n\t * @param instanceOptions Instance options from Holder.run\n\t */\n\tfunction parseURL(url, instanceOptions) {\n\t    var holder = {\n\t        theme: extend(App.settings.themes.gray, null),\n\t        stylesheets: instanceOptions.stylesheets,\n\t        instanceOptions: instanceOptions\n\t    };\n\n\t    var firstQuestionMark = url.indexOf('?');\n\t    var parts = [url];\n\n\t    if (firstQuestionMark !== -1) {\n\t        parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];\n\t    }\n\n\t    var basics = parts[0].split('/');\n\n\t    holder.holderURL = url;\n\n\t    var dimensions = basics[1];\n\t    var dimensionData = dimensions.match(/([\\d]+p?)x([\\d]+p?)/);\n\n\t    if (!dimensionData) return false;\n\n\t    holder.fluid = dimensions.indexOf('p') !== -1;\n\n\t    holder.dimensions = {\n\t        width: dimensionData[1].replace('p', '%'),\n\t        height: dimensionData[2].replace('p', '%')\n\t    };\n\n\t    if (parts.length === 2) {\n\t        var options = querystring.parse(parts[1]);\n\n\t        // Dimensions\n\n\t        if (utils.truthy(options.ratio)) {\n\t            holder.fluid = true;\n\t            var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));\n\t            var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));\n\n\t            ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));\n\t            ratioWidth = 100;\n\n\t            holder.dimensions.width = ratioWidth + '%';\n\t            holder.dimensions.height = ratioHeight + '%';\n\t        }\n\n\t        holder.auto = utils.truthy(options.auto);\n\n\t        // Colors\n\n\t        if (options.bg) {\n\t            holder.theme.bg = utils.parseColor(options.bg);\n\t        }\n\n\t        if (options.fg) {\n\t            holder.theme.fg = utils.parseColor(options.fg);\n\t        }\n\n\t        //todo: add automatic foreground to themes without foreground\n\t        if (options.bg && !options.fg) {\n\t            holder.autoFg = true;\n\t        }\n\n\t        if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {\n\t            holder.theme = extend(holder.instanceOptions.themes[options.theme], null);\n\t        }\n\n\t        // Text\n\n\t        if (options.text) {\n\t            holder.text = options.text;\n\t        }\n\n\t        if (options.textmode) {\n\t            holder.textmode = options.textmode;\n\t        }\n\n\t        if (options.size) {\n\t            holder.size = options.size;\n\t        }\n\n\t        if (options.font) {\n\t            holder.font = options.font;\n\t        }\n\n\t        if (options.align) {\n\t            holder.align = options.align;\n\t        }\n\n\t        if (options.lineWrap) {\n\t            holder.lineWrap = options.lineWrap;\n\t        }\n\n\t        holder.nowrap = utils.truthy(options.nowrap);\n\n\t        // Miscellaneous\n\n\t        holder.outline = utils.truthy(options.outline);\n\n\t        if (utils.truthy(options.random)) {\n\t            App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);\n\t            var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];\n\t            holder.theme = extend(holder.instanceOptions.themes[_theme], null);\n\t        }\n\t    }\n\n\t    return holder;\n\t}\n\n\t/**\n\t * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)\n\t *\n\t * @private\n\t * @param settings DOM prep settings\n\t */\n\tfunction prepareDOMElement(prepSettings) {\n\t    var mode = prepSettings.mode;\n\t    var el = prepSettings.el;\n\t    var flags = prepSettings.flags;\n\t    var _engineSettings = prepSettings.engineSettings;\n\t    var dimensions = flags.dimensions,\n\t        theme = flags.theme;\n\t    var dimensionsCaption = dimensions.width + 'x' + dimensions.height;\n\t    mode = mode == null ? (flags.fluid ? 'fluid' : 'image') : mode;\n\t    var holderTemplateRe = /holder_([a-z]+)/g;\n\t    var dimensionsInText = false;\n\n\t    if (flags.text != null) {\n\t        theme.text = flags.text;\n\n\t        //<object> SVG embedding doesn't parse Unicode properly\n\t        if (el.nodeName.toLowerCase() === 'object') {\n\t            var textLines = theme.text.split('\\\\n');\n\t            for (var k = 0; k < textLines.length; k++) {\n\t                textLines[k] = utils.encodeHtmlEntity(textLines[k]);\n\t            }\n\t            theme.text = textLines.join('\\\\n');\n\t        }\n\t    }\n\n\t    if (theme.text) {\n\t        var holderTemplateMatches = theme.text.match(holderTemplateRe);\n\n\t        if (holderTemplateMatches !== null) {\n\t            //todo: optimize template replacement\n\t            holderTemplateMatches.forEach(function (match) {\n\t                if (match === 'holder_dimensions') {\n\t                    theme.text = theme.text.replace(match, dimensionsCaption);\n\t                }\n\t            });\n\t        }\n\t    }\n\n\t    var holderURL = flags.holderURL;\n\t    var engineSettings = extend(_engineSettings, null);\n\n\t    if (flags.font) {\n\t        /*\n\t        If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.\n\n\t        This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.\n\t        The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.\n\t        */\n\t        theme.font = flags.font;\n\t        if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {\n\t            engineSettings = extend(engineSettings, {\n\t                renderer: 'canvas'\n\t            });\n\t        }\n\t    }\n\n\t    //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas\n\t    if (flags.font && engineSettings.renderer == 'canvas') {\n\t        engineSettings.reRender = true;\n\t    }\n\n\t    if (mode == 'background') {\n\t        if (el.getAttribute('data-background-src') == null) {\n\t            DOM.setAttr(el, {\n\t                'data-background-src': holderURL\n\t            });\n\t        }\n\t    } else {\n\t        var domProps = {};\n\t        domProps[App.vars.dataAttr] = holderURL;\n\t        DOM.setAttr(el, domProps);\n\t    }\n\n\t    flags.theme = theme;\n\n\t    //todo consider using all renderSettings in holderData\n\t    el.holderData = {\n\t        flags: flags,\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image' || mode == 'fluid') {\n\t        DOM.setAttr(el, {\n\t            'alt': theme.text ? (dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']') : dimensionsCaption\n\t        });\n\t    }\n\n\t    var renderSettings = {\n\t        mode: mode,\n\t        el: el,\n\t        holderSettings: {\n\t            dimensions: dimensions,\n\t            theme: theme,\n\t            flags: flags\n\t        },\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image') {\n\t        if (!flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            render(renderSettings);\n\n\t            if (flags.textmode == 'exact') {\n\t                el.holderData.resizeUpdate = true;\n\t                App.vars.resizableImages.push(el);\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    } else if (mode == 'background' && engineSettings.renderer != 'html') {\n\t        render(renderSettings);\n\t    } else if (mode == 'fluid') {\n\t        el.holderData.resizeUpdate = true;\n\n\t        if (dimensions.height.slice(-1) == '%') {\n\t            el.style.height = dimensions.height;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\t        if (dimensions.width.slice(-1) == '%') {\n\t            el.style.width = dimensions.width;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t        }\n\t        if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {\n\t            el.style.display = 'block';\n\t        }\n\n\t        setInitialDimensions(el);\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            App.vars.resizableImages.push(el);\n\t            updateResizableElements(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Core function that takes output from renderers and sets it as the source or background-image of the target element\n\t *\n\t * @private\n\t * @param renderSettings Renderer settings\n\t */\n\tfunction render(renderSettings) {\n\t    var image = null;\n\t    var mode = renderSettings.mode;\n\t    var el = renderSettings.el;\n\t    var holderSettings = renderSettings.holderSettings;\n\t    var engineSettings = renderSettings.engineSettings;\n\n\t    switch (engineSettings.renderer) {\n\t        case 'svg':\n\t            if (!App.setup.supportsSVG) return;\n\t            break;\n\t        case 'canvas':\n\t            if (!App.setup.supportsCanvas) return;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\n\t    //todo: move generation of scene up to flag generation to reduce extra object creation\n\t    var scene = {\n\t        width: holderSettings.dimensions.width,\n\t        height: holderSettings.dimensions.height,\n\t        theme: holderSettings.theme,\n\t        flags: holderSettings.flags\n\t    };\n\n\t    var sceneGraph = buildSceneGraph(scene);\n\n\t    function getRenderedImage() {\n\t        var image = null;\n\t        switch (engineSettings.renderer) {\n\t            case 'canvas':\n\t                image = sgCanvasRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            case 'svg':\n\t                image = svgRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            default:\n\t                throw 'Holder: invalid renderer: ' + engineSettings.renderer;\n\t        }\n\n\t        return image;\n\t    }\n\n\t    image = getRenderedImage();\n\n\t    if (image == null) {\n\t        throw 'Holder: couldn\\'t render placeholder';\n\t    }\n\n\t    //todo: add <object> canvas rendering\n\t    if (mode == 'background') {\n\t        el.style.backgroundImage = 'url(' + image + ')';\n\n\t        if (!engineSettings.noBackgroundSize) {\n\t            el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';\n\t        }\n\t    } else {\n\t        if (el.nodeName.toLowerCase() === 'img') {\n\t            DOM.setAttr(el, {\n\t                'src': image\n\t            });\n\t        } else if (el.nodeName.toLowerCase() === 'object') {\n\t            DOM.setAttr(el, {\n\t                'data': image,\n\t                'type': 'image/svg+xml'\n\t            });\n\t        }\n\t        if (engineSettings.reRender) {\n\t            global.setTimeout(function () {\n\t                var image = getRenderedImage();\n\t                if (image == null) {\n\t                    throw 'Holder: couldn\\'t render placeholder';\n\t                }\n\t                //todo: refactor this code into a function\n\t                if (el.nodeName.toLowerCase() === 'img') {\n\t                    DOM.setAttr(el, {\n\t                        'src': image\n\t                    });\n\t                } else if (el.nodeName.toLowerCase() === 'object') {\n\t                    DOM.setAttr(el, {\n\t                        'data': image,\n\t                        'type': 'image/svg+xml'\n\t                    });\n\t                }\n\t            }, 150);\n\t        }\n\t    }\n\t    //todo: account for re-rendering\n\t    DOM.setAttr(el, {\n\t        'data-holder-rendered': true\n\t    });\n\t}\n\n\t/**\n\t * Core function that takes a Holder scene description and builds a scene graph\n\t *\n\t * @private\n\t * @param scene Holder scene object\n\t */\n\t//todo: make this function reusable\n\t//todo: merge app defaults and setup properties into the scene argument\n\tfunction buildSceneGraph(scene) {\n\t    var fontSize = App.defaults.size;\n\t    if (parseFloat(scene.theme.size)) {\n\t        fontSize = scene.theme.size;\n\t    } else if (parseFloat(scene.flags.size)) {\n\t        fontSize = scene.flags.size;\n\t    }\n\n\t    scene.font = {\n\t        family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',\n\t        size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),\n\t        units: scene.theme.units ? scene.theme.units : App.defaults.units,\n\t        weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'\n\t    };\n\n\t    scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);\n\n\t    scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;\n\n\t    scene.align = scene.theme.align || scene.flags.align || 'center';\n\n\t    switch (scene.flags.textmode) {\n\t        case 'literal':\n\t            scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;\n\t            break;\n\t        case 'exact':\n\t            if (!scene.flags.exactDimensions) break;\n\t            scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);\n\t            break;\n\t    }\n\n\t    var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;\n\t    var sceneMargin = scene.width * lineWrap;\n\t    var maxLineWidth = sceneMargin;\n\n\t    var sceneGraph = new SceneGraph({\n\t        width: scene.width,\n\t        height: scene.height\n\t    });\n\n\t    var Shape = sceneGraph.Shape;\n\n\t    var holderBg = new Shape.Rect('holderBg', {\n\t        fill: scene.theme.bg\n\t    });\n\n\t    holderBg.resize(scene.width, scene.height);\n\t    sceneGraph.root.add(holderBg);\n\n\t    if (scene.flags.outline) {\n\t        var outlineColor = new Color(holderBg.properties.fill);\n\t        outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);\n\t        holderBg.properties.outline = {\n\t            fill: outlineColor.toHex(true),\n\t            width: 2\n\t        };\n\t    }\n\n\t    var holderTextColor = scene.theme.fg;\n\n\t    if (scene.flags.autoFg) {\n\t        var holderBgColor = new Color(holderBg.properties.fill);\n\t        var lightColor = new Color('fff');\n\t        var darkColor = new Color('000', {\n\t            'alpha': 0.285714\n\t        });\n\n\t        holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);\n\t    }\n\n\t    var holderTextGroup = new Shape.Group('holderTextGroup', {\n\t        text: scene.text,\n\t        align: scene.align,\n\t        font: scene.font,\n\t        fill: holderTextColor\n\t    });\n\n\t    holderTextGroup.moveTo(null, null, 1);\n\t    sceneGraph.root.add(holderTextGroup);\n\n\t    var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);\n\t    if (!tpdata) {\n\t        throw 'Holder: staging fallback not supported yet.';\n\t    }\n\t    holderTextGroup.properties.leading = tpdata.boundingBox.height;\n\n\t    var textNode = null;\n\t    var line = null;\n\n\t    function finalizeLine(parent, line, width, height) {\n\t        line.width = width;\n\t        line.height = height;\n\t        parent.width = Math.max(parent.width, line.width);\n\t        parent.height += line.height;\n\t    }\n\n\t    if (tpdata.lineCount > 1) {\n\t        var offsetX = 0;\n\t        var offsetY = 0;\n\t        var lineIndex = 0;\n\t        var lineKey;\n\t        line = new Shape.Group('line' + lineIndex);\n\n\t        //Double margin so that left/right-aligned next is not flush with edge of image\n\t        if (scene.align === 'left' || scene.align === 'right') {\n\t            maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);\n\t        }\n\n\t        for (var i = 0; i < tpdata.words.length; i++) {\n\t            var word = tpdata.words[i];\n\t            textNode = new Shape.Text(word.text);\n\t            var newline = word.text == '\\\\n';\n\t            if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {\n\t                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t                holderTextGroup.add(line);\n\t                offsetX = 0;\n\t                offsetY += holderTextGroup.properties.leading;\n\t                lineIndex += 1;\n\t                line = new Shape.Group('line' + lineIndex);\n\t                line.y = offsetY;\n\t            }\n\t            if (newline === true) {\n\t                continue;\n\t            }\n\t            textNode.moveTo(offsetX, 0);\n\t            offsetX += tpdata.spaceWidth + word.width;\n\t            line.add(textNode);\n\t        }\n\n\t        finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo(scene.width - line.width, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);\n\n\t        //If the text exceeds vertical space, move it down so the first line is visible\n\t        if ((scene.height - holderTextGroup.height) / 2 < 0) {\n\t            holderTextGroup.moveTo(null, 0, null);\n\t        }\n\t    } else {\n\t        textNode = new Shape.Text(scene.text);\n\t        line = new Shape.Group('line0');\n\t        line.add(textNode);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);\n\t    }\n\n\t    //todo: renderlist\n\t    return sceneGraph;\n\t}\n\n\t/**\n\t * Adaptive text sizing function\n\t *\n\t * @private\n\t * @param width Parent width\n\t * @param height Parent height\n\t * @param fontSize Requested text size\n\t * @param scale Proportional scale of text\n\t */\n\tfunction textSize(width, height, fontSize, scale) {\n\t    var stageWidth = parseInt(width, 10);\n\t    var stageHeight = parseInt(height, 10);\n\n\t    var bigSide = Math.max(stageWidth, stageHeight);\n\t    var smallSide = Math.min(stageWidth, stageHeight);\n\n\t    var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);\n\t    return Math.round(Math.max(fontSize, newHeight));\n\t}\n\n\t/**\n\t * Iterates over resizable (fluid or auto) placeholders and renders them\n\t *\n\t * @private\n\t * @param element Optional element selector, specified only if a specific element needs to be re-rendered\n\t */\n\tfunction updateResizableElements(element) {\n\t    var images;\n\t    if (element == null || element.nodeType == null) {\n\t        images = App.vars.resizableImages;\n\t    } else {\n\t        images = [element];\n\t    }\n\t    for (var i = 0, l = images.length; i < l; i++) {\n\t        var el = images[i];\n\t        if (el.holderData) {\n\t            var flags = el.holderData.flags;\n\t            var dimensions = dimensionCheck(el);\n\t            if (dimensions) {\n\t                if (!el.holderData.resizeUpdate) {\n\t                    continue;\n\t                }\n\n\t                if (flags.fluid && flags.auto) {\n\t                    var fluidConfig = el.holderData.fluidConfig;\n\t                    switch (fluidConfig.mode) {\n\t                        case 'width':\n\t                            dimensions.height = dimensions.width / fluidConfig.ratio;\n\t                            break;\n\t                        case 'height':\n\t                            dimensions.width = dimensions.height * fluidConfig.ratio;\n\t                            break;\n\t                    }\n\t                }\n\n\t                var settings = {\n\t                    mode: 'image',\n\t                    holderSettings: {\n\t                        dimensions: dimensions,\n\t                        theme: flags.theme,\n\t                        flags: flags\n\t                    },\n\t                    el: el,\n\t                    engineSettings: el.holderData.engineSettings\n\t                };\n\n\t                if (flags.textmode == 'exact') {\n\t                    flags.exactDimensions = dimensions;\n\t                    settings.holderSettings.dimensions = flags.dimensions;\n\t                }\n\n\t                render(settings);\n\t            } else {\n\t                setInvisible(el);\n\t            }\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing\n\t *\n\t * @private\n\t * @param el Image DOM element\n\t */\n\tfunction setInitialDimensions(el) {\n\t    if (el.holderData) {\n\t        var dimensions = dimensionCheck(el);\n\t        if (dimensions) {\n\t            var flags = el.holderData.flags;\n\n\t            var fluidConfig = {\n\t                fluidHeight: flags.dimensions.height.slice(-1) == '%',\n\t                fluidWidth: flags.dimensions.width.slice(-1) == '%',\n\t                mode: null,\n\t                initialDimensions: dimensions\n\t            };\n\n\t            if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'width';\n\t                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);\n\t            } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'height';\n\t                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;\n\t            }\n\n\t            el.holderData.fluidConfig = fluidConfig;\n\t        } else {\n\t            setInvisible(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.\n\t *\n\t * @private\n\t */\n\tfunction visibilityCheck() {\n\t    var renderableImages = [];\n\t    var keys = Object.keys(App.vars.invisibleImages);\n\t    var el;\n\n\t    keys.forEach(function (key) {\n\t        el = App.vars.invisibleImages[key];\n\t        if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {\n\t            renderableImages.push(el);\n\t            delete App.vars.invisibleImages[key];\n\t        }\n\t    });\n\n\t    if (renderableImages.length) {\n\t        Holder.run({\n\t            images: renderableImages\n\t        });\n\t    }\n\n\t    // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame\n\t    setTimeout(function () {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t    }, 10);\n\t}\n\n\t/**\n\t * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.\n\t *\n\t * @private\n\t */\n\tfunction startVisibilityCheck() {\n\t    if (!App.vars.visibilityCheckStarted) {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t        App.vars.visibilityCheckStarted = true;\n\t    }\n\t}\n\n\t/**\n\t * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck\n\t *\n\t * @private\n\t * @param el Invisible DOM element\n\t */\n\tfunction setInvisible(el) {\n\t    if (!el.holderData.invisibleId) {\n\t        App.vars.invisibleId += 1;\n\t        App.vars.invisibleImages['i' + App.vars.invisibleId] = el;\n\t        el.holderData.invisibleId = App.vars.invisibleId;\n\t    }\n\t}\n\n\t//todo: see if possible to convert stagingRenderer to use HTML only\n\tvar stagingRenderer = (function() {\n\t    var svg = null,\n\t        stagingText = null,\n\t        stagingTextNode = null;\n\t    return function(graph) {\n\t        var rootNode = graph.root;\n\t        if (App.setup.supportsSVG) {\n\t            var firstTimeSetup = false;\n\t            var tnode = function(text) {\n\t                return document.createTextNode(text);\n\t            };\n\t            if (svg == null || svg.parentNode !== document.body) {\n\t                firstTimeSetup = true;\n\t            }\n\n\t            svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);\n\t            //Show staging element before staging\n\t            svg.style.display = 'block';\n\n\t            if (firstTimeSetup) {\n\t                stagingText = DOM.newEl('text', SVG_NS);\n\t                stagingTextNode = tnode(null);\n\t                DOM.setAttr(stagingText, {\n\t                    x: 0\n\t                });\n\t                stagingText.appendChild(stagingTextNode);\n\t                svg.appendChild(stagingText);\n\t                document.body.appendChild(svg);\n\t                svg.style.visibility = 'hidden';\n\t                svg.style.position = 'absolute';\n\t                svg.style.top = '-100%';\n\t                svg.style.left = '-100%';\n\t                //todo: workaround for zero-dimension <svg> tag in Opera 12\n\t                //svg.setAttribute('width', 0);\n\t                //svg.setAttribute('height', 0);\n\t            }\n\n\t            var holderTextGroup = rootNode.children.holderTextGroup;\n\t            var htgProps = holderTextGroup.properties;\n\t            DOM.setAttr(stagingText, {\n\t                'y': htgProps.font.size,\n\t                'style': utils.cssProps({\n\t                    'font-weight': htgProps.font.weight,\n\t                    'font-size': htgProps.font.size + htgProps.font.units,\n\t                    'font-family': htgProps.font.family\n\t                })\n\t            });\n\n\t            //Get bounding box for the whole string (total width and height)\n\t            stagingTextNode.nodeValue = htgProps.text;\n\t            var stagingTextBBox = stagingText.getBBox();\n\n\t            //Get line count and split the string into words\n\t            var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);\n\t            var words = htgProps.text.split(' ');\n\t            var newlines = htgProps.text.match(/\\\\n/g);\n\t            lineCount += newlines == null ? 0 : newlines.length;\n\n\t            //Get bounding box for the string with spaces removed\n\t            stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');\n\t            var computedNoSpaceLength = stagingText.getComputedTextLength();\n\n\t            //Compute average space width\n\t            var diffLength = stagingTextBBox.width - computedNoSpaceLength;\n\t            var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));\n\n\t            //Get widths for every word with space only if there is more than one line\n\t            var wordWidths = [];\n\t            if (lineCount > 1) {\n\t                stagingTextNode.nodeValue = '';\n\t                for (var i = 0; i < words.length; i++) {\n\t                    if (words[i].length === 0) continue;\n\t                    stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);\n\t                    var bbox = stagingText.getBBox();\n\t                    wordWidths.push({\n\t                        text: words[i],\n\t                        width: bbox.width\n\t                    });\n\t                }\n\t            }\n\n\t            //Hide staging element after staging\n\t            svg.style.display = 'none';\n\n\t            return {\n\t                spaceWidth: spaceWidth,\n\t                lineCount: lineCount,\n\t                boundingBox: stagingTextBBox,\n\t                words: wordWidths\n\t            };\n\t        } else {\n\t            //todo: canvas fallback for measuring text on android 2.3\n\t            return false;\n\t        }\n\t    };\n\t})();\n\n\t//Helpers\n\n\t/**\n\t * Prevents a function from being called too often, waits until a timer elapses to call it again\n\t *\n\t * @param fn Function to call\n\t */\n\tfunction debounce(fn) {\n\t    if (!App.vars.debounceTimer) fn.call(this);\n\t    if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);\n\t    App.vars.debounceTimer = global.setTimeout(function() {\n\t        App.vars.debounceTimer = null;\n\t        fn.call(this);\n\t    }, App.setup.debounce);\n\t}\n\n\t/**\n\t * Holder-specific resize/orientation change callback, debounced to prevent excessive execution\n\t */\n\tfunction resizeEvent() {\n\t    debounce(function() {\n\t        updateResizableElements(null);\n\t    });\n\t}\n\n\t//Set up flags\n\n\tfor (var flag in App.flags) {\n\t    if (!App.flags.hasOwnProperty(flag)) continue;\n\t    App.flags[flag].match = function(val) {\n\t        return val.match(this.regex);\n\t    };\n\t}\n\n\t//Properties set once on setup\n\n\tApp.setup = {\n\t    renderer: 'html',\n\t    debounce: 100,\n\t    ratio: 1,\n\t    supportsCanvas: false,\n\t    supportsSVG: false,\n\t    lineWrapRatio: 0.9,\n\t    dataAttr: 'data-src',\n\t    renderers: ['html', 'canvas', 'svg']\n\t};\n\n\t//Properties modified during runtime\n\n\tApp.vars = {\n\t    preempted: false,\n\t    resizableImages: [],\n\t    invisibleImages: {},\n\t    invisibleId: 0,\n\t    visibilityCheckStarted: false,\n\t    debounceTimer: null,\n\t    cache: {}\n\t};\n\n\t//Pre-flight\n\n\t(function() {\n\t    var canvas = DOM.newEl('canvas');\n\n\t    if (canvas.getContext) {\n\t        if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {\n\t            App.setup.renderer = 'canvas';\n\t            App.setup.supportsCanvas = true;\n\t        }\n\t    }\n\n\t    if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {\n\t        App.setup.renderer = 'svg';\n\t        App.setup.supportsSVG = true;\n\t    }\n\t})();\n\n\t//Starts checking for invisible placeholders\n\tstartVisibilityCheck();\n\n\tif (onDomReady) {\n\t    onDomReady(function() {\n\t        if (!App.vars.preempted) {\n\t            Holder.run();\n\t        }\n\t        if (global.addEventListener) {\n\t            global.addEventListener('resize', resizeEvent, false);\n\t            global.addEventListener('orientationchange', resizeEvent, false);\n\t        } else {\n\t            global.attachEvent('onresize', resizeEvent);\n\t        }\n\n\t        if (typeof global.Turbolinks == 'object') {\n\t            global.document.addEventListener('page:change', function() {\n\t                Holder.run();\n\t            });\n\t        }\n\t    });\n\t}\n\n\tmodule.exports = Holder;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license\n\t *\n\t * Specially modified to work with Holder.js\n\t */\n\n\tfunction _onDomReady(win) {\n\t    //Lazy loading fix for Firefox < 3.6\n\t    //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\t    if (document.readyState == null && document.addEventListener) {\n\t        document.addEventListener(\"DOMContentLoaded\", function DOMContentLoaded() {\n\t            document.removeEventListener(\"DOMContentLoaded\", DOMContentLoaded, false);\n\t            document.readyState = \"complete\";\n\t        }, false);\n\t        document.readyState = \"loading\";\n\t    }\n\t    \n\t    var doc = win.document,\n\t        docElem = doc.documentElement,\n\t    \n\t        LOAD = \"load\",\n\t        FALSE = false,\n\t        ONLOAD = \"on\"+LOAD,\n\t        COMPLETE = \"complete\",\n\t        READYSTATE = \"readyState\",\n\t        ATTACHEVENT = \"attachEvent\",\n\t        DETACHEVENT = \"detachEvent\",\n\t        ADDEVENTLISTENER = \"addEventListener\",\n\t        DOMCONTENTLOADED = \"DOMContentLoaded\",\n\t        ONREADYSTATECHANGE = \"onreadystatechange\",\n\t        REMOVEEVENTLISTENER = \"removeEventListener\",\n\t    \n\t        // W3C Event model\n\t        w3c = ADDEVENTLISTENER in doc,\n\t        _top = FALSE,\n\t    \n\t        // isReady: Is the DOM ready to be used? Set to true once it occurs.\n\t        isReady = FALSE,\n\t    \n\t        // Callbacks pending execution until DOM is ready\n\t        callbacks = [];\n\t    \n\t    // Handle when the DOM is ready\n\t    function ready( fn ) {\n\t        if ( !isReady ) {\n\t    \n\t            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t            if ( !doc.body ) {\n\t                return defer( ready );\n\t            }\n\t    \n\t            // Remember that the DOM is ready\n\t            isReady = true;\n\t    \n\t            // Execute all callbacks\n\t            while ( fn = callbacks.shift() ) {\n\t                defer( fn );\n\t            }\n\t        }\n\t    }\n\t    \n\t    // The ready event handler\n\t    function completed( event ) {\n\t        // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t        if ( w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE ) {\n\t            detach();\n\t            ready();\n\t        }\n\t    }\n\t    \n\t    // Clean-up method for dom ready events\n\t    function detach() {\n\t        if ( w3c ) {\n\t            doc[REMOVEEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t            win[REMOVEEVENTLISTENER]( LOAD, completed, FALSE );\n\t        } else {\n\t            doc[DETACHEVENT]( ONREADYSTATECHANGE, completed );\n\t            win[DETACHEVENT]( ONLOAD, completed );\n\t        }\n\t    }\n\t    \n\t    // Defers a function, scheduling it to run after the current call stack has cleared.\n\t    function defer( fn, wait ) {\n\t        // Allow 0 to be passed\n\t        setTimeout( fn, +wait >= 0 ? wait : 1 );\n\t    }\n\t    \n\t    // Attach the listeners:\n\t    \n\t    // Catch cases where onDomReady is called after the browser event has already occurred.\n\t    // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t    if ( doc[READYSTATE] === COMPLETE ) {\n\t        // Handle it asynchronously to allow scripts the opportunity to delay ready\n\t        defer( ready );\n\t    \n\t    // Standards-based browsers support DOMContentLoaded\n\t    } else if ( w3c ) {\n\t        // Use the handy event callback\n\t        doc[ADDEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ADDEVENTLISTENER]( LOAD, completed, FALSE );\n\t    \n\t    // If IE event model is used\n\t    } else {\n\t        // Ensure firing before onload, maybe late but safe also for iframes\n\t        doc[ATTACHEVENT]( ONREADYSTATECHANGE, completed );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ATTACHEVENT]( ONLOAD, completed );\n\t    \n\t        // If IE and not a frame\n\t        // continually check to see if the document is ready\n\t        try {\n\t            _top = win.frameElement == null && docElem;\n\t        } catch(e) {}\n\t    \n\t        if ( _top && _top.doScroll ) {\n\t            (function doScrollCheck() {\n\t                if ( !isReady ) {\n\t                    try {\n\t                        // Use the trick by Diego Perini\n\t                        // http://javascript.nwbox.com/IEContentLoaded/\n\t                        _top.doScroll(\"left\");\n\t                    } catch(e) {\n\t                        return defer( doScrollCheck, 50 );\n\t                    }\n\t    \n\t                    // detach all dom ready events\n\t                    detach();\n\t    \n\t                    // and execute any waiting functions\n\t                    ready();\n\t                }\n\t            })();\n\t        }\n\t    }\n\t    \n\t    function onDomReady( fn ) {\n\t        // If DOM is ready, execute the function (async), otherwise wait\n\t        isReady ? defer( fn ) : callbacks.push( fn );\n\t    }\n\t    \n\t    // Add version\n\t    onDomReady.version = \"1.4.0\";\n\t    // Add method to check if DOM is ready\n\t    onDomReady.isReady = function(){\n\t        return isReady;\n\t    };\n\n\t    return onDomReady;\n\t}\n\n\tmodule.exports = typeof window !== \"undefined\" && _onDomReady(window);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Modified version of component/querystring\n\t//Changes: updated dependencies, dot notation parsing, JSHint fixes\n\t//Fork at https://github.com/imsky/querystring\n\n\t/**\n\t * Module dependencies.\n\t */\n\n\tvar encode = encodeURIComponent;\n\tvar decode = decodeURIComponent;\n\tvar trim = __webpack_require__(4);\n\tvar type = __webpack_require__(5);\n\n\tvar arrayRegex = /(\\w+)\\[(\\d+)\\]/;\n\tvar objectRegex = /\\w+\\.\\w+/;\n\n\t/**\n\t * Parse the given query `str`.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api public\n\t */\n\n\texports.parse = function(str){\n\t  if ('string' !== typeof str) return {};\n\n\t  str = trim(str);\n\t  if ('' === str) return {};\n\t  if ('?' === str.charAt(0)) str = str.slice(1);\n\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    var parts = pairs[i].split('=');\n\t    var key = decode(parts[0]);\n\t    var m, ctx, prop;\n\n\t    if (m = arrayRegex.exec(key)) {\n\t      obj[m[1]] = obj[m[1]] || [];\n\t      obj[m[1]][m[2]] = decode(parts[1]);\n\t      continue;\n\t    }\n\n\t    if (m = objectRegex.test(key)) {\n\t      m = key.split('.');\n\t      ctx = obj;\n\t      \n\t      while (m.length) {\n\t        prop = m.shift();\n\n\t        if (!prop.length) continue;\n\n\t        if (!ctx[prop]) {\n\t          ctx[prop] = {};\n\t        } else if (ctx[prop] && typeof ctx[prop] !== 'object') {\n\t          break;\n\t        }\n\n\t        if (!m.length) {\n\t          ctx[prop] = decode(parts[1]);\n\t        }\n\n\t        ctx = ctx[prop];\n\t      }\n\n\t      continue;\n\t    }\n\n\t    obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);\n\t  }\n\n\t  return obj;\n\t};\n\n\t/**\n\t * Stringify the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api public\n\t */\n\n\texports.stringify = function(obj){\n\t  if (!obj) return '';\n\t  var pairs = [];\n\n\t  for (var key in obj) {\n\t    var value = obj[key];\n\n\t    if ('array' == type(value)) {\n\t      for (var i = 0; i < value.length; ++i) {\n\t        pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));\n\t      }\n\t      continue;\n\t    }\n\n\t    pairs.push(encode(key) + '=' + encode(obj[key]));\n\t  }\n\n\t  return pairs.join('&');\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\n\texports = module.exports = trim;\n\n\tfunction trim(str){\n\t  return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\n\texports.left = function(str){\n\t  return str.replace(/^\\s*/, '');\n\t};\n\n\texports.right = function(str){\n\t  return str.replace(/\\s*$/, '');\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * toString ref.\n\t */\n\n\tvar toString = Object.prototype.toString;\n\n\t/**\n\t * Return the type of `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {String}\n\t * @api public\n\t */\n\n\tmodule.exports = function(val){\n\t  switch (toString.call(val)) {\n\t    case '[object Date]': return 'date';\n\t    case '[object RegExp]': return 'regexp';\n\t    case '[object Arguments]': return 'arguments';\n\t    case '[object Array]': return 'array';\n\t    case '[object Error]': return 'error';\n\t  }\n\n\t  if (val === null) return 'null';\n\t  if (val === undefined) return 'undefined';\n\t  if (val !== val) return 'nan';\n\t  if (val && val.nodeType === 1) return 'element';\n\n\t  if (isBuffer(val)) return 'buffer';\n\n\t  val = val.valueOf\n\t    ? val.valueOf()\n\t    : Object.prototype.valueOf.apply(val);\n\n\t  return typeof val;\n\t};\n\n\t// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js\n\tfunction isBuffer(obj) {\n\t  return !!(obj != null &&\n\t    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n\t      (obj.constructor &&\n\t      typeof obj.constructor.isBuffer === 'function' &&\n\t      obj.constructor.isBuffer(obj))\n\t    ))\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar SceneGraph = function(sceneProperties) {\n\t    var nodeCount = 1;\n\n\t    //todo: move merge to helpers section\n\t    function merge(parent, child) {\n\t        for (var prop in child) {\n\t            parent[prop] = child[prop];\n\t        }\n\t        return parent;\n\t    }\n\n\t    var SceneNode = function(name) {\n\t        nodeCount++;\n\t        this.parent = null;\n\t        this.children = {};\n\t        this.id = nodeCount;\n\t        this.name = 'n' + nodeCount;\n\t        if (typeof name !== 'undefined') {\n\t            this.name = name;\n\t        }\n\t        this.x = this.y = this.z = 0;\n\t        this.width = this.height = 0;\n\t    };\n\n\t    SceneNode.prototype.resize = function(width, height) {\n\t        if (width != null) {\n\t            this.width = width;\n\t        }\n\t        if (height != null) {\n\t            this.height = height;\n\t        }\n\t    };\n\n\t    SceneNode.prototype.moveTo = function(x, y, z) {\n\t        this.x = x != null ? x : this.x;\n\t        this.y = y != null ? y : this.y;\n\t        this.z = z != null ? z : this.z;\n\t    };\n\n\t    SceneNode.prototype.add = function(child) {\n\t        var name = child.name;\n\t        if (typeof this.children[name] === 'undefined') {\n\t            this.children[name] = child;\n\t            child.parent = this;\n\t        } else {\n\t            throw 'SceneGraph: child already exists: ' + name;\n\t        }\n\t    };\n\n\t    var RootNode = function() {\n\t        SceneNode.call(this, 'root');\n\t        this.properties = sceneProperties;\n\t    };\n\n\t    RootNode.prototype = new SceneNode();\n\n\t    var Shape = function(name, props) {\n\t        SceneNode.call(this, name);\n\t        this.properties = {\n\t            'fill': '#000000'\n\t        };\n\t        if (typeof props !== 'undefined') {\n\t            merge(this.properties, props);\n\t        } else if (typeof name !== 'undefined' && typeof name !== 'string') {\n\t            throw 'SceneGraph: invalid node name';\n\t        }\n\t    };\n\n\t    Shape.prototype = new SceneNode();\n\n\t    var Group = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'group';\n\t    };\n\n\t    Group.prototype = new Shape();\n\n\t    var Rect = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'rect';\n\t    };\n\n\t    Rect.prototype = new Shape();\n\n\t    var Text = function(text) {\n\t        Shape.call(this);\n\t        this.type = 'text';\n\t        this.properties.text = text;\n\t    };\n\n\t    Text.prototype = new Shape();\n\n\t    var root = new RootNode();\n\n\t    this.Shape = {\n\t        'Rect': Rect,\n\t        'Text': Text,\n\t        'Group': Group\n\t    };\n\n\t    this.root = root;\n\t    return this;\n\t};\n\n\tmodule.exports = SceneGraph;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Shallow object clone and merge\n\t *\n\t * @param a Object A\n\t * @param b Object B\n\t * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties\n\t */\n\texports.extend = function(a, b) {\n\t    var c = {};\n\t    for (var x in a) {\n\t        if (a.hasOwnProperty(x)) {\n\t            c[x] = a[x];\n\t        }\n\t    }\n\t    if (b != null) {\n\t        for (var y in b) {\n\t            if (b.hasOwnProperty(y)) {\n\t                c[y] = b[y];\n\t            }\n\t        }\n\t    }\n\t    return c;\n\t};\n\n\t/**\n\t * Takes a k/v list of CSS properties and returns a rule\n\t *\n\t * @param props CSS properties object\n\t */\n\texports.cssProps = function(props) {\n\t    var ret = [];\n\t    for (var p in props) {\n\t        if (props.hasOwnProperty(p)) {\n\t            ret.push(p + ':' + props[p]);\n\t        }\n\t    }\n\t    return ret.join(';');\n\t};\n\n\t/**\n\t * Encodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.encodeHtmlEntity = function(str) {\n\t    var buf = [];\n\t    var charCode = 0;\n\t    for (var i = str.length - 1; i >= 0; i--) {\n\t        charCode = str.charCodeAt(i);\n\t        if (charCode > 128) {\n\t            buf.unshift(['&#', charCode, ';'].join(''));\n\t        } else {\n\t            buf.unshift(str[i]);\n\t        }\n\t    }\n\t    return buf.join('');\n\t};\n\n\t/**\n\t * Checks if an image exists\n\t *\n\t * @param src URL of image\n\t * @param callback Callback to call once image status has been found\n\t */\n\texports.imageExists = function(src, callback) {\n\t    var image = new Image();\n\t    image.onerror = function() {\n\t        callback.call(this, false);\n\t    };\n\t    image.onload = function() {\n\t        callback.call(this, true);\n\t    };\n\t    image.src = src;\n\t};\n\n\t/**\n\t * Decodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.decodeHtmlEntity = function(str) {\n\t    return str.replace(/&#(\\d+);/g, function(match, dec) {\n\t        return String.fromCharCode(dec);\n\t    });\n\t};\n\n\n\t/**\n\t * Returns an element's dimensions if it's visible, `false` otherwise.\n\t *\n\t * @param el DOM element\n\t */\n\texports.dimensionCheck = function(el) {\n\t    var dimensions = {\n\t        height: el.clientHeight,\n\t        width: el.clientWidth\n\t    };\n\n\t    if (dimensions.height && dimensions.width) {\n\t        return dimensions;\n\t    } else {\n\t        return false;\n\t    }\n\t};\n\n\n\t/**\n\t * Returns true if value is truthy or if it is \"semantically truthy\"\n\t * @param val\n\t */\n\texports.truthy = function(val) {\n\t    if (typeof val === 'string') {\n\t        return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === '✓';\n\t    }\n\t    return !!val;\n\t};\n\n\t/**\n\t * Parses input into a well-formed CSS color\n\t * @param val\n\t */\n\texports.parseColor = function(val) {\n\t    var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;\n\t    var rgbre = /^rgb\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\n\t    var rgbare = /^rgba\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(0\\.\\d{1,}|1)\\)$/;\n\n\t    var match = val.match(hexre);\n\t    var retval;\n\n\t    if (match !== null) {\n\t        retval = match[1] || match[2];\n\t        if (retval[0] !== '#') {\n\t            return '#' + retval;\n\t        } else {\n\t            return retval;\n\t        }\n\t    }\n\n\t    match = val.match(rgbre);\n\n\t    if (match !== null) {\n\t        retval = 'rgb(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    match = val.match(rgbare);\n\n\t    if (match !== null) {\n\t        retval = 'rgba(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    return null;\n\t};\n\n\t/**\n\t * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)\n\t */\n\texports.canvasRatio = function () {\n\t    var devicePixelRatio = 1;\n\t    var backingStoreRatio = 1;\n\n\t    if (global.document) {\n\t        var canvas = global.document.createElement('canvas');\n\t        if (canvas.getContext) {\n\t            var ctx = canvas.getContext('2d');\n\t            devicePixelRatio = global.devicePixelRatio || 1;\n\t            backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n\t        }\n\t    }\n\n\t    return devicePixelRatio / backingStoreRatio;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var DOM = __webpack_require__(9);\n\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\tvar NODE_TYPE_COMMENT = 8;\n\n\t/**\n\t * Generic SVG element creation function\n\t *\n\t * @param svg SVG context, set to null if new\n\t * @param width Document width\n\t * @param height Document height\n\t */\n\texports.initSVG = function(svg, width, height) {\n\t    var defs, style, initialize = false;\n\n\t    if (svg && svg.querySelector) {\n\t        style = svg.querySelector('style');\n\t        if (style === null) {\n\t            initialize = true;\n\t        }\n\t    } else {\n\t        svg = DOM.newEl('svg', SVG_NS);\n\t        initialize = true;\n\t    }\n\n\t    if (initialize) {\n\t        defs = DOM.newEl('defs', SVG_NS);\n\t        style = DOM.newEl('style', SVG_NS);\n\t        DOM.setAttr(style, {\n\t            'type': 'text/css'\n\t        });\n\t        defs.appendChild(style);\n\t        svg.appendChild(defs);\n\t    }\n\n\t    //IE throws an exception if this is set and Chrome requires it to be set\n\t    if (svg.webkitMatchesSelector) {\n\t        svg.setAttribute('xmlns', SVG_NS);\n\t    }\n\n\t    //Remove comment nodes\n\t    for (var i = 0; i < svg.childNodes.length; i++) {\n\t        if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {\n\t            svg.removeChild(svg.childNodes[i]);\n\t        }\n\t    }\n\n\t    //Remove CSS\n\t    while (style.childNodes.length) {\n\t        style.removeChild(style.childNodes[0]);\n\t    }\n\n\t    DOM.setAttr(svg, {\n\t        'width': width,\n\t        'height': height,\n\t        'viewBox': '0 0 ' + width + ' ' + height,\n\t        'preserveAspectRatio': 'none'\n\t    });\n\n\t    return svg;\n\t};\n\n\t/**\n\t * Converts serialized SVG to a string suitable for data URI use\n\t * @param svgString Serialized SVG string\n\t * @param [base64] Use base64 encoding for data URI\n\t */\n\texports.svgStringToDataURI = function() {\n\t    var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';\n\t    var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';\n\n\t    return function(svgString, base64) {\n\t        if (base64) {\n\t            return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));\n\t        } else {\n\t            return rawPrefix + encodeURIComponent(svgString);\n\t        }\n\t    };\n\t}();\n\n\t/**\n\t * Returns serialized SVG with XML processing instructions\n\t *\n\t * @param svg SVG context\n\t * @param stylesheets CSS stylesheets to include\n\t */\n\texports.serializeSVG = function(svg, engineSettings) {\n\t    if (!global.XMLSerializer) return;\n\t    var serializer = new XMLSerializer();\n\t    var svgCSS = '';\n\t    var stylesheets = engineSettings.stylesheets;\n\n\t    //External stylesheets: Processing Instruction method\n\t    if (engineSettings.svgXMLStylesheet) {\n\t        var xml = DOM.createXML();\n\t        //Add <?xml-stylesheet ?> directives\n\t        for (var i = stylesheets.length - 1; i >= 0; i--) {\n\t            var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href=\"' + stylesheets[i] + '\" rel=\"stylesheet\"');\n\t            xml.insertBefore(csspi, xml.firstChild);\n\t        }\n\n\t        xml.removeChild(xml.documentElement);\n\t        svgCSS = serializer.serializeToString(xml);\n\t    }\n\n\t    var svgText = serializer.serializeToString(svg);\n\t    svgText = svgText.replace(/\\&amp;(\\#[0-9]{2,}\\;)/g, '&$1');\n\t    return svgCSS + svgText;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Generic new DOM element function\n\t *\n\t * @param tag Tag to create\n\t * @param namespace Optional namespace value\n\t */\n\texports.newEl = function(tag, namespace) {\n\t    if (!global.document) return;\n\n\t    if (namespace == null) {\n\t        return global.document.createElement(tag);\n\t    } else {\n\t        return global.document.createElementNS(namespace, tag);\n\t    }\n\t};\n\n\t/**\n\t * Generic setAttribute function\n\t *\n\t * @param el Reference to DOM element\n\t * @param attrs Object with attribute keys and values\n\t */\n\texports.setAttr = function (el, attrs) {\n\t    for (var a in attrs) {\n\t        el.setAttribute(a, attrs[a]);\n\t    }\n\t};\n\n\t/**\n\t * Creates a XML document\n\t * @private\n\t */\n\texports.createXML = function() {\n\t    if (!global.DOMParser) return;\n\t    return new DOMParser().parseFromString('<xml />', 'application/xml');\n\t};\n\n\t/**\n\t * Converts a value into an array of DOM nodes\n\t *\n\t * @param val A string, a NodeList, a Node, or an HTMLCollection\n\t */\n\texports.getNodeArray = function(val) {\n\t    var retval = null;\n\t    if (typeof(val) == 'string') {\n\t        retval = document.querySelectorAll(val);\n\t    } else if (global.NodeList && val instanceof global.NodeList) {\n\t        retval = val;\n\t    } else if (global.Node && val instanceof global.Node) {\n\t        retval = [val];\n\t    } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {\n\t        retval = val;\n\t    } else if (val instanceof Array) {\n\t        retval = val;\n\t    } else if (val === null) {\n\t        retval = [];\n\t    }\n\n\t    retval = Array.prototype.slice.call(retval);\n\n\t    return retval;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar Color = function(color, options) {\n\t    //todo: support rgba, hsla, and rrggbbaa notation\n\t    //todo: use CIELAB internally\n\t    //todo: add clamp function (with sign)\n\t    if (typeof color !== 'string') return;\n\n\t    this.original = color;\n\n\t    if (color.charAt(0) === '#') {\n\t        color = color.slice(1);\n\t    }\n\n\t    if (/[^a-f0-9]+/i.test(color)) return;\n\n\t    if (color.length === 3) {\n\t        color = color.replace(/./g, '$&$&');\n\t    }\n\n\t    if (color.length !== 6) return;\n\n\t    this.alpha = 1;\n\n\t    if (options && options.alpha) {\n\t        this.alpha = options.alpha;\n\t    }\n\n\t    this.set(parseInt(color, 16));\n\t};\n\n\t//todo: jsdocs\n\tColor.rgb2hex = function(r, g, b) {\n\t    function format (decimal) {\n\t        var hex = (decimal | 0).toString(16);\n\t        if (decimal < 16) {\n\t            hex = '0' + hex;\n\t        }\n\t        return hex;\n\t    }\n\n\t    return [r, g, b].map(format).join('');\n\t};\n\n\t//todo: jsdocs\n\tColor.hsl2rgb = function (h, s, l) {\n\t    var H = h / 60;\n\t    var C = (1 - Math.abs(2 * l - 1)) * s;\n\t    var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));\n\t    var m = l - (C / 2);\n\n\t    var r = 0, g = 0, b = 0;\n\n\t    if (H >= 0 && H < 1) {\n\t        r = C;\n\t        g = X;\n\t    } else if (H >= 1 && H < 2) {\n\t        r = X;\n\t        g = C;\n\t    } else if (H >= 2 && H < 3) {\n\t        g = C;\n\t        b = X;\n\t    } else if (H >= 3 && H < 4) {\n\t        g = X;\n\t        b = C;\n\t    } else if (H >= 4 && H < 5) {\n\t        r = X;\n\t        b = C;\n\t    } else if (H >= 5 && H < 6) {\n\t        r = C;\n\t        b = X;\n\t    }\n\n\t    r += m;\n\t    g += m;\n\t    b += m;\n\n\t    r = parseInt(r * 255);\n\t    g = parseInt(g * 255);\n\t    b = parseInt(b * 255);\n\n\t    return [r, g, b];\n\t};\n\n\t/**\n\t * Sets the color from a raw RGB888 integer\n\t * @param raw RGB888 representation of color\n\t */\n\t//todo: refactor into a static method\n\t//todo: factor out individual color spaces\n\t//todo: add HSL, CIELAB, and CIELUV\n\tColor.prototype.set = function (val) {\n\t    this.raw = val;\n\n\t    var r = (this.raw & 0xFF0000) >> 16;\n\t    var g = (this.raw & 0x00FF00) >> 8;\n\t    var b = (this.raw & 0x0000FF);\n\n\t    // BT.709\n\t    var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\t    var u = -0.09991 * r - 0.33609 * g + 0.436 * b;\n\t    var v = 0.615 * r - 0.55861 * g - 0.05639 * b;\n\n\t    this.rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b\n\t    };\n\n\t    this.yuv = {\n\t        y: y,\n\t        u: u,\n\t        v: v\n\t    };\n\n\t    return this;\n\t};\n\n\t/**\n\t * Lighten or darken a color\n\t * @param multiplier Amount to lighten or darken (-1 to 1)\n\t */\n\tColor.prototype.lighten = function(multiplier) {\n\t    var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);\n\t    var bm = (255 * cm) | 0;\n\t    var cr = Math.min(255, Math.max(0, this.rgb.r + bm));\n\t    var cg = Math.min(255, Math.max(0, this.rgb.g + bm));\n\t    var cb = Math.min(255, Math.max(0, this.rgb.b + bm));\n\t    var hex = Color.rgb2hex(cr, cg, cb);\n\t    return new Color(hex);\n\t};\n\n\t/**\n\t * Output color in hex format\n\t * @param addHash Add a hash character to the beginning of the output\n\t */\n\tColor.prototype.toHex = function(addHash) {\n\t    return (addHash ? '#' : '') + this.raw.toString(16);\n\t};\n\n\t/**\n\t * Returns whether or not current color is lighter than another color\n\t * @param color Color to compare against\n\t */\n\tColor.prototype.lighterThan = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    return this.yuv.y > color.yuv.y;\n\t};\n\n\t/**\n\t * Returns the result of mixing current color with another color\n\t * @param color Color to mix with\n\t * @param multiplier How much to mix with the other color\n\t */\n\t/*\n\tColor.prototype.mix = function (color, multiplier) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var r = this.rgb.r;\n\t    var g = this.rgb.g;\n\t    var b = this.rgb.b;\n\t    var a = this.alpha;\n\n\t    var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;\n\n\t    //todo: write a lerp function\n\t    r = r + m * (color.rgb.r - r);\n\t    g = g + m * (color.rgb.g - g);\n\t    b = b + m * (color.rgb.b - b);\n\t    a = a + m * (color.alpha - a);\n\n\t    return new Color(Color.rgbToHex(r, g, b), {\n\t        'alpha': a\n\t    });\n\t};\n\t*/\n\n\t/**\n\t * Returns the result of blending another color on top of current color with alpha\n\t * @param color Color to blend on top of current color, i.e. \"Ca\"\n\t */\n\t//todo: see if .blendAlpha can be merged into .mix\n\tColor.prototype.blendAlpha = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var Ca = color;\n\t    var Cb = this;\n\n\t    //todo: write alpha blending function\n\t    var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;\n\t    var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;\n\t    var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;\n\n\t    return new Color(Color.rgb2hex(r, g, b));\n\t};\n\n\tmodule.exports = Color;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t  'version': '2.9.4',\n\t  'svg_ns': 'http://www.w3.org/2000/svg'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shaven = __webpack_require__(13);\n\n\tvar SVG = __webpack_require__(8);\n\tvar constants = __webpack_require__(11);\n\tvar utils = __webpack_require__(7);\n\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar templates = {\n\t  'element': function (options) {\n\t    var tag = options.tag;\n\t    var content = options.content || '';\n\t    delete options.tag;\n\t    delete options.content;\n\t    return  [tag, content, options];\n\t  }\n\t};\n\n\t//todo: deprecate tag arg, infer tag from shape object\n\tfunction convertShape (shape, tag) {\n\t  return templates.element({\n\t    'tag': tag,\n\t    'width': shape.width,\n\t    'height': shape.height,\n\t    'fill': shape.properties.fill\n\t  });\n\t}\n\n\tfunction textCss (properties) {\n\t  return utils.cssProps({\n\t    'fill': properties.fill,\n\t    'font-weight': properties.font.weight,\n\t    'font-family': properties.font.family + ', monospace',\n\t    'font-size': properties.font.size + properties.font.units\n\t  });\n\t}\n\n\tfunction outlinePath (bgWidth, bgHeight, outlineWidth) {\n\t  var outlineOffsetWidth = outlineWidth / 2;\n\n\t  return [\n\t    'M', outlineOffsetWidth, outlineOffsetWidth,\n\t    'H', bgWidth - outlineOffsetWidth,\n\t    'V', bgHeight - outlineOffsetWidth,\n\t    'H', outlineOffsetWidth,\n\t    'V', 0,\n\t    'M', 0, outlineOffsetWidth,\n\t    'L', bgWidth, bgHeight - outlineOffsetWidth,\n\t    'M', 0, bgHeight - outlineOffsetWidth,\n\t    'L', bgWidth, outlineOffsetWidth\n\t  ].join(' ');\n\t}\n\n\tmodule.exports = function (sceneGraph, renderSettings) {\n\t  var engineSettings = renderSettings.engineSettings;\n\t  var stylesheets = engineSettings.stylesheets;\n\t  var stylesheetXml = stylesheets.map(function (stylesheet) {\n\t    return '<?xml-stylesheet rel=\"stylesheet\" href=\"' + stylesheet + '\"?>';\n\t  }).join('\\n');\n\n\t  var holderId = 'holder_' + Number(new Date()).toString(16);\n\n\t  var root = sceneGraph.root;\n\t  var textGroup = root.children.holderTextGroup;\n\n\t  var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } ';\n\n\t  // push text down to be equally vertically aligned with canvas renderer\n\t  textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;\n\n\t  var wordTags = [];\n\n\t  Object.keys(textGroup.children).forEach(function (lineKey) {\n\t    var line = textGroup.children[lineKey];\n\n\t    Object.keys(line.children).forEach(function (wordKey) {\n\t      var word = line.children[wordKey];\n\t      var x = textGroup.x + line.x + word.x;\n\t      var y = textGroup.y + line.y + word.y;\n\n\t      var wordTag = templates.element({\n\t        'tag': 'text',\n\t        'content': word.properties.text,\n\t        'x': x,\n\t        'y': y\n\t      });\n\n\t      wordTags.push(wordTag);\n\t    });\n\t  });\n\n\t  var text = templates.element({\n\t    'tag': 'g',\n\t    'content': wordTags\n\t  });\n\n\t  var outline = null;\n\n\t  if (root.children.holderBg.properties.outline) {\n\t    var outlineProperties = root.children.holderBg.properties.outline;\n\t    outline = templates.element({\n\t      'tag': 'path',\n\t      'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),\n\t      'stroke-width': outlineProperties.width,\n\t      'stroke': outlineProperties.fill,\n\t      'fill': 'none'\n\t    });\n\t  }\n\n\t  var bg = convertShape(root.children.holderBg, 'rect');\n\n\t  var sceneContent = [];\n\n\t  sceneContent.push(bg);\n\t  if (outlineProperties) {\n\t    sceneContent.push(outline);\n\t  }\n\t  sceneContent.push(text);\n\n\t  var scene = templates.element({\n\t    'tag': 'g',\n\t    'id': holderId,\n\t    'content': sceneContent\n\t  });\n\n\t  var style = templates.element({\n\t    'tag': 'style',\n\t    //todo: figure out how to add CDATA directive\n\t    'content': css,\n\t    'type': 'text/css'\n\t  });\n\n\t  var defs = templates.element({\n\t    'tag': 'defs',\n\t    'content': style\n\t  });\n\n\t  var svg = templates.element({\n\t    'tag': 'svg',\n\t    'content': [defs, scene],\n\t    'width': root.properties.width,\n\t    'height': root.properties.height,\n\t    'xmlns': SVG_NS,\n\t    'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),\n\t    'preserveAspectRatio': 'none'\n\t  });\n\n\t  var output = shaven(svg);\n\t  \n\t  output = stylesheetXml + output[0];\n\n\t  var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');\n\t  return svgString;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar escape = __webpack_require__(14)\n\n\t// TODO: remove namespace\n\n\tmodule.exports = function shaven (array, namespace, returnObject) {\n\n\t\t'use strict'\n\n\t\tvar i = 1\n\t\tvar doesEscape = true\n\t\tvar HTMLString\n\t\tvar attributeKey\n\t\tvar callback\n\t\tvar key\n\n\n\t\treturnObject = returnObject || {}\n\n\n\t\tfunction createElement (sugarString) {\n\n\t\t\tvar tags = sugarString.match(/^[\\w-]+/)\n\t\t\tvar element = {\n\t\t\t\ttag: tags ? tags[0] : 'div',\n\t\t\t\tattr: {},\n\t\t\t\tchildren: []\n\t\t\t}\n\t\t\tvar id = sugarString.match(/#([\\w-]+)/)\n\t\t\tvar reference = sugarString.match(/\\$([\\w-]+)/)\n\t\t\tvar classNames = sugarString.match(/\\.[\\w-]+/g)\n\n\n\t\t\t// Assign id if is set\n\t\t\tif (id) {\n\t\t\t\telement.attr.id = id[1]\n\n\t\t\t\t// Add element to the return object\n\t\t\t\treturnObject[id[1]] = element\n\t\t\t}\n\n\t\t\tif (reference)\n\t\t\t\treturnObject[reference[1]] = element\n\n\t\t\tif (classNames)\n\t\t\t\telement.attr.class = classNames.join(' ').replace(/\\./g, '')\n\n\t\t\tif (sugarString.match(/&$/g))\n\t\t\t\tdoesEscape = false\n\n\t\t\treturn element\n\t\t}\n\n\t\tfunction replacer (key, value) {\n\n\t\t\tif (value === null || value === false || value === undefined)\n\t\t\t\treturn\n\n\t\t\tif (typeof value !== 'string' && typeof value !== 'object')\n\t\t\t\treturn String(value)\n\n\t\t\treturn value\n\t\t}\n\n\t\tfunction escapeAttribute (string) {\n\t\t\treturn (string || string === 0) ?\n\t\t\t\tString(string)\n\t\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t\t.replace(/\"/g, '&quot;') :\n\t\t\t\t''\n\t\t}\n\n\t\tfunction escapeHTML (string) {\n\t\t\treturn String(string)\n\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t\t.replace(/'/g, '&apos;')\n\t\t\t\t.replace(/</g, '&lt;')\n\t\t\t\t.replace(/>/g, '&gt;')\n\t\t}\n\n\n\t\tif (typeof array[0] === 'string')\n\t\t\tarray[0] = createElement(array[0])\n\n\t\telse if (Array.isArray(array[0]))\n\t\t\ti = 0\n\n\t\telse\n\t\t\tthrow new Error(\n\t\t\t\t'First element of array must be a string, ' +\n\t\t\t\t'or an array and not ' + JSON.stringify(array[0])\n\t\t\t)\n\n\n\t\tfor (; i < array.length; i++) {\n\n\t\t\t// Don't render element if value is false or null\n\t\t\tif (array[i] === false || array[i] === null) {\n\t\t\t\tarray[0] = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Continue with next array value if current value is undefined or true\n\t\t\telse if (array[i] === undefined || array[i] === true) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'string') {\n\t\t\t\tif (doesEscape)\n\t\t\t\t\tarray[i] = escapeHTML(array[i])\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'number') {\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (Array.isArray(array[i])) {\n\n\t\t\t\tif (Array.isArray(array[i][0])) {\n\t\t\t\t\tarray[i].reverse().forEach(function (subArray) {\n\t\t\t\t\t\tarray.splice(i + 1, 0, subArray)\n\t\t\t\t\t})\n\n\t\t\t\t\tif (i !== 0)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\ti++\n\t\t\t\t}\n\n\t\t\t\tshaven(array[i], namespace, returnObject)\n\n\t\t\t\tif (array[i][0])\n\t\t\t\t\tarray[0].children.push(array[i][0])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'function')\n\t\t\t\tcallback = array[i]\n\n\n\t\t\telse if (typeof array[i] === 'object') {\n\t\t\t\tfor (attributeKey in array[i])\n\t\t\t\t\tif (array[i].hasOwnProperty(attributeKey))\n\t\t\t\t\t\tif (array[i][attributeKey] !== null &&\n\t\t\t\t\t\t\tarray[i][attributeKey] !== false)\n\t\t\t\t\t\t\tif (attributeKey === 'style' &&\n\t\t\t\t\t\t\t\ttypeof array[i][attributeKey] === 'object')\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = JSON\n\t\t\t\t\t\t\t\t\t.stringify(array[i][attributeKey], replacer)\n\t\t\t\t\t\t\t\t\t.slice(2, -2)\n\t\t\t\t\t\t\t\t\t.replace(/\",\"/g, ';')\n\t\t\t\t\t\t\t\t\t.replace(/\":\"/g, ':')\n\t\t\t\t\t\t\t\t\t.replace(/\\\\\"/g, '\\'')\n\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = array[i][attributeKey]\n\t\t\t}\n\n\t\t\telse\n\t\t\t\tthrow new TypeError('\"' + array[i] + '\" is not allowed as a value.')\n\t\t}\n\n\n\t\tif (array[0] !== false) {\n\n\t\t\tHTMLString = '<' + array[0].tag\n\n\t\t\tfor (key in array[0].attr)\n\t\t\t\tif (array[0].attr.hasOwnProperty(key))\n\t\t\t\t\tHTMLString += ' ' + key + '=\"' +\n\t\t\t\t\t\tescapeAttribute(array[0].attr[key]) + '\"'\n\n\t\t\tHTMLString += '>'\n\n\t\t\tarray[0].children.forEach(function (child) {\n\t\t\t\tHTMLString += child\n\t\t\t})\n\n\t\t\tHTMLString += '</' + array[0].tag + '>'\n\n\t\t\tarray[0] = HTMLString\n\t\t}\n\n\t\t// Return root element on index 0\n\t\treturnObject[0] = array[0]\n\n\t\tif (callback)\n\t\t\tcallback(array[0])\n\n\t\t// returns object containing all elements with an id and the root element\n\t\treturn returnObject\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\n\t'use strict';\n\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\n\tmodule.exports = escapeHtml;\n\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\n\t  if (!match) {\n\t    return str;\n\t  }\n\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DOM = __webpack_require__(9);\n\tvar utils = __webpack_require__(7);\n\n\tmodule.exports = (function() {\n\t    var canvas = DOM.newEl('canvas');\n\t    var ctx = null;\n\n\t    return function(sceneGraph) {\n\t        if (ctx == null) {\n\t            ctx = canvas.getContext('2d');\n\t        }\n\n\t        var dpr = utils.canvasRatio();\n\t        var root = sceneGraph.root;\n\t        canvas.width = dpr * root.properties.width;\n\t        canvas.height = dpr * root.properties.height ;\n\t        ctx.textBaseline = 'middle';\n\n\t        var bg = root.children.holderBg;\n\t        var bgWidth = dpr * bg.width;\n\t        var bgHeight = dpr * bg.height;\n\t        //todo: parametrize outline width (e.g. in scene object)\n\t        var outlineWidth = 2;\n\t        var outlineOffsetWidth = outlineWidth / 2;\n\n\t        ctx.fillStyle = bg.properties.fill;\n\t        ctx.fillRect(0, 0, bgWidth, bgHeight);\n\n\t        if (bg.properties.outline) {\n\t            //todo: abstract this into a method\n\t            ctx.strokeStyle = bg.properties.outline.fill;\n\t            ctx.lineWidth = bg.properties.outline.width;\n\t            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // TL, TR, BR, BL\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // Diagonals\n\t            ctx.moveTo(0, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.moveTo(0, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, outlineOffsetWidth);\n\t            ctx.stroke();\n\t        }\n\n\t        var textGroup = root.children.holderTextGroup;\n\t        ctx.font = textGroup.properties.font.weight + ' ' + (dpr * textGroup.properties.font.size) + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';\n\t        ctx.fillStyle = textGroup.properties.fill;\n\n\t        for (var lineKey in textGroup.children) {\n\t            var line = textGroup.children[lineKey];\n\t            for (var wordKey in line.children) {\n\t                var word = line.children[wordKey];\n\t                var x = dpr * (textGroup.x + line.x + word.x);\n\t                var y = dpr * (textGroup.y + line.y + word.y + (textGroup.properties.leading / 2));\n\n\t                ctx.fillText(word.properties.text, x, y);\n\t            }\n\t        }\n\n\t        return canvas.toDataURL('image/png');\n\t    };\n\t})();\n\n/***/ }\n/******/ ])\n});\n;\n(function(ctx, isMeteorPackage) {\n    if (isMeteorPackage) {\n        Holder = ctx.Holder;\n    }\n})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return buildOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getI18n; });\n/**\n * 文件容量转换具体的bytes数值\n * @param fileSize 参数类型（String），例：2MB，230KB，1TB等\n * @param thousand 参数类型（boolean），是否以1000为计算单位，否则以默认的1024为计算单位\n */\nvar fileSize2Bytes = function fileSize2Bytes(fileSize, thousand) {\n    if (!fileSize) return null;\n    var baseUnit = thousand ? 1000 : 1024;\n    var kb = baseUnit,\n        mb = kb * baseUnit,\n        gb = mb * baseUnit;\n    var tmpCode = fileSize.substring(fileSize.length - 2).toUpperCase();\n    var sizeNumber = fileSize.substring(0, fileSize.length - 2);\n    var num = Number.parseInt(sizeNumber);\n    var result = 0;\n    switch (tmpCode) {\n        case 'KB':\n            result = num * kb;\n            break;\n        case 'MB':\n            result = num * mb;\n            break;\n        case 'GB':\n            result = num * gb;\n            break;\n    }\n    return result;\n};\n\nvar i18n = {\n    cn: {\n        messages: {\n            'typeError': \"{file} 文件格式不正确。有效格式： {extensions}\",\n            'sizeError': \"{file} 文件容量超过限制, 文件最大容量为： {sizeLimit}\",\n            'minSizeError': \"{file} 文件容量低于限制, 上传的文件最小容量为： {minSizeLimit}.\",\n            'emptyError': \"{file} 文件为空，请选择其他文件进行上传。\",\n            'noFilesError': \"未选择任何文件进行上传\",\n            'tooManyItemsError': \"太多文件 ({netItems}) 需要被上传，上传文件数量限制为： {itemLimit}个\",\n            'maxHeightImageError': \"图片高度超过限制\",\n            'maxWidthImageError': \"图片宽度超过限制\",\n            'minHeightImageError': \"图片高度不足\",\n            'minWidthImageError': \"图片宽度不足\",\n            'retryFailTooManyItems': \"重试失败 - 您已达到文件数量上限。\",\n            'onLeave': \"文件正在上传，若离开该页面，正在上传的文件将被取消\"\n        },\n        text: {\n            'failUpload': '上传失败',\n            'fileInputTitle': '选择文件进行上传'\n        },\n        ui: {\n            thumbnail: '图片预览',\n            choseFileButton: '选择文件',\n            dropHere: '将文件拖到这里进行上传……',\n            done: '完成',\n            fileTypes: '文件类型',\n            fileSizeLimit: '文件容量限制'\n        }\n\n    },\n    vi: {\n        messages: {\n            'typeError': \"{file} Định dạng tệp không chính xác. Định dạng hợp lệ: {extensions}\",\n            'sizeError': \"{file} Dung lượng tệp vượt quá giới hạn và kích thước tệp tối đa là: {sizeLimit}\",\n            'minSizeError': \"{file} Kích thước tệp dưới giới hạn và kích thước tệp tối thiểu để tải lên là: {minSizeLimit}.\",\n            'emptyError': \"{file} Tệp này trống. Vui lòng chọn một tệp khác để tải lên.\",\n            'noFilesError': \"Không có tệp nào được chọn để tải lên\",\n            'tooManyItemsError': \"Quá nhiều tệp ({netItems}) được tải lên, số lượng tệp tải lên được giới hạn trong: {itemLimit}个\",\n            'maxHeightImageError': \"Chiều cao hình ảnh vượt quá giới hạn\",\n            'maxWidthImageError': \"Chiều rộng hình ảnh vượt quá giới hạn\",\n            'minHeightImageError': \"Chiều cao hình ảnh quá nhỏ\",\n            'minWidthImageError': \"Chiều rộng hình ảnh quá nhỏ\",\n            'retryFailTooManyItems': \"Thử lại không thành công - Bạn đã đạt đến số lượng tệp tối đa.\",\n            'onLeave': \"Tệp đang được tải lên. Nếu bạn rời khỏi trang, tệp đang được tải lên sẽ bị hủy.\"\n        },\n        text: {\n            'failUpload': 'Tải lên không thành công',\n            'fileInputTitle': 'Chọn tệp để tải lên'\n        },\n        ui: {\n            thumbnail: 'Xem trước hình ảnh',\n            choseFileButton: 'Chọn tệp',\n            dropHere: 'Kéo tệp vào đây để tải lên...',\n            done: 'Hoàn thành',\n            fileTypes: 'Loại tệp',\n            fileSizeLimit: 'Giới hạn kích thước tệp'\n        }\n\n    },\n    en: {\n        ui: {\n            thumbnail: 'thumbnail',\n            choseFileButton: 'select file',\n            dropHere: 'drop files here',\n            done: 'done',\n            fileTypes: 'file extensions',\n            fileSizeLimit: 'file size limit'\n        }\n    }\n};\n\nvar buildOptions = function buildOptions() {\n    var _this = this;\n\n    var p = {\n        multiple: this.multiple,\n        request: {\n            endpoint: this.uploadFileUrl,\n            inputName: this.uploadFileObjName,\n            //server side validate file info\n            params: {\n                'fileSizeLimit': this.fileSizeLimit,\n                'fileTypeExts': this.fileTypeExts\n            }\n        },\n        deleteFile: {\n            enabled: true,\n            method: \"POST\" //,\n            //'endpoint' : $webroot + 'upload/deleteUploadFile'\n        },\n        debug: true,\n        validation: {\n            allowedExtensions: this.fileTypeExts.split(','),\n            sizeLimit: fileSize2Bytes(this.fileSizeLimit, true),\n            sizeLimitStr: this.fileSizeLimit,\n            image: {\n                maxHeight: this.imageMaxHeight,\n                maxWidth: this.imageMaxWidth,\n                minHeight: this.imageMinHeight,\n                minWidth: this.imageMinWidth\n            }\n        },\n        callbacks: {\n            //the callback when file upload finish\n            onComplete: function onComplete(id, name, json, xhr) {},\n            //the callback before delete file, return false can stop it.\n            onSubmitDelete: function onSubmitDelete(id) {}\n        }\n    };\n    if (this.language && this.language === 'vi') {\n        p.messages = i18n.vi.messages;\n        p.text = i18n.vi.text;\n    }\n    if (this.callback && typeof this.callback === 'function') {\n        p.callbacks.onComplete = function (id, name, json, xhr) {\n            if (json) _this.callback(json);\n        };\n    }\n    return p;\n};\n\nvar getI18n = function getI18n(language) {\n    return !language || language !== 'en' ? i18n.vi.ui : i18n.en.ui;\n};\n\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:[_vm.uploaderClass]},[(!_vm.multiple)?_c('div',{staticClass:\"single-upload\"},[(_vm.preview)?_c('div',{staticClass:\"image-box\"},[_c('img',{ref:\"simpleImg\",attrs:{\"src\":_vm.singleUploadImg,\"alt\":\"\",\"width\":_vm.previewWidth,\"height\":_vm.previewHeight}})]):_vm._e(),_vm._v(\" \"),_c('div',{ref:\"upload\",staticClass:\"btn singleFileUpload uploader-button\"},[(_vm.buttonIcon)?_c('i',{staticClass:\"fi-camera\"}):_vm._e(),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(_vm.buttonText?_vm.buttonText:_vm.ui.choseFileButton))])])]):_vm._e(),_vm._v(\" \"),(_vm.multiple)?_c('div',{ref:\"multipleUpload\",staticClass:\"upload-list\"}):_vm._e(),_vm._v(\" \"),(_vm.multiple)?_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(false),expression:\"false\"}],ref:\"uploadArea\"},[_c('div',{staticClass:\"qq-uploader-selector qq-uploader qq-gallery\",staticStyle:{\"height\":\"100%\"},attrs:{\"qq-drop-area-text\":_vm.ui.dropHere}},[_vm._m(0),_vm._v(\" \"),_vm._m(1),_vm._v(\" \"),_c('div',{staticClass:\"qq-upload-button-selector qq-upload-button uploader-button\"},[_c('div',[(_vm.buttonIcon)?_c('i',{staticClass:\"fi-camera v-upload-iconfont icon-uploader-open\"}):_vm._e(),_vm._v(\"\\n                    \"+_vm._s(_vm.buttonText?_vm.buttonText:_vm.ui.choseFileButton)+\"\\n                \")])]),_vm._v(\" \"),_c('div',{staticClass:\"info-show\"},[_c('div',[_vm._v(\"\\n                    \"+_vm._s(_vm.ui.fileSizeLimit)+\"：\"),_c('span',{domProps:{\"textContent\":_vm._s(_vm.fileSizeLimit)}}),_c('br'),_vm._v(\"\\n                    \"+_vm._s(_vm.ui.fileTypes)+\"：\"),_c('span',{domProps:{\"textContent\":_vm._s(_vm.fileTypeExts)}})])]),_vm._v(\" \"),_vm._m(2)])]):_vm._e()])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:\"qq-upload-list-selector qq-upload-list grid-x grid-padding-x\",attrs:{\"role\":\"region\",\"aria-live\":\"polite\",\"aria-relevant\":\"additions removals\"}},[_c('li',[_c('span',{staticClass:\"qq-upload-status-text-selector qq-upload-status-text\",attrs:{\"role\":\"status\"}}),_vm._v(\" \"),_c('div',{staticClass:\"qq-progress-bar-container-selector qq-progress-bar-container\"},[_c('div',{staticClass:\"qq-progress-bar-selector qq-progress-bar\",attrs:{\"role\":\"progressbar\",\"aria-valuenow\":\"0\",\"aria-valuemin\":\"0\",\"aria-valuemax\":\"100\"}})]),_vm._v(\" \"),_c('span',{staticClass:\"qq-upload-spinner-selector qq-upload-spinner\"}),_vm._v(\" \"),_c('div',{staticClass:\"qq-thumbnail-wrapper\"},[_c('img',{staticClass:\"qq-thumbnail-selector\",attrs:{\"qq-max-size\":\"120\",\"qq-server-scale\":\"\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-upload-cancel-selector qq-upload-cancel\",attrs:{\"type\":\"button\"}},[_vm._v(\"X\")]),_vm._v(\" \"),_c('button',{staticClass:\"qq-upload-retry-selector qq-upload-retry\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-retry-icon\",attrs:{\"aria-label\":\"Retry\"}}),_vm._v(\" Retry\\n                    \")]),_vm._v(\" \"),_c('div',{staticClass:\"qq-file-info\"},[_c('div',{staticClass:\"qq-file-name\"},[_c('span',{staticClass:\"qq-upload-file-selector qq-upload-file\"}),_vm._v(\" \"),_c('span',{staticClass:\"qq-edit-filename-icon-selector qq-edit-filename-icon\",attrs:{\"aria-label\":\"Edit filename\"}})]),_vm._v(\" \"),_c('input',{staticClass:\"qq-edit-filename-selector qq-edit-filename\",attrs:{\"tabindex\":\"0\",\"type\":\"text\"}}),_vm._v(\" \"),_c('span',{staticClass:\"qq-upload-size-selector qq-upload-size\"}),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-delete-selector qq-upload-delete\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-delete-icon\",attrs:{\"aria-label\":\"Delete\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-pause-selector qq-upload-pause\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-pause-icon\",attrs:{\"aria-label\":\"Pause\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-continue-selector qq-upload-continue\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-continue-icon\",attrs:{\"aria-label\":\"Continue\"}})])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"qq-upload-drop-area-selector qq-upload-drop-area\",attrs:{\"qq-hide-dropzone\":\"\"}},[_c('span',{staticClass:\"qq-upload-drop-area-text-selector\"})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"qq-total-progress-bar-container-selector qq-total-progress-bar-container\"},[_c('div',{staticClass:\"qq-total-progress-bar-selector qq-progress-bar qq-total-progress-bar\",attrs:{\"role\":\"progressbar\",\"aria-valuenow\":\"0\",\"aria-valuemin\":\"0\",\"aria-valuemax\":\"100\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// v-uploader.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e05517980d34ba7ccf1d","<template>\n    <div :class=\"[uploaderClass]\">\n        <!-- single upload file mode -->\n        <div class=\"single-upload\" v-if=\"!multiple\">\n            <div class=\"image-box\" v-if=\"preview\">\n                <img :src=\"singleUploadImg\" alt=\"\" ref=\"simpleImg\" :width=\"previewWidth\" :height=\"previewHeight\">\n            </div>\n            <div class=\"btn singleFileUpload uploader-button\" ref=\"upload\" >\n                <i class=\"fi-camera\" v-if=\"buttonIcon\"></i>\n                <span>{{buttonText?buttonText:ui.choseFileButton}}</span>\n            </div>\n        </div>\n\n        <!-- multiple upload file mode -->\n        <div v-if=\"multiple\" ref=\"multipleUpload\" class=\"upload-list\">\n\n        </div>\n\n        <div v-if=\"multiple\" v-show=\"false\" ref=\"uploadArea\">\n            <div class=\"qq-uploader-selector qq-uploader qq-gallery\"\n                 :qq-drop-area-text=\"ui.dropHere\"\n                 style=\"height:100%;\">\n                <ul class=\"qq-upload-list-selector qq-upload-list grid-x grid-padding-x\"\n                    role=\"region\"\n                    aria-live=\"polite\"\n                    aria-relevant=\"additions removals\">\n                    <li>\n                        <span role=\"status\" class=\"qq-upload-status-text-selector qq-upload-status-text\"></span>\n                        <div class=\"qq-progress-bar-container-selector qq-progress-bar-container\">\n                            <div role=\"progressbar\"\n                                 aria-valuenow=\"0\"\n                                 aria-valuemin=\"0\"\n                                 aria-valuemax=\"100\"\n                                 class=\"qq-progress-bar-selector qq-progress-bar\"></div>\n                        </div>\n                        <span class=\"qq-upload-spinner-selector qq-upload-spinner\"></span>\n                        <div class=\"qq-thumbnail-wrapper\">\n                            <img class=\"qq-thumbnail-selector\" qq-max-size=\"120\" qq-server-scale>\n                        </div>\n                        <button type=\"button\" class=\"qq-upload-cancel-selector qq-upload-cancel\">X</button>\n                        <button type=\"button\" class=\"qq-upload-retry-selector qq-upload-retry\">\n                            <span class=\"qq-btn qq-retry-icon\" aria-label=\"Retry\"></span> Retry\n                        </button>\n\n                        <div class=\"qq-file-info\">\n                            <div class=\"qq-file-name\">\n                                <span class=\"qq-upload-file-selector qq-upload-file\"></span>\n                                <span class=\"qq-edit-filename-icon-selector qq-edit-filename-icon\"\n                                      aria-label=\"Edit filename\"></span>\n                            </div>\n                            <input class=\"qq-edit-filename-selector qq-edit-filename\" tabindex=\"0\" type=\"text\">\n                            <span class=\"qq-upload-size-selector qq-upload-size\"></span>\n                            <button type=\"button\" class=\"qq-btn qq-upload-delete-selector qq-upload-delete\">\n                                <span class=\"qq-btn qq-delete-icon\" aria-label=\"Delete\"></span>\n                            </button>\n                            <button type=\"button\" class=\"qq-btn qq-upload-pause-selector qq-upload-pause\">\n                                <span class=\"qq-btn qq-pause-icon\" aria-label=\"Pause\"></span>\n                            </button>\n                            <button type=\"button\" class=\"qq-btn qq-upload-continue-selector qq-upload-continue\">\n                                <span class=\"qq-btn qq-continue-icon\" aria-label=\"Continue\"></span>\n                            </button>\n                        </div>\n                    </li>\n                </ul>\n\n\n                <div class=\"qq-upload-drop-area-selector qq-upload-drop-area\" qq-hide-dropzone>\n                    <span class=\"qq-upload-drop-area-text-selector\"></span>\n                </div>\n\n\n                <div class=\"qq-upload-button-selector qq-upload-button uploader-button\">\n                    <div>\n                        <i class=\"fi-camera v-upload-iconfont icon-uploader-open\" v-if=\"buttonIcon\"></i>\n                        {{buttonText?buttonText:ui.choseFileButton}}\n                    </div>\n                </div>\n                <div class=\"info-show\">\n                    <div>\n                        {{ui.fileSizeLimit}}：<span v-text=\"fileSizeLimit\"></span><br/>\n                        {{ui.fileTypes}}：<span v-text=\"fileTypeExts\"></span>\n                    </div>\n                </div>\n\n                <!--<div class=\"qq-upload-button-selector qq-upload-button file-upload-finish\" style=\"float:right;\">\n                    <div><i class=\"iconfont icon-uploader-done\"></i> {{ui.done}}</div>\n                </div>-->\n\n                <div class=\"qq-total-progress-bar-container-selector qq-total-progress-bar-container\">\n                    <div role=\"progressbar\"\n                         aria-valuenow=\"0\"\n                         aria-valuemin=\"0\"\n                         aria-valuemax=\"100\"\n                         class=\"qq-total-progress-bar-selector qq-progress-bar qq-total-progress-bar\">\n                    </div>\n                </div>\n            </div>\n        </div>\n\n    </div>\n</template>\n\n<script>\n    import fu from 'fine-uploader';\n    import holder from 'holderjs';\n\n    import * as cs from './constants';\n\n    export default {\n        name: \"v-uploader\",\n        props: {\n            language: {\n                type: String,\n                default: 'cn'\n            },\n            //show preview box in single upload mode\n            preview: {\n                type: Boolean,\n                default: true\n            },\n            previewImg: String,\n            buttonText: String,\n            buttonIcon: {\n                type: Boolean,\n                default: true\n            },\n            previewWidth: {\n                type: Number,\n                default: 200\n            },\n            previewHeight: {\n                type: Number,\n                default: 150\n            },\n            /**\n             * file upload type\n             * true: multiple file upload\n             * false: single file upload(default)\n             */\n            multiple: {\n                type: Boolean,\n                default: false\n            },\n            //upload file object name\n            uploadFileObjName: {\n                type: String,\n                default: 'uploadFileObj'\n            },\n            //Maximum number of items that can be potentially uploaded in this session.\n            //set 0 to unlimited\n            itemLimit: {\n                type: Number,\n                default: 0\n            },\n            //upload file size limit\n            fileSizeLimit: {\n                type: String,\n                default: '5MB'\n            },\n            // allow to upload file types\n            fileTypeExts: {\n                type: String,\n                default: 'jpeg,jpg,gif,png'\n            },\n            imageMaxHeight: {\n                type: Number,\n                default: 0\n            },\n            imageMaxWidth: {\n                type: Number,\n                default: 0\n            },\n            imageMinHeight: {\n                type: Number,\n                default: 0\n            },\n            imageMinWidth: {\n                type: Number,\n                default: 0\n            },\n            /**\n             * the callback before file upload\n             *\n             * @param id - file id\n             * @param name - file name\n             *\n             * @return boolean - return false to abort file upload\n             */\n            beforeUpload: Function,\n            //file uploader service url\n            uploadFileUrl: {\n                type: String,\n                default: ''\n            },\n            //file delete service url\n            deleteFileUrl: {\n                type: String,\n                default: ''\n            },\n            //set the way to show upload message(upload fail message)\n            showMessage: {\n                type: Function,\n                default: undefined\n            }\n        },\n        data(){\n            return {\n                uploadedFiles: [],\n                deleteIndexs: [],\n\n                options: {},\n                /**\n                 * upload success callback\n                 * @param id - file id\n                 * @param name - file name\n                 * @param json - uploaded file detail info\n                 */\n                callback: undefined,\n\n                singleUploadImg: '',\n                ui: {},\n                //fileSizeLimit: 0,\n                uploaderClass: {\n                    'v-uploader': true,\n                    'single-mode': false,\n                    'multiple-mode': false\n                }\n            };\n        },\n        watch:{\n            previewImg(val){\n                if(val) this.singleUploadImg = val;\n            }\n        },\n        beforeMount(){\n            let that = this;\n            if(this.multiple) this.uploaderClass['multiple-mode'] = true;\n            else this.uploaderClass['single-mode'] = true;\n\n            this.ui = cs.getI18n(this.language);\n            let imgHolder = `holder.js/${this.previewWidth}x${this.previewHeight}?text=${this.ui.thumbnail}&size=16`;\n            this.singleUploadImg = this.previewImg?this.previewImg:imgHolder;\n\n            if(!this.multiple) {\n                this.callback = data => {\n                    if(data && typeof(data.success) !== 'undefined' && data.success){\n                        if(that.preview) that.singleUploadImg = data.url;\n                        that.$emit('done', [data]);\n                    }\n                };\n            }else{\n                this.callback = data => {\n                    if(data && typeof(data.success) !== 'undefined' && data.success) {\n                        that.uploadedFiles.push(data);\n                    }\n                };\n            }\n            this.options = cs.buildOptions.call(this);\n        },\n        mounted(){\n            let that = this;\n\n            if(!this.multiple) {\n                if(this.preview && !this.previewImg) holder.run({ images: this.$refs.simpleImg });\n                this.options.button = this.$refs.upload;\n                //upload error callback\n                //basic mode work only\n                that.options.callbacks.onError = (id, name, errorReason, xhr) => {\n                    if(that.showMessage && typeof that.showMessage === 'function')\n                        that.showMessage(that, errorReason);\n                };\n                if(this.beforeUpload && typeof this.beforeUpload === 'function')\n                    that.options.callbacks.onSubmit = this.beforeUpload;\n                new fu.FineUploaderBasic(that.options);\n            }else{\n                that.options.deleteFile.endpoint = this.deleteFileUrl;\n                that.options.template = this.$refs.uploadArea;\n                that.options.element = this.$refs.multipleUpload;\n                that.options.showMessage = message => {\n                    if(that.showMessage && typeof that.showMessage === 'function') that.showMessage(that, message);\n                }\n                that.options.callbacks.onDelete = id => {\n                    that.deleteIndexs.push(id);\n                    that.$emit('done', that.uploadedFiles.filter((val,index)=>{\n                        return !that.deleteIndexs.includes(index);\n                    }));\n                };\n                that.options.callbacks.onAllComplete = (succeeded, failed) => {\n                    that.$emit('done', that.uploadedFiles);\n                };\n                if(this.itemLimit) this.options.validation.itemLimit = this.itemLimit;\n                if(this.beforeUpload && typeof(this.beforeUpload) === 'function')\n                    that.options.callbacks.onSubmit = this.beforeUpload;\n                new fu.FineUploader(that.options);\n            }\n        }\n    };\n</script>\n\n\n// WEBPACK FOOTER //\n// src/Uploader.vue","import uploader from './Uploader.vue';\n\nconst Plugin = {\n    install(Vue, options = {}){\n        if(Object.keys(options).length){\n            if(typeof options.language === 'string') uploader.props.language.default = options.language;\n            if(typeof options.preview === 'boolean') uploader.props.preview.default = options.preview;\n            if(typeof options.buttonText === 'string') uploader.props.buttonText.default = options.buttonText;\n            if(typeof options.buttonIcon === 'boolean') uploader.props.buttonIcon.default = options.buttonIcon;\n            if(typeof options.previewWidth === 'number') uploader.props.previewWidth.default = options.previewWidth;\n            if(typeof options.previewHeight === 'number') uploader.props.previewHeight.default = options.previewHeight;\n            if(typeof options.multiple === 'boolean') uploader.props.multiple.default = options.multiple;\n            if(typeof options.uploadFileObjName === 'string') uploader.props.uploadFileObjName.default = options.uploadFileObjName;\n            if(typeof options.itemLimit === 'number') uploader.props.itemLimit.default = options.itemLimit;\n            if(typeof options.fileSizeLimit === 'string') uploader.props.fileSizeLimit.default = options.fileSizeLimit;\n            if(typeof options.fileTypeExts === 'string') uploader.props.fileTypeExts.default = options.fileTypeExts;\n            if(typeof options.imageMaxHeight === 'number') uploader.props.imageMaxHeight.default = options.imageMaxHeight;\n            if(typeof options.imageMaxWidth === 'number') uploader.props.imageMaxWidth.default = options.imageMaxWidth;\n            if(typeof options.imageMinHeight === 'number') uploader.props.imageMinHeight.default = options.imageMinHeight;\n            if(typeof options.imageMinWidth === 'number') uploader.props.imageMinWidth.default = options.imageMinWidth;\n\n            if(typeof options.uploadFileUrl === 'string') uploader.props.uploadFileUrl.default = options.uploadFileUrl;\n            if(typeof options.deleteFileUrl === 'string') uploader.props.deleteFileUrl.default = options.deleteFileUrl;\n            if(typeof options.showMessage === 'function') uploader.props.showMessage.default = options.showMessage;\n        }\n        Vue.component(uploader.name, uploader);\n    }\n};\n\nexport default Plugin;\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","var normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Uploader.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Uploader.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-0b4b4387\\\",\\\"hasScoped\\\":false,\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./Uploader.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Uploader.vue\n// module id = 2\n// module chunks = 0","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file.\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/component-normalizer.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\nmodule.exports = require(\"../fine-uploader/fine-uploader\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fine-uploader/lib/traditional.js\n// module id = 4\n// module chunks = 0","// Fine Uploader 5.16.2 - MIT licensed. http://fineuploader.com\n(function(global) {\n    var qq = function(element) {\n        \"use strict\";\n        return {\n            hide: function() {\n                element.style.display = \"none\";\n                return this;\n            },\n            attach: function(type, fn) {\n                if (element.addEventListener) {\n                    element.addEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + type, fn);\n                }\n                return function() {\n                    qq(element).detach(type, fn);\n                };\n            },\n            detach: function(type, fn) {\n                if (element.removeEventListener) {\n                    element.removeEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.detachEvent(\"on\" + type, fn);\n                }\n                return this;\n            },\n            contains: function(descendant) {\n                if (!descendant) {\n                    return false;\n                }\n                if (element === descendant) {\n                    return true;\n                }\n                if (element.contains) {\n                    return element.contains(descendant);\n                } else {\n                    return !!(descendant.compareDocumentPosition(element) & 8);\n                }\n            },\n            insertBefore: function(elementB) {\n                elementB.parentNode.insertBefore(element, elementB);\n                return this;\n            },\n            remove: function() {\n                element.parentNode.removeChild(element);\n                return this;\n            },\n            css: function(styles) {\n                if (element.style == null) {\n                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n                }\n                if (styles.opacity != null) {\n                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                    }\n                }\n                qq.extend(element.style, styles);\n                return this;\n            },\n            hasClass: function(name, considerParent) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n            },\n            addClass: function(name) {\n                if (!qq(element).hasClass(name)) {\n                    element.className += \" \" + name;\n                }\n                return this;\n            },\n            removeClass: function(name) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n                return this;\n            },\n            getByClass: function(className, first) {\n                var candidates, result = [];\n                if (first && element.querySelector) {\n                    return element.querySelector(\".\" + className);\n                } else if (element.querySelectorAll) {\n                    return element.querySelectorAll(\".\" + className);\n                }\n                candidates = element.getElementsByTagName(\"*\");\n                qq.each(candidates, function(idx, val) {\n                    if (qq(val).hasClass(className)) {\n                        result.push(val);\n                    }\n                });\n                return first ? result[0] : result;\n            },\n            getFirstByClass: function(className) {\n                return qq(element).getByClass(className, true);\n            },\n            children: function() {\n                var children = [], child = element.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        children.push(child);\n                    }\n                    child = child.nextSibling;\n                }\n                return children;\n            },\n            setText: function(text) {\n                element.innerText = text;\n                element.textContent = text;\n                return this;\n            },\n            clearText: function() {\n                return qq(element).setText(\"\");\n            },\n            hasAttribute: function(attrName) {\n                var attrVal;\n                if (element.hasAttribute) {\n                    if (!element.hasAttribute(attrName)) {\n                        return false;\n                    }\n                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n                } else {\n                    attrVal = element[attrName];\n                    if (attrVal === undefined) {\n                        return false;\n                    }\n                    return /^false$/i.exec(attrVal) == null;\n                }\n            }\n        };\n    };\n    (function() {\n        \"use strict\";\n        qq.canvasToBlob = function(canvas, mime, quality) {\n            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n        };\n        qq.dataUriToBlob = function(dataUri) {\n            var arrayBuffer, byteString, createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                } else {\n                    return new Blob([ data ], {\n                        type: mime\n                    });\n                }\n            }, intArray, mimeString;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return createBlob(arrayBuffer, mimeString);\n        };\n        qq.log = function(message, level) {\n            if (window.console) {\n                if (!level || level === \"info\") {\n                    window.console.log(message);\n                } else {\n                    if (window.console[level]) {\n                        window.console[level](message);\n                    } else {\n                        window.console.log(\"<\" + level + \"> \" + message);\n                    }\n                }\n            }\n        };\n        qq.isObject = function(variable) {\n            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n        };\n        qq.isFunction = function(variable) {\n            return typeof variable === \"function\";\n        };\n        qq.isArray = function(value) {\n            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n        };\n        qq.isItemList = function(maybeItemList) {\n            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n        };\n        qq.isNodeList = function(maybeNodeList) {\n            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n        };\n        qq.isString = function(maybeString) {\n            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n        };\n        qq.trimStr = function(string) {\n            if (String.prototype.trim) {\n                return string.trim();\n            }\n            return string.replace(/^\\s+|\\s+$/g, \"\");\n        };\n        qq.format = function(str) {\n            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n            qq.each(args, function(idx, val) {\n                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n                newStr = strBefore + val + strAfter;\n                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n                if (nextIdxToReplace < 0) {\n                    return false;\n                }\n            });\n            return newStr;\n        };\n        qq.isFile = function(maybeFile) {\n            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n        };\n        qq.isFileList = function(maybeFileList) {\n            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n        };\n        qq.isFileOrInput = function(maybeFileOrInput) {\n            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n        };\n        qq.isInput = function(maybeInput, notFile) {\n            var evaluateType = function(type) {\n                var normalizedType = type.toLowerCase();\n                if (notFile) {\n                    return normalizedType !== \"file\";\n                }\n                return normalizedType === \"file\";\n            };\n            if (window.HTMLInputElement) {\n                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            if (maybeInput.tagName) {\n                if (maybeInput.tagName.toLowerCase() === \"input\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        qq.isBlob = function(maybeBlob) {\n            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n                return true;\n            }\n        };\n        qq.isXhrUploadSupported = function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n        };\n        qq.createXhrInstance = function() {\n            if (window.XMLHttpRequest) {\n                return new XMLHttpRequest();\n            }\n            try {\n                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            } catch (error) {\n                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n                return null;\n            }\n        };\n        qq.isFolderDropSupported = function(dataTransfer) {\n            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n        };\n        qq.isFileChunkingSupported = function() {\n            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n        };\n        qq.sliceBlob = function(fileOrBlob, start, end) {\n            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n            return slicer.call(fileOrBlob, start, end);\n        };\n        qq.arrayBufferToHex = function(buffer) {\n            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n            qq.each(bytes, function(idx, byt) {\n                var byteAsHexStr = byt.toString(16);\n                if (byteAsHexStr.length < 2) {\n                    byteAsHexStr = \"0\" + byteAsHexStr;\n                }\n                bytesAsHex += byteAsHexStr;\n            });\n            return bytesAsHex;\n        };\n        qq.readBlobToHex = function(blob, startOffset, length) {\n            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n            fileReader.onload = function() {\n                promise.success(qq.arrayBufferToHex(fileReader.result));\n            };\n            fileReader.onerror = promise.failure;\n            fileReader.readAsArrayBuffer(initialBlob);\n            return promise;\n        };\n        qq.extend = function(first, second, extendNested) {\n            qq.each(second, function(prop, val) {\n                if (extendNested && qq.isObject(val)) {\n                    if (first[prop] === undefined) {\n                        first[prop] = {};\n                    }\n                    qq.extend(first[prop], val, true);\n                } else {\n                    first[prop] = val;\n                }\n            });\n            return first;\n        };\n        qq.override = function(target, sourceFn) {\n            var super_ = {}, source = sourceFn(super_);\n            qq.each(source, function(srcPropName, srcPropVal) {\n                if (target[srcPropName] !== undefined) {\n                    super_[srcPropName] = target[srcPropName];\n                }\n                target[srcPropName] = srcPropVal;\n            });\n            return target;\n        };\n        qq.indexOf = function(arr, elt, from) {\n            if (arr.indexOf) {\n                return arr.indexOf(elt, from);\n            }\n            from = from || 0;\n            var len = arr.length;\n            if (from < 0) {\n                from += len;\n            }\n            for (;from < len; from += 1) {\n                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n        qq.getUniqueId = function() {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n                return v.toString(16);\n            });\n        };\n        qq.ie = function() {\n            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n        };\n        qq.ie7 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n        };\n        qq.ie8 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n        };\n        qq.ie10 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n        };\n        qq.ie11 = function() {\n            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n        };\n        qq.edge = function() {\n            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n        };\n        qq.safari = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n        };\n        qq.chrome = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n        };\n        qq.opera = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n        };\n        qq.firefox = function() {\n            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n        };\n        qq.windows = function() {\n            return navigator.platform === \"Win32\";\n        };\n        qq.android = function() {\n            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n        };\n        qq.androidStock = function() {\n            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n        };\n        qq.ios6 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n        };\n        qq.ios7 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n        };\n        qq.ios8 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n        };\n        qq.ios800 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n        };\n        qq.ios = function() {\n            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n        };\n        qq.iosChrome = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n        };\n        qq.iosSafari = function() {\n            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n        };\n        qq.iosSafariWebView = function() {\n            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n        };\n        qq.preventDefault = function(e) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n        };\n        qq.toElement = function() {\n            var div = document.createElement(\"div\");\n            return function(html) {\n                div.innerHTML = html;\n                var element = div.firstChild;\n                div.removeChild(element);\n                return element;\n            };\n        }();\n        qq.each = function(iterableItem, callback) {\n            var keyOrIndex, retVal;\n            if (iterableItem) {\n                if (window.Storage && iterableItem.constructor === window.Storage) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isString(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (keyOrIndex in iterableItem) {\n                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                            if (retVal === false) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        qq.bind = function(oldFunc, context) {\n            if (qq.isFunction(oldFunc)) {\n                var args = Array.prototype.slice.call(arguments, 2);\n                return function() {\n                    var newArgs = qq.extend([], args);\n                    if (arguments.length) {\n                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                    }\n                    return oldFunc.apply(context, newArgs);\n                };\n            }\n            throw new Error(\"first parameter must be a function!\");\n        };\n        qq.obj2url = function(obj, temp, prefixDone) {\n            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n                }\n            };\n            if (!prefixDone && temp) {\n                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n                uristrings.push(temp);\n                uristrings.push(qq.obj2url(obj));\n            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n                qq.each(obj, function(idx, val) {\n                    add(val, idx);\n                });\n            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n                qq.each(obj, function(prop, val) {\n                    add(val, prop);\n                });\n            } else {\n                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n            }\n            if (temp) {\n                return uristrings.join(prefix);\n            } else {\n                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n            }\n        };\n        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n            if (!formData) {\n                formData = new FormData();\n            }\n            qq.each(obj, function(key, val) {\n                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n                if (qq.isObject(val)) {\n                    qq.obj2FormData(val, formData, key);\n                } else if (qq.isFunction(val)) {\n                    formData.append(key, val());\n                } else {\n                    formData.append(key, val);\n                }\n            });\n            return formData;\n        };\n        qq.obj2Inputs = function(obj, form) {\n            var input;\n            if (!form) {\n                form = document.createElement(\"form\");\n            }\n            qq.obj2FormData(obj, {\n                append: function(key, val) {\n                    input = document.createElement(\"input\");\n                    input.setAttribute(\"name\", key);\n                    input.setAttribute(\"value\", val);\n                    form.appendChild(input);\n                }\n            });\n            return form;\n        };\n        qq.parseJson = function(json) {\n            if (window.JSON && qq.isFunction(JSON.parse)) {\n                return JSON.parse(json);\n            } else {\n                return eval(\"(\" + json + \")\");\n            }\n        };\n        qq.getExtension = function(filename) {\n            var extIdx = filename.lastIndexOf(\".\") + 1;\n            if (extIdx > 0) {\n                return filename.substr(extIdx, filename.length - extIdx);\n            }\n        };\n        qq.getFilename = function(blobOrFileInput) {\n            if (qq.isInput(blobOrFileInput)) {\n                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n            } else if (qq.isFile(blobOrFileInput)) {\n                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                    return blobOrFileInput.fileName;\n                }\n            }\n            return blobOrFileInput.name;\n        };\n        qq.DisposeSupport = function() {\n            var disposers = [];\n            return {\n                dispose: function() {\n                    var disposer;\n                    do {\n                        disposer = disposers.shift();\n                        if (disposer) {\n                            disposer();\n                        }\n                    } while (disposer);\n                },\n                attach: function() {\n                    var args = arguments;\n                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n                },\n                addDisposer: function(disposeFunction) {\n                    disposers.push(disposeFunction);\n                }\n            };\n        };\n    })();\n    (function() {\n        \"use strict\";\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return qq;\n            });\n        } else if (typeof module !== \"undefined\" && module.exports) {\n            module.exports = qq;\n        } else {\n            global.qq = qq;\n        }\n    })();\n    (function() {\n        \"use strict\";\n        qq.Error = function(message) {\n            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n        };\n        qq.Error.prototype = new Error();\n    })();\n    qq.version = \"5.16.2\";\n    qq.supportedFeatures = function() {\n        \"use strict\";\n        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n        function testSupportsFileInputElement() {\n            var supported = true, tempInput;\n            try {\n                tempInput = document.createElement(\"input\");\n                tempInput.type = \"file\";\n                qq(tempInput).hide();\n                if (tempInput.disabled) {\n                    supported = false;\n                }\n            } catch (ex) {\n                supported = false;\n            }\n            return supported;\n        }\n        function isChrome14OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n        }\n        function isCrossOriginXhrSupported() {\n            if (window.XMLHttpRequest) {\n                var xhr = qq.createXhrInstance();\n                return xhr.withCredentials !== undefined;\n            }\n            return false;\n        }\n        function isXdrSupported() {\n            return window.XDomainRequest !== undefined;\n        }\n        function isCrossOriginAjaxSupported() {\n            if (isCrossOriginXhrSupported()) {\n                return true;\n            }\n            return isXdrSupported();\n        }\n        function isFolderSelectionSupported() {\n            return document.createElement(\"input\").webkitdirectory !== undefined;\n        }\n        function isLocalStorageSupported() {\n            try {\n                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n            } catch (error) {\n                return false;\n            }\n        }\n        function isDragAndDropSupported() {\n            var span = document.createElement(\"span\");\n            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n        }\n        supportsUploading = testSupportsFileInputElement();\n        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n        supportsFolderDrop = supportsFileDrop && function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n        }();\n        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n        supportsDeleteFileXdr = isXdrSupported();\n        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n        supportsFolderSelection = isFolderSelectionSupported();\n        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n        supportsUploadProgress = function() {\n            if (supportsAjaxFileUploading) {\n                return !qq.androidStock() && !qq.iosChrome();\n            }\n            return false;\n        }();\n        return {\n            ajaxUploading: supportsAjaxFileUploading,\n            blobUploading: supportsUploadingBlobs,\n            canDetermineSize: supportsAjaxFileUploading,\n            chunking: supportsChunking,\n            deleteFileCors: supportsDeleteFileCors,\n            deleteFileCorsXdr: supportsDeleteFileXdr,\n            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n            dialogElement: !!window.HTMLDialogElement,\n            fileDrop: supportsFileDrop,\n            folderDrop: supportsFolderDrop,\n            folderSelection: supportsFolderSelection,\n            imagePreviews: supportsImagePreviews,\n            imageValidation: supportsImagePreviews,\n            itemSizeValidation: supportsAjaxFileUploading,\n            pause: supportsChunking,\n            progressBar: supportsUploadProgress,\n            resume: supportsResume,\n            scaling: supportsImagePreviews && supportsUploadingBlobs,\n            tiffPreviews: qq.safari(),\n            unlimitedScaledImageSize: !qq.ios(),\n            uploading: supportsUploading,\n            uploadCors: supportsUploadCors,\n            uploadCustomHeaders: supportsAjaxFileUploading,\n            uploadNonMultipart: supportsAjaxFileUploading,\n            uploadViaPaste: supportsUploadViaPaste\n        };\n    }();\n    qq.isGenericPromise = function(maybePromise) {\n        \"use strict\";\n        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n    };\n    qq.Promise = function() {\n        \"use strict\";\n        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n        qq.extend(this, {\n            then: function(onSuccess, onFailure) {\n                if (state === 0) {\n                    if (onSuccess) {\n                        successCallbacks.push(onSuccess);\n                    }\n                    if (onFailure) {\n                        failureCallbacks.push(onFailure);\n                    }\n                } else if (state === -1) {\n                    onFailure && onFailure.apply(null, failureArgs);\n                } else if (onSuccess) {\n                    onSuccess.apply(null, successArgs);\n                }\n                return this;\n            },\n            done: function(callback) {\n                if (state === 0) {\n                    doneCallbacks.push(callback);\n                } else {\n                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n                }\n                return this;\n            },\n            success: function() {\n                state = 1;\n                successArgs = arguments;\n                if (successCallbacks.length) {\n                    qq.each(successCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                return this;\n            },\n            failure: function() {\n                state = -1;\n                failureArgs = arguments;\n                if (failureCallbacks.length) {\n                    qq.each(failureCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                return this;\n            }\n        });\n    };\n    qq.BlobProxy = function(referenceBlob, onCreate) {\n        \"use strict\";\n        qq.extend(this, {\n            referenceBlob: referenceBlob,\n            create: function() {\n                return onCreate(referenceBlob);\n            }\n        });\n    };\n    qq.UploadButton = function(o) {\n        \"use strict\";\n        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n            acceptFiles: null,\n            element: null,\n            focusClass: \"qq-upload-button-focus\",\n            folders: false,\n            hoverClass: \"qq-upload-button-hover\",\n            ios8BrowserCrashWorkaround: false,\n            multiple: false,\n            name: \"qqfile\",\n            onChange: function(input) {},\n            title: null\n        }, input, buttonId;\n        qq.extend(options, o);\n        buttonId = qq.getUniqueId();\n        function createInput() {\n            var input = document.createElement(\"input\");\n            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n            input.setAttribute(\"title\", options.title);\n            self.setMultiple(options.multiple, input);\n            if (options.folders && qq.supportedFeatures.folderSelection) {\n                input.setAttribute(\"webkitdirectory\", \"\");\n            }\n            if (options.acceptFiles) {\n                input.setAttribute(\"accept\", options.acceptFiles);\n            }\n            input.setAttribute(\"type\", \"file\");\n            input.setAttribute(\"name\", options.name);\n            qq(input).css({\n                position: \"absolute\",\n                right: 0,\n                top: 0,\n                fontFamily: \"Arial\",\n                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n                margin: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                opacity: 0\n            });\n            !qq.ie7() && qq(input).css({\n                height: \"100%\"\n            });\n            options.element.appendChild(input);\n            disposeSupport.attach(input, \"change\", function() {\n                options.onChange(input);\n            });\n            disposeSupport.attach(input, \"mouseover\", function() {\n                qq(options.element).addClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"mouseout\", function() {\n                qq(options.element).removeClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"focus\", function() {\n                qq(options.element).addClass(options.focusClass);\n            });\n            disposeSupport.attach(input, \"blur\", function() {\n                qq(options.element).removeClass(options.focusClass);\n            });\n            return input;\n        }\n        qq(options.element).css({\n            position: \"relative\",\n            overflow: \"hidden\",\n            direction: \"ltr\"\n        });\n        qq.extend(this, {\n            getInput: function() {\n                return input;\n            },\n            getButtonId: function() {\n                return buttonId;\n            },\n            setMultiple: function(isMultiple, optInput) {\n                var input = optInput || this.getInput();\n                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                    input.setAttribute(\"multiple\", \"\");\n                } else {\n                    if (isMultiple) {\n                        input.setAttribute(\"multiple\", \"\");\n                    } else {\n                        input.removeAttribute(\"multiple\");\n                    }\n                }\n            },\n            setAcceptFiles: function(acceptFiles) {\n                if (acceptFiles !== options.acceptFiles) {\n                    input.setAttribute(\"accept\", acceptFiles);\n                }\n            },\n            reset: function() {\n                if (input.parentNode) {\n                    qq(input).remove();\n                }\n                qq(options.element).removeClass(options.focusClass);\n                input = null;\n                input = createInput();\n            }\n        });\n        input = createInput();\n    };\n    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n    qq.UploadData = function(uploaderProxy) {\n        \"use strict\";\n        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n        function getDataByIds(idOrIds) {\n            if (qq.isArray(idOrIds)) {\n                var entries = [];\n                qq.each(idOrIds, function(idx, id) {\n                    entries.push(data[id]);\n                });\n                return entries;\n            }\n            return data[idOrIds];\n        }\n        function getDataByUuids(uuids) {\n            if (qq.isArray(uuids)) {\n                var entries = [];\n                qq.each(uuids, function(idx, uuid) {\n                    entries.push(data[byUuid[uuid]]);\n                });\n                return entries;\n            }\n            return data[byUuid[uuids]];\n        }\n        function getDataByStatus(status) {\n            var statusResults = [], statuses = [].concat(status);\n            qq.each(statuses, function(index, statusEnum) {\n                var statusResultIndexes = byStatus[statusEnum];\n                if (statusResultIndexes !== undefined) {\n                    qq.each(statusResultIndexes, function(i, dataIndex) {\n                        statusResults.push(data[dataIndex]);\n                    });\n                }\n            });\n            return statusResults;\n        }\n        qq.extend(this, {\n            addFile: function(spec) {\n                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status,\n                    file: spec.file\n                }) - 1;\n                if (spec.batchId) {\n                    data[id].batchId = spec.batchId;\n                    if (byBatchId[spec.batchId] === undefined) {\n                        byBatchId[spec.batchId] = [];\n                    }\n                    byBatchId[spec.batchId].push(id);\n                }\n                if (spec.proxyGroupId) {\n                    data[id].proxyGroupId = spec.proxyGroupId;\n                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                        byProxyGroupId[spec.proxyGroupId] = [];\n                    }\n                    byProxyGroupId[spec.proxyGroupId].push(id);\n                }\n                data[id].id = id;\n                byUuid[spec.uuid] = id;\n                if (byStatus[status] === undefined) {\n                    byStatus[status] = [];\n                }\n                byStatus[status].push(id);\n                spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n                uploaderProxy.onStatusChange(id, null, status);\n                return id;\n            },\n            retrieve: function(optionalFilter) {\n                if (qq.isObject(optionalFilter) && data.length) {\n                    if (optionalFilter.id !== undefined) {\n                        return getDataByIds(optionalFilter.id);\n                    } else if (optionalFilter.uuid !== undefined) {\n                        return getDataByUuids(optionalFilter.uuid);\n                    } else if (optionalFilter.status) {\n                        return getDataByStatus(optionalFilter.status);\n                    }\n                } else {\n                    return qq.extend([], data, true);\n                }\n            },\n            removeFileRef: function(id) {\n                var record = getDataByIds(id);\n                if (record) {\n                    delete record.file;\n                }\n            },\n            reset: function() {\n                data = [];\n                byUuid = {};\n                byStatus = {};\n                byBatchId = {};\n            },\n            setStatus: function(id, newStatus) {\n                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n                data[id].status = newStatus;\n                if (byStatus[newStatus] === undefined) {\n                    byStatus[newStatus] = [];\n                }\n                byStatus[newStatus].push(id);\n                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n            },\n            uuidChanged: function(id, newUuid) {\n                var oldUuid = data[id].uuid;\n                data[id].uuid = newUuid;\n                byUuid[newUuid] = id;\n                delete byUuid[oldUuid];\n            },\n            updateName: function(id, newName) {\n                data[id].name = newName;\n            },\n            updateSize: function(id, newSize) {\n                data[id].size = newSize;\n            },\n            setParentId: function(targetId, parentId) {\n                data[targetId].parentId = parentId;\n            },\n            getIdsInProxyGroup: function(id) {\n                var proxyGroupId = data[id].proxyGroupId;\n                if (proxyGroupId) {\n                    return byProxyGroupId[proxyGroupId];\n                }\n                return [];\n            },\n            getIdsInBatch: function(id) {\n                var batchId = data[id].batchId;\n                return byBatchId[batchId];\n            }\n        });\n    };\n    qq.status = {\n        SUBMITTING: \"submitting\",\n        SUBMITTED: \"submitted\",\n        REJECTED: \"rejected\",\n        QUEUED: \"queued\",\n        CANCELED: \"canceled\",\n        PAUSED: \"paused\",\n        UPLOADING: \"uploading\",\n        UPLOAD_FINALIZING: \"upload finalizing\",\n        UPLOAD_RETRYING: \"retrying upload\",\n        UPLOAD_SUCCESSFUL: \"upload successful\",\n        UPLOAD_FAILED: \"upload failed\",\n        DELETE_FAILED: \"delete failed\",\n        DELETING: \"deleting\",\n        DELETED: \"deleted\"\n    };\n    (function() {\n        \"use strict\";\n        qq.basePublicApi = {\n            addBlobs: function(blobDataOrArray, params, endpoint) {\n                this.addFiles(blobDataOrArray, params, endpoint);\n            },\n            addInitialFiles: function(cannedFileList) {\n                var self = this;\n                qq.each(cannedFileList, function(index, cannedFile) {\n                    self._addCannedFile(cannedFile);\n                });\n            },\n            addFiles: function(data, params, endpoint) {\n                this._maybeHandleIos8SafariWorkaround();\n                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this), processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this), processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this), processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    } else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this), normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                }, self = this, verifiedFiles = [];\n                this._currentBatchId = batchId;\n                if (data) {\n                    normalizeData();\n                    qq.each(data, function(idx, fileContainer) {\n                        if (qq.isFileOrInput(fileContainer)) {\n                            processFileOrInput(fileContainer);\n                        } else if (qq.isBlob(fileContainer)) {\n                            processBlob(fileContainer);\n                        } else if (qq.isObject(fileContainer)) {\n                            if (fileContainer.blob && fileContainer.name) {\n                                processBlobData(fileContainer);\n                            } else if (fileContainer.canvas && fileContainer.name) {\n                                processCanvasData(fileContainer);\n                            }\n                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                            processCanvas(fileContainer);\n                        } else {\n                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                        }\n                    });\n                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n                }\n            },\n            cancel: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n                    this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n                } else {\n                    this._handler.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var storedIdsCopy = [], self = this;\n                qq.extend(storedIdsCopy, this._storedIds);\n                qq.each(storedIdsCopy, function(idx, storedFileId) {\n                    self.cancel(storedFileId);\n                });\n                this._handler.cancelAll();\n            },\n            clearStoredFiles: function() {\n                this._storedIds = [];\n            },\n            continueUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (uploadData.status === qq.status.PAUSED) {\n                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                    this._uploadFile(id);\n                    return true;\n                } else {\n                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            deleteFile: function(id) {\n                return this._onSubmitDelete(id);\n            },\n            doesExist: function(fileOrBlobId) {\n                return this._handler.isValid(fileOrBlobId);\n            },\n            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n                if (this._imageGenerator) {\n                    fileOrUrl = this._thumbnailUrls[fileId];\n                    options = {\n                        customResizeFunction: customResizeFunction,\n                        maxSize: maxSize > 0 ? maxSize : null,\n                        scale: maxSize > 0\n                    };\n                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                        fileOrUrl = this.getFile(fileId);\n                    }\n                    if (fileOrUrl == null) {\n                        promiseToReturn.failure({\n                            container: imgOrCanvas,\n                            error: \"File or URL not found.\"\n                        });\n                    } else {\n                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        }, function failure(container, reason) {\n                            promiseToReturn.failure({\n                                container: container,\n                                error: reason || \"Problem generating thumbnail\"\n                            });\n                        });\n                    }\n                } else {\n                    promiseToReturn.failure({\n                        container: imgOrCanvas,\n                        error: \"Missing image generator module\"\n                    });\n                }\n                return promiseToReturn;\n            },\n            getButton: function(fileId) {\n                return this._getButton(this._buttonIdsForFileIds[fileId]);\n            },\n            getEndpoint: function(fileId) {\n                return this._endpointStore.get(fileId);\n            },\n            getFile: function(fileOrBlobId) {\n                var file = this._handler.getFile(fileOrBlobId);\n                var uploadDataRecord;\n                if (!file) {\n                    uploadDataRecord = this._uploadData.retrieve({\n                        id: fileOrBlobId\n                    });\n                    if (uploadDataRecord) {\n                        file = uploadDataRecord.file;\n                    }\n                }\n                return file || null;\n            },\n            getInProgress: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n                }).length;\n            },\n            getName: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).name;\n            },\n            getParentId: function(id) {\n                var uploadDataEntry = this.getUploads({\n                    id: id\n                }), parentId = null;\n                if (uploadDataEntry) {\n                    if (uploadDataEntry.parentId !== undefined) {\n                        parentId = uploadDataEntry.parentId;\n                    }\n                }\n                return parentId;\n            },\n            getResumableFilesData: function() {\n                return this._handler.getResumableFilesData();\n            },\n            getSize: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).size;\n            },\n            getNetUploads: function() {\n                return this._netUploaded;\n            },\n            getRemainingAllowedItems: function() {\n                var allowedItems = this._currentItemLimit;\n                if (allowedItems > 0) {\n                    return allowedItems - this._netUploadedOrQueued;\n                }\n                return null;\n            },\n            getUploads: function(optionalFilter) {\n                return this._uploadData.retrieve(optionalFilter);\n            },\n            getUuid: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).uuid;\n            },\n            isResumable: function(id) {\n                return this._handler.hasResumeRecord(id);\n            },\n            log: function(str, level) {\n                if (this._options.debug && (!level || level === \"info\")) {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n                } else if (level && level !== \"info\") {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n                }\n            },\n            pauseUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n                    if (this._handler.pause(id)) {\n                        this._uploadData.setStatus(id, qq.status.PAUSED);\n                        return true;\n                    } else {\n                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                    }\n                } else {\n                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            removeFileRef: function(id) {\n                this._handler.expunge(id);\n                this._uploadData.removeFileRef(id);\n            },\n            reset: function() {\n                this.log(\"Resetting uploader...\");\n                this._handler.reset();\n                this._storedIds = [];\n                this._autoRetries = [];\n                this._retryTimeouts = [];\n                this._preventRetries = [];\n                this._thumbnailUrls = [];\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n                this._paramsStore.reset();\n                this._endpointStore.reset();\n                this._netUploadedOrQueued = 0;\n                this._netUploaded = 0;\n                this._uploadData.reset();\n                this._buttonIdsForFileIds = [];\n                this._pasteHandler && this._pasteHandler.reset();\n                this._options.session.refreshOnReset && this._refreshSessionData();\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n                this._totalProgress && this._totalProgress.reset();\n                this._customResumeDataStore.reset();\n            },\n            retry: function(id) {\n                return this._manualRetry(id);\n            },\n            scaleImage: function(id, specs) {\n                var self = this;\n                return qq.Scaler.prototype.scaleImage(id, specs, {\n                    log: qq.bind(self.log, self),\n                    getFile: qq.bind(self.getFile, self),\n                    uploadData: self._uploadData\n                });\n            },\n            setCustomHeaders: function(headers, id) {\n                this._customHeadersStore.set(headers, id);\n            },\n            setCustomResumeData: function(id, data) {\n                this._customResumeDataStore.set(data, id);\n            },\n            setDeleteFileCustomHeaders: function(headers, id) {\n                this._deleteFileCustomHeadersStore.set(headers, id);\n            },\n            setDeleteFileEndpoint: function(endpoint, id) {\n                this._deleteFileEndpointStore.set(endpoint, id);\n            },\n            setDeleteFileParams: function(params, id) {\n                this._deleteFileParamsStore.set(params, id);\n            },\n            setEndpoint: function(endpoint, id) {\n                this._endpointStore.set(endpoint, id);\n            },\n            setForm: function(elementOrId) {\n                this._updateFormSupportAndParams(elementOrId);\n            },\n            setItemLimit: function(newItemLimit) {\n                this._currentItemLimit = newItemLimit;\n            },\n            setName: function(id, newName) {\n                this._uploadData.updateName(id, newName);\n            },\n            setParams: function(params, id) {\n                this._paramsStore.set(params, id);\n            },\n            setUuid: function(id, newUuid) {\n                return this._uploadData.uuidChanged(id, newUuid);\n            },\n            setStatus: function(id, newStatus) {\n                var fileRecord = this.getUploads({\n                    id: id\n                });\n                if (!fileRecord) {\n                    throw new qq.Error(id + \" is not a valid file ID.\");\n                }\n                switch (newStatus) {\n                  case qq.status.DELETED:\n                    this._onDeleteComplete(id, null, false);\n                    break;\n\n                  case qq.status.DELETE_FAILED:\n                    this._onDeleteComplete(id, null, true);\n                    break;\n\n                  default:\n                    var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n                    this.log(errorMessage);\n                    throw new qq.Error(errorMessage);\n                }\n            },\n            uploadStoredFiles: function() {\n                if (this._storedIds.length === 0) {\n                    this._itemError(\"noFilesError\");\n                } else {\n                    this._uploadStoredFiles();\n                }\n            }\n        };\n        qq.basePrivateApi = {\n            _addCannedFile: function(sessionData) {\n                var self = this;\n                return this._uploadData.addFile({\n                    uuid: sessionData.uuid,\n                    name: sessionData.name,\n                    size: sessionData.size,\n                    status: qq.status.UPLOAD_SUCCESSFUL,\n                    onBeforeStatusChange: function(id) {\n                        sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                        sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n                        if (sessionData.thumbnailUrl) {\n                            self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                        }\n                        self._netUploaded++;\n                        self._netUploadedOrQueued++;\n                    }\n                });\n            },\n            _annotateWithButtonId: function(file, associatedInput) {\n                if (qq.isFile(file)) {\n                    file.qqButtonId = this._getButtonId(associatedInput);\n                }\n            },\n            _batchError: function(message) {\n                this._options.callbacks.onError(null, null, message, undefined);\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return new qq.DeleteFileAjaxRequester({\n                    method: this._options.deleteFile.method.toUpperCase(),\n                    maxConnections: this._options.maxConnections,\n                    uuidParamName: this._options.request.uuidName,\n                    customHeaders: this._deleteFileCustomHeadersStore,\n                    paramsStore: this._deleteFileParamsStore,\n                    endpointStore: this._deleteFileEndpointStore,\n                    cors: this._options.cors,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        self._onDeleteComplete(id, xhrOrXdr, isError);\n                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                    }\n                });\n            },\n            _createPasteHandler: function() {\n                var self = this;\n                return new qq.PasteSupport({\n                    targetElement: this._options.paste.targetElement,\n                    callbacks: {\n                        log: qq.bind(self.log, self),\n                        pasteReceived: function(blob) {\n                            self._handleCheckedCallback({\n                                name: \"onPasteReceived\",\n                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                                identifier: \"pasted image\"\n                            });\n                        }\n                    }\n                });\n            },\n            _createStore: function(initialValue, _readOnlyValues_) {\n                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                }, getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                }, includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n                return {\n                    set: function(val, id) {\n                        if (id == null) {\n                            store = {};\n                            catchall = copy(val);\n                        } else {\n                            store[id] = copy(val);\n                        }\n                    },\n                    get: function(id) {\n                        var values;\n                        if (id != null && store[id]) {\n                            values = store[id];\n                        } else {\n                            values = copy(catchall);\n                        }\n                        includeReadOnlyValues(id, values);\n                        return copy(values);\n                    },\n                    addReadOnly: function(id, values) {\n                        if (qq.isObject(store)) {\n                            if (id === null) {\n                                if (qq.isFunction(values)) {\n                                    readOnlyValues = values;\n                                } else {\n                                    readOnlyValues = readOnlyValues || {};\n                                    qq.extend(readOnlyValues, values);\n                                }\n                            } else {\n                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                                qq.extend(perIdReadOnlyValues[id], values);\n                            }\n                        }\n                    },\n                    remove: function(fileId) {\n                        return delete store[fileId];\n                    },\n                    reset: function() {\n                        store = {};\n                        perIdReadOnlyValues = {};\n                        catchall = initialValue;\n                    }\n                };\n            },\n            _createUploadDataTracker: function() {\n                var self = this;\n                return new qq.UploadData({\n                    getName: function(id) {\n                        return self.getName(id);\n                    },\n                    getUuid: function(id) {\n                        return self.getUuid(id);\n                    },\n                    getSize: function(id) {\n                        return self.getSize(id);\n                    },\n                    onStatusChange: function(id, oldStatus, newStatus) {\n                        self._onUploadStatusChange(id, oldStatus, newStatus);\n                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                        self._maybeAllComplete(id, newStatus);\n                        if (self._totalProgress) {\n                            setTimeout(function() {\n                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                            }, 0);\n                        }\n                    }\n                });\n            },\n            _createUploadButton: function(spec) {\n                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n                function allowMultiple() {\n                    if (qq.supportedFeatures.ajaxUploading) {\n                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n                            return false;\n                        }\n                        if (spec.multiple === undefined) {\n                            return self._options.multiple;\n                        }\n                        return spec.multiple;\n                    }\n                    return false;\n                }\n                button = new qq.UploadButton({\n                    acceptFiles: acceptFiles,\n                    element: spec.element,\n                    focusClass: this._options.classes.buttonFocus,\n                    folders: spec.folders,\n                    hoverClass: this._options.classes.buttonHover,\n                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                    multiple: allowMultiple(),\n                    name: this._options.request.inputName,\n                    onChange: function(input) {\n                        self._onInputChange(input);\n                    },\n                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n                });\n                this._disposeSupport.addDisposer(function() {\n                    button.dispose();\n                });\n                self._buttons.push(button);\n                return button;\n            },\n            _createUploadHandler: function(additionalOptions, namespace) {\n                var self = this, lastOnProgress = {}, options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        } else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n                        lastOnProgress[id] = {\n                            loaded: loaded,\n                            total: total\n                        };\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n                        var status = self.getUploads({\n                            id: id\n                        }).status, retVal;\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n                        retVal = self._onComplete(id, name, result, xhr);\n                        if (retVal instanceof qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        } else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        var onUploadResult = self._options.callbacks.onUpload(id, name);\n                        if (qq.isGenericPromise(onUploadResult)) {\n                            self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                            return onUploadResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n                        if (qq.isGenericPromise(onUploadChunkResult)) {\n                            self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                            return onUploadChunkResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._onUploadChunkSuccess(id, chunkData);\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData, customResumeData) {\n                        return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({\n                            uuid: uuid\n                        });\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({\n                            id: id\n                        }).status;\n                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch,\n                    isInProgress: function(id) {\n                        return self.getUploads({\n                            id: id\n                        }).status === qq.status.UPLOADING;\n                    },\n                    getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n                    setStatus: function(id, status) {\n                        self._uploadData.setStatus(id, status);\n                    }\n                };\n                qq.each(this._options.request, function(prop, val) {\n                    options[prop] = val;\n                });\n                options.customHeaders = this._customHeadersStore;\n                if (additionalOptions) {\n                    qq.each(additionalOptions, function(key, val) {\n                        options[key] = val;\n                    });\n                }\n                return new qq.UploadHandlerController(options, namespace);\n            },\n            _fileOrBlobRejected: function(id) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.REJECTED);\n            },\n            _formatSize: function(bytes) {\n                if (bytes === 0) {\n                    return bytes + this._options.text.sizeSymbols[0];\n                }\n                var i = -1;\n                do {\n                    bytes = bytes / 1e3;\n                    i++;\n                } while (bytes > 999);\n                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n            },\n            _generateExtraButtonSpecs: function() {\n                var self = this;\n                this._extraButtonSpecs = {};\n                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n                    if (multiple === undefined) {\n                        multiple = self._options.multiple;\n                    }\n                    if (extraButtonSpec.validation) {\n                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n                    }\n                    qq.extend(extraButtonSpec, {\n                        multiple: multiple,\n                        validation: validation\n                    }, true);\n                    self._initExtraButton(extraButtonSpec);\n                });\n            },\n            _getButton: function(buttonId) {\n                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n                if (extraButtonsSpec) {\n                    return extraButtonsSpec.element;\n                } else if (buttonId === this._defaultButtonId) {\n                    return this._options.button;\n                }\n            },\n            _getButtonId: function(buttonOrFileInputOrFile) {\n                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n                if (fileBlobOrInput instanceof qq.BlobProxy) {\n                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n                }\n                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                    if (qq.isFile(fileBlobOrInput)) {\n                        return fileBlobOrInput.qqButtonId;\n                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n                    qq.each(inputs, function(idx, input) {\n                        if (input.getAttribute(\"type\") === \"file\") {\n                            fileInput = input;\n                            return false;\n                        }\n                    });\n                    if (fileInput) {\n                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                }\n            },\n            _getCustomResumeData: function(fileId) {\n                return this._customResumeDataStore.get(fileId);\n            },\n            _getNotFinished: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n                }).length;\n            },\n            _getValidationBase: function(buttonId) {\n                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n            },\n            _getValidationDescriptor: function(fileWrapper) {\n                if (fileWrapper.file instanceof qq.BlobProxy) {\n                    return {\n                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n                        size: fileWrapper.file.referenceBlob.size\n                    };\n                }\n                return {\n                    name: this.getUploads({\n                        id: fileWrapper.id\n                    }).name,\n                    size: this.getUploads({\n                        id: fileWrapper.id\n                    }).size\n                };\n            },\n            _getValidationDescriptors: function(fileWrappers) {\n                var self = this, fileDescriptors = [];\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n                });\n                return fileDescriptors;\n            },\n            _handleCameraAccess: function() {\n                if (this._options.camera.ios && qq.ios()) {\n                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n                    if (buttonId && buttonId !== this._defaultButtonId) {\n                        optionRoot = this._extraButtonSpecs[buttonId];\n                    }\n                    optionRoot.multiple = false;\n                    if (optionRoot.validation.acceptFiles === null) {\n                        optionRoot.validation.acceptFiles = acceptIosCamera;\n                    } else {\n                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                    }\n                    qq.each(this._buttons, function(idx, button) {\n                        if (button.getButtonId() === buttonId) {\n                            button.setMultiple(optionRoot.multiple);\n                            button.setAcceptFiles(optionRoot.acceptFiles);\n                            return false;\n                        }\n                    });\n                }\n            },\n            _handleCheckedCallback: function(details) {\n                var self = this, callbackRetVal = details.callback();\n                if (qq.isGenericPromise(callbackRetVal)) {\n                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                    return callbackRetVal.then(function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    }, function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        } else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n                }\n                if (callbackRetVal !== false) {\n                    details.onSuccess(callbackRetVal);\n                } else {\n                    if (details.onFailure) {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                        details.onFailure();\n                    } else {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                    }\n                }\n                return callbackRetVal;\n            },\n            _handleNewFile: function(file, batchId, newFileWrapperList) {\n                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                    size = actualFile.size;\n                }\n                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                    uploadData: self._uploadData,\n                    paramsStore: self._paramsStore,\n                    addFileToHandler: function(id, file) {\n                        self._handler.add(id, file);\n                        self._netUploadedOrQueued++;\n                        self._trackButton(id);\n                    }\n                });\n            },\n            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n                var id = this._uploadData.addFile({\n                    uuid: uuid,\n                    name: name,\n                    size: size,\n                    batchId: batchId,\n                    file: file\n                });\n                this._handler.add(id, file);\n                this._trackButton(id);\n                this._netUploadedOrQueued++;\n                fileList.push({\n                    id: id,\n                    file: file\n                });\n            },\n            _handlePasteSuccess: function(blob, extSuppliedName) {\n                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n                if (name == null) {\n                    name = this._options.paste.defaultName;\n                }\n                name += \".\" + extension;\n                this.addFiles({\n                    name: name,\n                    blob: blob\n                });\n            },\n            _handleDeleteSuccess: function(id) {\n                if (this.getUploads({\n                    id: id\n                }).status !== qq.status.DELETED) {\n                    var name = this.getName(id);\n                    this._netUploadedOrQueued--;\n                    this._netUploaded--;\n                    this._handler.expunge(id);\n                    this._uploadData.setStatus(id, qq.status.DELETED);\n                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n                }\n            },\n            _handleDeleteFailed: function(id, xhrOrXdr) {\n                var name = this.getName(id);\n                this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n                this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n                if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n                    this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n                } else {\n                    this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n                }\n            },\n            _initExtraButton: function(spec) {\n                var button = this._createUploadButton({\n                    accept: spec.validation.acceptFiles,\n                    allowedExtensions: spec.validation.allowedExtensions,\n                    element: spec.element,\n                    folders: spec.folders,\n                    multiple: spec.multiple,\n                    title: spec.fileInputTitle\n                });\n                this._extraButtonSpecs[button.getButtonId()] = spec;\n            },\n            _initFormSupportAndParams: function() {\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this._options.request.endpoint = this._formSupport.newEndpoint;\n                    }\n                } else {\n                    this._paramsStore = this._createStore(this._options.request.params);\n                }\n            },\n            _isDeletePossible: function() {\n                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                    return false;\n                }\n                if (this._options.cors.expected) {\n                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n                        return true;\n                    }\n                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                        return true;\n                    }\n                    return false;\n                }\n                return true;\n            },\n            _isAllowedExtension: function(allowed, fileName) {\n                var valid = false;\n                if (!allowed.length) {\n                    return true;\n                }\n                qq.each(allowed, function(idx, allowedExt) {\n                    if (qq.isString(allowedExt)) {\n                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n                        if (fileName.match(extRegex) != null) {\n                            valid = true;\n                            return false;\n                        }\n                    }\n                });\n                return valid;\n            },\n            _itemError: function(code, maybeNameOrNames, item) {\n                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                    if (qq.isString(allowedExtension)) {\n                        allowedExtensions.push(allowedExtension);\n                    }\n                });\n                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n                r(\"{file}\", this._options.formatFileName(name));\n                r(\"{extensions}\", extensionsForMessage);\n                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n                if (placeholderMatch !== null) {\n                    qq.each(placeholderMatch, function(idx, placeholder) {\n                        r(placeholder, names[idx]);\n                    });\n                }\n                this._options.callbacks.onError(null, name, message, undefined);\n                return message;\n            },\n            _manualRetry: function(id, callback) {\n                if (this._onBeforeManualRetry(id)) {\n                    this._netUploadedOrQueued++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    if (callback) {\n                        callback(id);\n                    } else {\n                        this._handler.retry(id);\n                    }\n                    return true;\n                }\n            },\n            _maybeAllComplete: function(id, status) {\n                var self = this, notFinished = this._getNotFinished();\n                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                    this._succeededSinceLastAllComplete.push(id);\n                } else if (status === qq.status.UPLOAD_FAILED) {\n                    this._failedSinceLastAllComplete.push(id);\n                }\n                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                    setTimeout(function() {\n                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                    }, 0);\n                }\n            },\n            _maybeHandleIos8SafariWorkaround: function() {\n                var self = this;\n                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                    setTimeout(function() {\n                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                    }, 0);\n                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n                }\n            },\n            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n                if (!response.success) {\n                    if (xhr && xhr.status !== 200 && !response.error) {\n                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                    } else {\n                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                        this._options.callbacks.onError(id, name, errorReason, xhr);\n                    }\n                }\n            },\n            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n                var self = this;\n                if (items.length > index) {\n                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                        setTimeout(function() {\n                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n                            self._handleCheckedCallback({\n                                name: \"onValidate\",\n                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                            });\n                        }, 0);\n                    } else if (!validItem) {\n                        for (;index < items.length; index++) {\n                            self._fileOrBlobRejected(items[index].id);\n                        }\n                    }\n                }\n            },\n            _onAllComplete: function(successful, failed) {\n                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n            },\n            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n                var self = this;\n                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n                if (self._shouldAutoRetry(id)) {\n                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n                    self._maybeParseAndSendUploadError.apply(self, arguments);\n                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                    self._onBeforeAutoRetry(id, name);\n                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    self._retryTimeouts[id] = setTimeout(function() {\n                        self.log(\"Starting retry for \" + name + \"...\");\n                        if (callback) {\n                            callback(id);\n                        } else {\n                            self._handler.retry(id);\n                        }\n                    }, retryWaitPeriod);\n                    return true;\n                }\n            },\n            _onBeforeAutoRetry: function(id, name) {\n                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n            },\n            _onBeforeManualRetry: function(id) {\n                var itemLimit = this._currentItemLimit, fileName;\n                if (this._preventRetries[id]) {\n                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                    return false;\n                } else if (this._handler.isValid(id)) {\n                    fileName = this.getName(id);\n                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                        return false;\n                    }\n                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                        this._itemError(\"retryFailTooManyItems\");\n                        return false;\n                    }\n                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                    return true;\n                } else {\n                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                    return false;\n                }\n            },\n            _onCancel: function(id, name) {\n                this._netUploadedOrQueued--;\n                clearTimeout(this._retryTimeouts[id]);\n                var storedItemIndex = qq.indexOf(this._storedIds, id);\n                if (!this._options.autoUpload && storedItemIndex >= 0) {\n                    this._storedIds.splice(storedItemIndex, 1);\n                }\n                this._uploadData.setStatus(id, qq.status.CANCELED);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                if (!result.success) {\n                    this._netUploadedOrQueued--;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                        this._preventRetries[id] = true;\n                    }\n                } else {\n                    if (result.thumbnailUrl) {\n                        this._thumbnailUrls[id] = result.thumbnailUrl;\n                    }\n                    this._netUploaded++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n                }\n                this._maybeParseAndSendUploadError(id, name, result, xhr);\n                return result.success ? true : false;\n            },\n            _onDelete: function(id) {\n                this._uploadData.setStatus(id, qq.status.DELETING);\n            },\n            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n                var name = this.getName(id);\n                if (isError) {\n                    this._handleDeleteFailed(id, xhrOrXdr);\n                } else {\n                    this._handleDeleteSuccess(id);\n                }\n            },\n            _onInputChange: function(input) {\n                var fileIndex;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                        this._annotateWithButtonId(input.files[fileIndex], input);\n                    }\n                    this.addFiles(input.files);\n                } else if (input.value.length > 0) {\n                    this.addFiles(input);\n                }\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n            },\n            _onSubmit: function(id, name) {},\n            _onSubmitCallbackSuccess: function(id, name) {\n                this._onSubmit.apply(this, arguments);\n                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n                this._onSubmitted.apply(this, arguments);\n                if (this._options.autoUpload) {\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                    this._uploadFile(id);\n                } else {\n                    this._storeForLater(id);\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                }\n            },\n            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n                if (onSuccessCallback) {\n                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n                }\n                if (this._isDeletePossible()) {\n                    this._handleCheckedCallback({\n                        name: \"onSubmitDelete\",\n                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                        identifier: id\n                    });\n                    return true;\n                } else {\n                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                    return false;\n                }\n            },\n            _onSubmitted: function(id) {},\n            _onTotalProgress: function(loaded, total) {\n                this._options.callbacks.onTotalProgress(loaded, total);\n            },\n            _onUploadPrep: function(id) {},\n            _onUpload: function(id, name) {\n                this._uploadData.setStatus(id, qq.status.UPLOADING);\n            },\n            _onUploadChunk: function(id, chunkData) {},\n            _onUploadChunkSuccess: function(id, chunkData) {\n                if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n                    this._autoRetries[id] = 0;\n                }\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.PAUSED) {\n                    clearTimeout(this._retryTimeouts[id]);\n                }\n            },\n            _onValidateBatchCallbackFailure: function(fileWrappers) {\n                var self = this;\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    self._fileOrBlobRejected(fileWrapper.id);\n                });\n            },\n            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                    if (items.length > 0) {\n                        this._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                        });\n                    } else {\n                        this._itemError(\"noFilesError\");\n                    }\n                } else {\n                    this._onValidateBatchCallbackFailure(items);\n                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n                    this._batchError(errorMessage);\n                }\n            },\n            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n                var nextIndex = index + 1;\n                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n            },\n            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                }, function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                });\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                if (items.length === 0) {\n                    this._itemError(\"noFilesError\");\n                    return;\n                }\n                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n                this._handleCheckedCallback({\n                    name: \"onValidateBatch\",\n                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                    identifier: \"batch validation\"\n                });\n            },\n            _preventLeaveInProgress: function() {\n                var self = this;\n                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                    if (self.getInProgress()) {\n                        e = e || window.event;\n                        e.returnValue = self._options.messages.onLeave;\n                        return self._options.messages.onLeave;\n                    }\n                });\n            },\n            _refreshSessionData: function() {\n                var self = this, options = this._options.session;\n                if (qq.Session && this._options.session.endpoint != null) {\n                    if (!this._session) {\n                        qq.extend(options, {\n                            cors: this._options.cors\n                        });\n                        options.log = qq.bind(this.log, this);\n                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n                        this._session = new qq.Session(options);\n                    }\n                    setTimeout(function() {\n                        self._session.refresh().then(function(response, xhrOrXdr) {\n                            self._sessionRequestComplete();\n                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n                        }, function(response, xhrOrXdr) {\n                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                        });\n                    }, 0);\n                }\n            },\n            _sessionRequestComplete: function() {},\n            _setSize: function(id, newSize) {\n                this._uploadData.updateSize(id, newSize);\n                this._totalProgress && this._totalProgress.onNewSize(id);\n            },\n            _shouldAutoRetry: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n                    if (this._autoRetries[id] === undefined) {\n                        this._autoRetries[id] = 0;\n                    }\n                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                        this._autoRetries[id] += 1;\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _storeForLater: function(id) {\n                this._storedIds.push(id);\n            },\n            _trackButton: function(id) {\n                var buttonId;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    buttonId = this._handler.getFile(id).qqButtonId;\n                } else {\n                    buttonId = this._getButtonId(this._handler.getInput(id));\n                }\n                if (buttonId) {\n                    this._buttonIdsForFileIds[id] = buttonId;\n                }\n            },\n            _updateFormSupportAndParams: function(formElementOrId) {\n                this._options.form.element = formElementOrId;\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this.setEndpoint(this._formSupport.newEndpoint);\n                    }\n                }\n            },\n            _upload: function(id, params, endpoint) {\n                var name = this.getName(id);\n                if (params) {\n                    this.setParams(params, id);\n                }\n                if (endpoint) {\n                    this.setEndpoint(endpoint, id);\n                }\n                this._handleCheckedCallback({\n                    name: \"onSubmit\",\n                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                    identifier: id\n                });\n            },\n            _uploadFile: function(id) {\n                if (!this._handler.upload(id)) {\n                    this._uploadData.setStatus(id, qq.status.QUEUED);\n                }\n            },\n            _uploadStoredFiles: function() {\n                var idToUpload, stillSubmitting, self = this;\n                while (this._storedIds.length) {\n                    idToUpload = this._storedIds.shift();\n                    this._uploadFile(idToUpload);\n                }\n                stillSubmitting = this.getUploads({\n                    status: qq.status.SUBMITTING\n                }).length;\n                if (stillSubmitting) {\n                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                    setTimeout(function() {\n                        self._uploadStoredFiles();\n                    }, 1e3);\n                }\n            },\n            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n                var self = this, file = function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n                validityChecker.then(function() {}, function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                    this._itemError(\"typeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (!this._options.validation.allowEmpty && size === 0) {\n                    this._itemError(\"emptyError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                    this._itemError(\"sizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && size < validationBase.minSizeLimit) {\n                    this._itemError(\"minSizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    });\n                } else {\n                    validityChecker.success();\n                }\n                return validityChecker;\n            },\n            _wrapCallbacks: function() {\n                var self, safeCallback, prop;\n                self = this;\n                safeCallback = function(name, callback, args) {\n                    var errorMsg;\n                    try {\n                        return callback.apply(self, args);\n                    } catch (exception) {\n                        errorMsg = exception.message || exception.toString();\n                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                    }\n                };\n                for (prop in this._options.callbacks) {\n                    (function() {\n                        var callbackName, callbackFunc;\n                        callbackName = prop;\n                        callbackFunc = self._options.callbacks[callbackName];\n                        self._options.callbacks[callbackName] = function() {\n                            return safeCallback(callbackName, callbackFunc, arguments);\n                        };\n                    })();\n                }\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.FineUploaderBasic = function(o) {\n            var self = this;\n            this._options = {\n                debug: false,\n                button: null,\n                multiple: true,\n                maxConnections: 3,\n                disableCancelForFormUploads: false,\n                autoUpload: true,\n                warnBeforeUnload: true,\n                request: {\n                    customHeaders: {},\n                    endpoint: \"/server/upload\",\n                    filenameParam: \"qqfilename\",\n                    forceMultipart: true,\n                    inputName: \"qqfile\",\n                    method: \"POST\",\n                    omitDefaultParams: false,\n                    params: {},\n                    paramsInBody: true,\n                    requireSuccessJson: true,\n                    totalFileSizeName: \"qqtotalfilesize\",\n                    uuidName: \"qquuid\"\n                },\n                validation: {\n                    allowedExtensions: [],\n                    sizeLimit: 0,\n                    minSizeLimit: 0,\n                    itemLimit: 0,\n                    stopOnFirstInvalidFile: true,\n                    acceptFiles: null,\n                    image: {\n                        maxHeight: 0,\n                        maxWidth: 0,\n                        minHeight: 0,\n                        minWidth: 0\n                    },\n                    allowEmpty: false\n                },\n                callbacks: {\n                    onSubmit: function(id, name) {},\n                    onSubmitted: function(id, name) {},\n                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n                    onAllComplete: function(successful, failed) {},\n                    onCancel: function(id, name) {},\n                    onUpload: function(id, name) {},\n                    onUploadChunk: function(id, name, chunkData) {},\n                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                    onResume: function(id, fileName, chunkData, customResumeData) {},\n                    onProgress: function(id, name, loaded, total) {},\n                    onTotalProgress: function(loaded, total) {},\n                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n                    onAutoRetry: function(id, name, attemptNumber) {},\n                    onManualRetry: function(id, name) {},\n                    onValidateBatch: function(fileOrBlobData) {},\n                    onValidate: function(fileOrBlobData) {},\n                    onSubmitDelete: function(id) {},\n                    onDelete: function(id) {},\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                    onPasteReceived: function(blob) {},\n                    onStatusChange: function(id, oldStatus, newStatus) {},\n                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n                },\n                messages: {\n                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                    emptyError: \"{file} is empty, please select files again without it.\",\n                    noFilesError: \"No files to upload.\",\n                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                    maxHeightImageError: \"Image is too tall.\",\n                    maxWidthImageError: \"Image is too wide.\",\n                    minHeightImageError: \"Image is not tall enough.\",\n                    minWidthImageError: \"Image is not wide enough.\",\n                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n                },\n                retry: {\n                    enableAuto: false,\n                    maxAutoAttempts: 3,\n                    autoAttemptDelay: 5,\n                    preventRetryResponseProperty: \"preventRetry\"\n                },\n                classes: {\n                    buttonHover: \"qq-upload-button-hover\",\n                    buttonFocus: \"qq-upload-button-focus\"\n                },\n                chunking: {\n                    enabled: false,\n                    concurrent: {\n                        enabled: false\n                    },\n                    mandatory: false,\n                    paramNames: {\n                        partIndex: \"qqpartindex\",\n                        partByteOffset: \"qqpartbyteoffset\",\n                        chunkSize: \"qqchunksize\",\n                        totalFileSize: \"qqtotalfilesize\",\n                        totalParts: \"qqtotalparts\"\n                    },\n                    partSize: function(id) {\n                        return 2e6;\n                    },\n                    success: {\n                        endpoint: null,\n                        headers: function(id) {\n                            return null;\n                        },\n                        jsonPayload: false,\n                        method: \"POST\",\n                        params: function(id) {\n                            return null;\n                        },\n                        resetOnStatus: []\n                    }\n                },\n                resume: {\n                    enabled: false,\n                    recordsExpireIn: 7,\n                    paramNames: {\n                        resuming: \"qqresume\"\n                    },\n                    customKeys: function(fileId) {\n                        return [];\n                    }\n                },\n                formatFileName: function(fileOrBlobName) {\n                    return fileOrBlobName;\n                },\n                text: {\n                    defaultResponseError: \"Upload failure reason unknown\",\n                    fileInputTitle: \"file input\",\n                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n                },\n                deleteFile: {\n                    enabled: false,\n                    method: \"DELETE\",\n                    endpoint: \"/server/upload\",\n                    customHeaders: {},\n                    params: {}\n                },\n                cors: {\n                    expected: false,\n                    sendCredentials: false,\n                    allowXdr: false\n                },\n                blobs: {\n                    defaultName: \"misc_data\"\n                },\n                paste: {\n                    targetElement: null,\n                    defaultName: \"pasted_image\"\n                },\n                camera: {\n                    ios: false,\n                    button: null\n                },\n                extraButtons: [],\n                session: {\n                    endpoint: null,\n                    params: {},\n                    customHeaders: {},\n                    refreshOnReset: true\n                },\n                form: {\n                    element: \"qq-form\",\n                    autoUpload: false,\n                    interceptSubmit: true\n                },\n                scaling: {\n                    customResizer: null,\n                    sendOriginal: true,\n                    orient: true,\n                    defaultType: null,\n                    defaultQuality: 80,\n                    failureText: \"Failed to scale\",\n                    includeExif: false,\n                    sizes: []\n                },\n                workarounds: {\n                    iosEmptyVideos: true,\n                    ios8SafariUploads: true,\n                    ios8BrowserCrash: false\n                }\n            };\n            qq.extend(this._options, o, true);\n            this._buttons = [];\n            this._extraButtonSpecs = {};\n            this._buttonIdsForFileIds = [];\n            this._wrapCallbacks();\n            this._disposeSupport = new qq.DisposeSupport();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData = this._createUploadDataTracker();\n            this._initFormSupportAndParams();\n            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n            this._endpointStore = this._createStore(this._options.request.endpoint);\n            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n            this._handler = this._createUploadHandler();\n            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n            if (this._options.button) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._options.button,\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._generateExtraButtonSpecs();\n            this._handleCameraAccess();\n            if (this._options.paste.targetElement) {\n                if (qq.PasteSupport) {\n                    this._pasteHandler = this._createPasteHandler();\n                } else {\n                    this.log(\"Paste support module not found\", \"error\");\n                }\n            }\n            this._options.warnBeforeUnload && this._preventLeaveInProgress();\n            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n            this._refreshSessionData();\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n            if (this._scaler.enabled) {\n                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n            }\n            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n                    var entry = self._uploadData.retrieve({\n                        id: id\n                    });\n                    return entry && entry.size || 0;\n                });\n            }\n            this._currentItemLimit = this._options.validation.itemLimit;\n            this._customResumeDataStore = this._createStore();\n        };\n        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n    })();\n    qq.AjaxRequester = function(o) {\n        \"use strict\";\n        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n            acceptHeader: null,\n            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [ 200, 202, 204 ],\n                PATCH: [ 200, 201, 202, 203, 204 ],\n                POST: [ 200, 201, 202, 203, 204 ],\n                PUT: [ 200, 201, 202, 203, 204 ],\n                GET: [ 200 ]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n        qq.extend(options, o);\n        log = options.log;\n        if (qq.indexOf(options.validMethods, options.method) < 0) {\n            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n        }\n        function isSimpleMethod() {\n            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n        }\n        function containsNonSimpleHeaders(headers) {\n            var containsNonSimple = false;\n            qq.each(containsNonSimple, function(idx, header) {\n                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n                    containsNonSimple = true;\n                    return false;\n                }\n            });\n            return containsNonSimple;\n        }\n        function isXdr(xhr) {\n            return options.cors.expected && xhr.withCredentials === undefined;\n        }\n        function getCorsAjaxTransport() {\n            var xhrOrXdr;\n            if (window.XMLHttpRequest || window.ActiveXObject) {\n                xhrOrXdr = qq.createXhrInstance();\n                if (xhrOrXdr.withCredentials === undefined) {\n                    xhrOrXdr = new XDomainRequest();\n                    xhrOrXdr.onload = function() {};\n                    xhrOrXdr.onerror = function() {};\n                    xhrOrXdr.ontimeout = function() {};\n                    xhrOrXdr.onprogress = function() {};\n                }\n            }\n            return xhrOrXdr;\n        }\n        function getXhrOrXdr(id, suppliedXhr) {\n            var xhrOrXdr = requestData[id] && requestData[id].xhr;\n            if (!xhrOrXdr) {\n                if (suppliedXhr) {\n                    xhrOrXdr = suppliedXhr;\n                } else {\n                    if (options.cors.expected) {\n                        xhrOrXdr = getCorsAjaxTransport();\n                    } else {\n                        xhrOrXdr = qq.createXhrInstance();\n                    }\n                }\n                requestData[id].xhr = xhrOrXdr;\n            }\n            return xhrOrXdr;\n        }\n        function dequeue(id) {\n            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n            delete requestData[id];\n            queue.splice(i, 1);\n            if (queue.length >= max && i < max) {\n                nextId = queue[max - 1];\n                sendRequest(nextId);\n            }\n        }\n        function onComplete(id, xdrError) {\n            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n            dequeue(id);\n            if (isError) {\n                log(method + \" request for \" + id + \" has failed\", \"error\");\n            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n                isError = true;\n                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n            }\n            options.onComplete(id, xhr, isError);\n        }\n        function getParams(id) {\n            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n            if (options.paramsStore.get) {\n                params = options.paramsStore.get(id);\n            }\n            if (onDemandParams) {\n                qq.each(onDemandParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            if (mandatedParams) {\n                qq.each(mandatedParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            return params;\n        }\n        function sendRequest(id, optXhr) {\n            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n            options.onSend(id);\n            url = createUrl(id, params, requestData[id].additionalQueryParams);\n            if (isXdr(xhr)) {\n                xhr.onload = getXdrLoadHandler(id);\n                xhr.onerror = getXdrErrorHandler(id);\n            } else {\n                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n            }\n            registerForUploadProgress(id);\n            xhr.open(method, url, true);\n            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n                xhr.withCredentials = true;\n            }\n            setHeaders(id);\n            log(\"Sending \" + method + \" request for \" + id);\n            if (payload) {\n                xhr.send(payload);\n            } else if (shouldParamsBeInQueryString || !params) {\n                xhr.send();\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n                xhr.send(qq.obj2url(params, \"\"));\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n                xhr.send(JSON.stringify(params));\n            } else {\n                xhr.send(params);\n            }\n            return xhr;\n        }\n        function createUrl(id, params, additionalQueryParams) {\n            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n            if (addToPath != undefined) {\n                endpoint += \"/\" + addToPath;\n            }\n            if (shouldParamsBeInQueryString && params) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            if (additionalQueryParams) {\n                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n            }\n            return endpoint;\n        }\n        function getXhrReadyStateChangeHandler(id) {\n            return function() {\n                if (getXhrOrXdr(id).readyState === 4) {\n                    onComplete(id);\n                }\n            };\n        }\n        function registerForUploadProgress(id) {\n            var onProgress = options.onProgress;\n            if (onProgress) {\n                getXhrOrXdr(id).upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        onProgress(id, e.loaded, e.total);\n                    }\n                };\n            }\n        }\n        function getXdrLoadHandler(id) {\n            return function() {\n                onComplete(id);\n            };\n        }\n        function getXdrErrorHandler(id) {\n            return function() {\n                onComplete(id, true);\n            };\n        }\n        function setHeaders(id) {\n            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n            if (!isXdr(xhr)) {\n                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n                if (options.allowXRequestedWithAndCacheControl) {\n                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                    }\n                }\n                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n                }\n                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n                qq.extend(allHeaders, onDemandHeaders);\n                qq.each(allHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        }\n        function isResponseSuccessful(responseCode) {\n            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n        }\n        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n            requestData[id] = {\n                addToPath: addToPath,\n                additionalParams: additionalParams,\n                additionalQueryParams: additionalQueryParams,\n                additionalHeaders: additionalHeaders,\n                payload: payload\n            };\n            var len = queue.push(id);\n            if (len <= options.maxConnections) {\n                return sendRequest(id, optXhr);\n            }\n        }\n        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n        qq.extend(this, {\n            initTransport: function(id) {\n                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n                return {\n                    withPath: function(appendToPath) {\n                        path = appendToPath;\n                        return this;\n                    },\n                    withParams: function(additionalParams) {\n                        params = additionalParams;\n                        return this;\n                    },\n                    withQueryParams: function(_additionalQueryParams_) {\n                        additionalQueryParams = _additionalQueryParams_;\n                        return this;\n                    },\n                    withHeaders: function(additionalHeaders) {\n                        headers = additionalHeaders;\n                        return this;\n                    },\n                    withPayload: function(thePayload) {\n                        payload = thePayload;\n                        return this;\n                    },\n                    withCacheBuster: function() {\n                        cacheBuster = true;\n                        return this;\n                    },\n                    send: function(optXhr) {\n                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n                            params.qqtimestamp = new Date().getTime();\n                        }\n                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                    }\n                };\n            },\n            canceled: function(id) {\n                dequeue(id);\n            }\n        });\n    };\n    qq.UploadHandler = function(spec) {\n        \"use strict\";\n        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n        qq.extend(this, {\n            add: function(id, fileItem) {\n                fileState[id] = fileItem;\n                fileState[id].temp = {};\n            },\n            cancel: function(id) {\n                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n                onCancelRetVal.then(function() {\n                    if (self.isValid(id)) {\n                        fileState[id].canceled = true;\n                        self.expunge(id);\n                    }\n                    cancelFinalizationEffort.success();\n                });\n            },\n            expunge: function(id) {\n                delete fileState[id];\n            },\n            getThirdPartyFileId: function(id) {\n                return fileState[id].key;\n            },\n            isValid: function(id) {\n                return fileState[id] !== undefined;\n            },\n            reset: function() {\n                fileState = {};\n            },\n            _getFileState: function(id) {\n                return fileState[id];\n            },\n            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n                fileState[id].key = thirdPartyFileId;\n            },\n            _wasCanceled: function(id) {\n                return !!fileState[id].canceled;\n            }\n        });\n    };\n    qq.UploadHandlerController = function(o, namespace) {\n        \"use strict\";\n        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n            paramsStore: {},\n            maxConnections: 3,\n            chunking: {\n                enabled: false,\n                multiple: {\n                    enabled: false\n                }\n            },\n            log: function(str, level) {},\n            onProgress: function(id, fileName, loaded, total) {},\n            onComplete: function(id, fileName, response, xhr) {},\n            onCancel: function(id, fileName) {},\n            onUploadPrep: function(id) {},\n            onUpload: function(id, fileName) {},\n            onUploadChunk: function(id, fileName, chunkData) {},\n            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n            onAutoRetry: function(id, fileName, response, xhr) {},\n            onResume: function(id, fileName, chunkData, customResumeData) {},\n            onUuidChanged: function(id, newUuid) {},\n            getName: function(id) {},\n            setSize: function(id, newSize) {},\n            isQueued: function(id) {},\n            getIdsInProxyGroup: function(id) {},\n            getIdsInBatch: function(id) {},\n            isInProgress: function(id) {}\n        }, chunked = {\n            done: function(id, chunkIdx, response, xhr) {\n                var chunkData = handler._getChunkData(id, chunkIdx);\n                handler._getFileState(id).attemptingResume = false;\n                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n                handler._getFileState(id).loaded += chunkData.size;\n                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n            },\n            finalize: function(id) {\n                var size = options.getSize(id), name = options.getName(id);\n                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n                handler.finalizeChunks(id).then(function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                }, function(response, xhr) {\n                    var normalizedResponse = upload.normalizeResponse(response, false);\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n                    if (normalizedResponse.reset || xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0) {\n                        chunked.reset(id);\n                    }\n                    if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n                        upload.cleanup(id, normalizedResponse, xhr);\n                    }\n                });\n            },\n            handleFailure: function(chunkIdx, id, response, xhr) {\n                var name = options.getName(id);\n                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n                if (responseToReport.reset) {\n                    chunked.reset(id);\n                } else {\n                    var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n                    inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n                    if (inProgressIdx >= 0) {\n                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                    }\n                }\n                if (!handler._getFileState(id).temp.ignoreFailure) {\n                    if (concurrentChunkingPossible) {\n                        handler._getFileState(id).temp.ignoreFailure = true;\n                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                            ckXhr.abort();\n                            ckXhr._cancelled = true;\n                        });\n                        handler.moveInProgressToRemaining(id);\n                        connectionManager.free(id, true);\n                    }\n                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                        upload.cleanup(id, responseToReport, xhr);\n                    }\n                }\n            },\n            hasMoreParts: function(id) {\n                return !!handler._getFileState(id).chunking.remaining.length;\n            },\n            nextPart: function(id) {\n                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n                if (nextIdx >= handler._getTotalChunks(id)) {\n                    nextIdx = null;\n                }\n                return nextIdx;\n            },\n            reset: function(id) {\n                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n                handler._maybeDeletePersistedChunkData(id);\n                handler.reevaluateChunking(id);\n                handler._getFileState(id).loaded = 0;\n                handler._getFileState(id).attemptingResume = false;\n            },\n            sendNext: function(id) {\n                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), fileState = handler._getFileState(id), resuming = fileState.attemptingResume, inProgressChunks = fileState.chunking.inProgress || [];\n                if (fileState.loaded == null) {\n                    fileState.loaded = 0;\n                }\n                if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n                    chunked.reset(id);\n                    chunkIdx = chunked.nextPart(id);\n                    chunkData = handler._getChunkData(id, chunkIdx);\n                    resuming = false;\n                }\n                if (chunkIdx == null && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                } else {\n                    inProgressChunks.push(chunkIdx);\n                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n                    if (concurrentChunkingPossible) {\n                        connectionManager.open(id, chunkIdx);\n                    }\n                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                        chunked.sendNext(id);\n                    }\n                    if (chunkData.blob.size === 0) {\n                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                    }\n                    var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n                    onUploadChunkPromise.then(function(requestOverrides) {\n                        if (!options.isInProgress(id)) {\n                            log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n                        } else {\n                            log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                            var uploadChunkData = {\n                                chunkIdx: chunkIdx,\n                                id: id,\n                                overrides: requestOverrides,\n                                resuming: resuming\n                            };\n                            handler.uploadChunk(uploadChunkData).then(function success(response, xhr) {\n                                log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                                handler.clearCachedChunk(id, chunkIdx);\n                                var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                                log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                                chunked.done(id, chunkIdx, responseToReport, xhr);\n                                if (inProgressChunkIdx >= 0) {\n                                    inProgressChunks.splice(inProgressChunkIdx, 1);\n                                }\n                                handler._maybePersistChunkedState(id);\n                                if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                    chunked.finalize(id);\n                                } else if (chunked.hasMoreParts(id)) {\n                                    chunked.sendNext(id);\n                                } else {\n                                    log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                                }\n                            }, function failure(response, xhr) {\n                                chunked.handleFailure(chunkIdx, id, response, xhr);\n                            }).done(function() {\n                                handler.clearXhr(id, chunkIdx);\n                            });\n                        }\n                    }, function(error) {\n                        chunked.handleFailure(chunkIdx, id, error, null);\n                    });\n                }\n            }\n        }, connectionManager = {\n            _open: [],\n            _openChunks: {},\n            _waiting: [],\n            available: function() {\n                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                    openChunkEntriesCount++;\n                    openChunksCount += openChunkIndexes.length;\n                });\n                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n            },\n            free: function(id, dontAllowNext) {\n                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n                delete connectionManager._openChunks[id];\n                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                    delete handler._getFileState(id).file;\n                }\n                if (waitingIndex >= 0) {\n                    connectionManager._waiting.splice(waitingIndex, 1);\n                } else if (allowNext && connectionsIndex >= 0) {\n                    connectionManager._open.splice(connectionsIndex, 1);\n                    nextId = connectionManager._waiting.shift();\n                    if (nextId >= 0) {\n                        connectionManager._open.push(nextId);\n                        upload.start(nextId);\n                    }\n                }\n            },\n            getWaitingOrConnected: function() {\n                var waitingOrConnected = [];\n                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                    if (chunks && chunks.length) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                qq.each(connectionManager._open, function(idx, fileId) {\n                    if (!connectionManager._openChunks[fileId]) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n                return waitingOrConnected;\n            },\n            isUsingConnection: function(id) {\n                return qq.indexOf(connectionManager._open, id) >= 0;\n            },\n            open: function(id, chunkIdx) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.push(id);\n                }\n                if (connectionManager.available()) {\n                    if (chunkIdx == null) {\n                        connectionManager._waiting.pop();\n                        connectionManager._open.push(id);\n                    } else {\n                        (function() {\n                            var openChunksEntry = connectionManager._openChunks[id] || [];\n                            openChunksEntry.push(chunkIdx);\n                            connectionManager._openChunks[id] = openChunksEntry;\n                        })();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            reset: function() {\n                connectionManager._waiting = [];\n                connectionManager._open = [];\n            }\n        }, simple = {\n            send: function(id, name) {\n                var fileState = handler._getFileState(id);\n                if (!fileState) {\n                    log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n                    return;\n                }\n                fileState.loaded = 0;\n                log(\"Sending simple upload request for \" + id);\n                handler.uploadFile(id).then(function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                }, function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, false);\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                });\n            }\n        }, upload = {\n            cancel: function(id) {\n                log(\"Cancelling \" + id);\n                options.paramsStore.remove(id);\n                connectionManager.free(id);\n            },\n            cleanup: function(id, response, optXhr) {\n                var name = options.getName(id);\n                options.onComplete(id, name, response, optXhr);\n                if (handler._getFileState(id)) {\n                    handler._clearXhrs && handler._clearXhrs(id);\n                }\n                connectionManager.free(id);\n            },\n            getProxyOrBlob: function(id) {\n                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n            },\n            initHandler: function() {\n                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n                    getCustomResumeData: options.getCustomResumeData,\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged,\n                    onFinalizing: function(id) {\n                        options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n                    }\n                });\n                if (handler._removeExpiredChunkingRecords) {\n                    handler._removeExpiredChunkingRecords();\n                }\n            },\n            isDeferredEligibleForUpload: function(id) {\n                return options.isQueued(id);\n            },\n            maybeDefer: function(id, blob) {\n                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n                    options.onUploadPrep(id);\n                    log(\"Attempting to generate a blob on-demand for \" + id);\n                    blob.create().then(function(generatedBlob) {\n                        log(\"Generated an on-demand blob for \" + id);\n                        handler.updateBlob(id, generatedBlob);\n                        options.setSize(id, generatedBlob.size);\n                        handler.reevaluateChunking(id);\n                        upload.maybeSendDeferredFiles(id);\n                    }, function(errorMessage) {\n                        var errorResponse = {};\n                        if (errorMessage) {\n                            errorResponse.error = errorMessage;\n                        }\n                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                        upload.maybeSendDeferredFiles(id);\n                        connectionManager.free(id);\n                    });\n                } else {\n                    return upload.maybeSendDeferredFiles(id);\n                }\n                return false;\n            },\n            maybeSendDeferredFiles: function(id) {\n                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n                if (idsInGroup && idsInGroup.length) {\n                    log(\"Maybe ready to upload proxy group file \" + id);\n                    qq.each(idsInGroup, function(idx, idInGroup) {\n                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                            uploadedThisId = idInGroup === id;\n                            upload.now(idInGroup);\n                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                            return false;\n                        }\n                    });\n                } else {\n                    uploadedThisId = true;\n                    upload.now(id);\n                }\n                return uploadedThisId;\n            },\n            maybeNewUuid: function(id, response) {\n                if (response.newUuid !== undefined) {\n                    options.onUuidChanged(id, response.newUuid);\n                }\n            },\n            normalizeResponse: function(originalResponse, successful) {\n                var response = originalResponse;\n                if (!qq.isObject(originalResponse)) {\n                    response = {};\n                    if (qq.isString(originalResponse) && !successful) {\n                        response.error = originalResponse;\n                    }\n                }\n                response.success = successful;\n                return response;\n            },\n            now: function(id) {\n                var name = options.getName(id);\n                if (!controller.isValid(id)) {\n                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n                }\n                options.onUpload(id, name).then(function(response) {\n                    if (response && response.pause) {\n                        options.setStatus(id, qq.status.PAUSED);\n                        handler.pause(id);\n                        connectionManager.free(id);\n                    } else {\n                        if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                            chunked.sendNext(id);\n                        } else {\n                            simple.send(id, name);\n                        }\n                    }\n                }, function(error) {\n                    error = error || {};\n                    log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n                    if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n                        var response = upload.normalizeResponse(error.responseJSON, false);\n                        upload.cleanup(id, response);\n                    }\n                });\n            },\n            start: function(id) {\n                var blobToUpload = upload.getProxyOrBlob(id);\n                if (blobToUpload) {\n                    return upload.maybeDefer(id, blobToUpload);\n                } else {\n                    upload.now(id);\n                    return true;\n                }\n            }\n        };\n        qq.extend(this, {\n            add: function(id, file) {\n                handler.add.apply(this, arguments);\n            },\n            upload: function(id) {\n                if (connectionManager.open(id)) {\n                    return upload.start(id);\n                }\n                return false;\n            },\n            retry: function(id) {\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = false;\n                }\n                if (connectionManager.isUsingConnection(id)) {\n                    return upload.start(id);\n                } else {\n                    return controller.upload(id);\n                }\n            },\n            cancel: function(id) {\n                var cancelRetVal = handler.cancel(id);\n                if (qq.isGenericPromise(cancelRetVal)) {\n                    cancelRetVal.then(function() {\n                        upload.cancel(id);\n                    });\n                } else if (cancelRetVal !== false) {\n                    upload.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n                if (waitingOrConnected.length) {\n                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                        controller.cancel(waitingOrConnected[i]);\n                    }\n                }\n                connectionManager.reset();\n            },\n            getFile: function(id) {\n                if (handler.getProxy && handler.getProxy(id)) {\n                    return handler.getProxy(id).referenceBlob;\n                }\n                return handler.getFile && handler.getFile(id);\n            },\n            isProxied: function(id) {\n                return !!(handler.getProxy && handler.getProxy(id));\n            },\n            getInput: function(id) {\n                if (handler.getInput) {\n                    return handler.getInput(id);\n                }\n            },\n            reset: function() {\n                log(\"Resetting upload handler\");\n                controller.cancelAll();\n                connectionManager.reset();\n                handler.reset();\n            },\n            expunge: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.expunge(id);\n                }\n            },\n            isValid: function(id) {\n                return handler.isValid(id);\n            },\n            hasResumeRecord: function(id) {\n                var key = handler.isValid(id) && handler._getLocalStorageId && handler._getLocalStorageId(id);\n                if (key) {\n                    return !!localStorage.getItem(key);\n                }\n                return false;\n            },\n            getResumableFilesData: function() {\n                if (handler.getResumableFilesData) {\n                    return handler.getResumableFilesData();\n                }\n                return [];\n            },\n            getThirdPartyFileId: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.getThirdPartyFileId(id);\n                }\n            },\n            pause: function(id) {\n                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                    connectionManager.free(id);\n                    handler.moveInProgressToRemaining(id);\n                    return true;\n                }\n                return false;\n            },\n            isAttemptingResume: function(id) {\n                return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n            },\n            isResumable: function(id) {\n                return !!handler.isResumable && handler.isResumable(id);\n            }\n        });\n        qq.extend(options, o);\n        log = options.log;\n        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n        preventRetryResponse = function() {\n            var response = {};\n            response[options.preventRetryParam] = true;\n            return response;\n        }();\n        upload.initHandler();\n    };\n    qq.WindowReceiveMessage = function(o) {\n        \"use strict\";\n        var options = {\n            log: function(message, level) {}\n        }, callbackWrapperDetachers = {};\n        qq.extend(options, o);\n        qq.extend(this, {\n            receiveMessage: function(id, callback) {\n                var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n                if (window.postMessage) {\n                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n                } else {\n                    log(\"iframe message passing not supported in this browser!\", \"error\");\n                }\n            },\n            stopReceivingMessages: function(id) {\n                if (window.postMessage) {\n                    var detacher = callbackWrapperDetachers[id];\n                    if (detacher) {\n                        detacher();\n                    }\n                }\n            }\n        });\n    };\n    qq.FormUploadHandler = function(spec) {\n        \"use strict\";\n        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n            log: log\n        });\n        function expungeFile(id) {\n            delete detachLoadEvents[id];\n            if (isCors) {\n                clearTimeout(postMessageCallbackTimers[id]);\n                delete postMessageCallbackTimers[id];\n                corsMessageReceiver.stopReceivingMessages(id);\n            }\n            var iframe = document.getElementById(handler._getIframeName(id));\n            if (iframe) {\n                iframe.setAttribute(\"src\", \"javascript:false;\");\n                qq(iframe).remove();\n            }\n        }\n        function getFileIdForIframeName(iframeName) {\n            return iframeName.split(\"_\")[0];\n        }\n        function initIframeForUpload(name) {\n            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n            iframe.setAttribute(\"id\", name);\n            iframe.style.display = \"none\";\n            document.body.appendChild(iframe);\n            return iframe;\n        }\n        function registerPostMessageCallback(iframe, callback) {\n            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n            onloadCallbacks[uuid] = callback;\n            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n                if (handler.getInput(fileId)) {\n                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                        log(errorMessage, \"error\");\n                        callback({\n                            error: errorMessage\n                        });\n                    }, 1e3);\n                }\n            });\n            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n                log(\"Received the following window message: '\" + message + \"'\");\n                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n                if (uuid && onloadCallbacks[uuid]) {\n                    log(\"Handling response for iframe name \" + iframeName);\n                    clearTimeout(postMessageCallbackTimers[iframeName]);\n                    delete postMessageCallbackTimers[iframeName];\n                    handler._detachLoadEvent(iframeName);\n                    onloadCallback = onloadCallbacks[uuid];\n                    delete onloadCallbacks[uuid];\n                    corsMessageReceiver.stopReceivingMessages(iframeName);\n                    onloadCallback(response);\n                } else if (!uuid) {\n                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n                }\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, fileInput) {\n                    super_.add(id, {\n                        input: fileInput\n                    });\n                    fileInput.setAttribute(\"name\", inputName);\n                    if (fileInput.parentNode) {\n                        qq(fileInput).remove();\n                    }\n                },\n                expunge: function(id) {\n                    expungeFile(id);\n                    super_.expunge(id);\n                },\n                isValid: function(id) {\n                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n                }\n            };\n        });\n        qq.extend(this, {\n            getInput: function(id) {\n                return handler._getFileState(id).input;\n            },\n            _attachLoadEvent: function(iframe, callback) {\n                var responseDescriptor;\n                if (isCors) {\n                    registerPostMessageCallback(iframe, callback);\n                } else {\n                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                        log(\"Received response for \" + iframe.id);\n                        if (!iframe.parentNode) {\n                            return;\n                        }\n                        try {\n                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                                return;\n                            }\n                        } catch (error) {\n                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                            responseDescriptor = {\n                                success: false\n                            };\n                        }\n                        callback(responseDescriptor);\n                    });\n                }\n            },\n            _createIframe: function(id) {\n                var iframeName = handler._getIframeName(id);\n                return initIframeForUpload(iframeName);\n            },\n            _detachLoadEvent: function(id) {\n                if (detachLoadEvents[id] !== undefined) {\n                    detachLoadEvents[id]();\n                    delete detachLoadEvents[id];\n                }\n            },\n            _getIframeName: function(fileId) {\n                return fileId + \"_\" + formHandlerInstanceId;\n            },\n            _initFormForUpload: function(spec) {\n                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n                if (paramsInBody) {\n                    qq.obj2Inputs(params, form);\n                } else {\n                    url = qq.obj2url(params, endpoint);\n                }\n                form.setAttribute(\"action\", url);\n                form.setAttribute(\"target\", targetName);\n                form.style.display = \"none\";\n                document.body.appendChild(form);\n                return form;\n            },\n            _parseJsonResponse: function(innerHtmlOrMessage) {\n                var response = {};\n                try {\n                    response = qq.parseJson(innerHtmlOrMessage);\n                } catch (error) {\n                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n                }\n                return response;\n            }\n        });\n    };\n    qq.XhrUploadHandler = function(spec) {\n        \"use strict\";\n        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, getChunkSize = function(id) {\n            var fileState = handler._getFileState(id);\n            if (fileState.chunkSize) {\n                return fileState.chunkSize;\n            } else {\n                var chunkSize = chunking.partSize;\n                if (qq.isFunction(chunkSize)) {\n                    chunkSize = chunkSize(id, getSize(id));\n                }\n                fileState.chunkSize = chunkSize;\n                return chunkSize;\n            }\n        }, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log, getCustomResumeData = proxy.getCustomResumeData;\n        function abort(id) {\n            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n                xhr.onreadystatechange = null;\n                xhr.upload.onprogress = null;\n                xhr.abort();\n                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, blobOrProxy) {\n                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                        super_.add(id, {\n                            file: blobOrProxy\n                        });\n                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n                        super_.add(id, {\n                            proxy: blobOrProxy\n                        });\n                    } else {\n                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                    }\n                    handler._initTempState(id);\n                    resumeEnabled && handler._maybePrepareForResume(id);\n                },\n                expunge: function(id) {\n                    abort(id);\n                    handler._maybeDeletePersistedChunkData(id);\n                    handler._clearXhrs(id);\n                    super_.expunge(id);\n                }\n            };\n        });\n        qq.extend(this, {\n            clearCachedChunk: function(id, chunkIdx) {\n                var fileState = handler._getFileState(id);\n                if (fileState) {\n                    delete fileState.temp.cachedChunks[chunkIdx];\n                }\n            },\n            clearXhr: function(id, chunkIdx) {\n                var tempState = handler._getFileState(id).temp;\n                if (tempState.xhrs) {\n                    delete tempState.xhrs[chunkIdx];\n                }\n                if (tempState.ajaxRequesters) {\n                    delete tempState.ajaxRequesters[chunkIdx];\n                }\n            },\n            finalizeChunks: function(id, responseParser) {\n                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n                if (responseParser) {\n                    return new qq.Promise().success(responseParser(xhr), xhr);\n                }\n                return new qq.Promise().success({}, xhr);\n            },\n            getFile: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).file;\n            },\n            getProxy: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).proxy;\n            },\n            getResumableFilesData: function() {\n                var resumableFilesData = [];\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n                    var data = {\n                        name: uploadData.name,\n                        remaining: uploadData.chunking.remaining,\n                        size: uploadData.size,\n                        uuid: uploadData.uuid\n                    };\n                    if (uploadData.key) {\n                        data.key = uploadData.key;\n                    }\n                    if (uploadData.customResumeData) {\n                        data.customResumeData = uploadData.customResumeData;\n                    }\n                    resumableFilesData.push(data);\n                });\n                return resumableFilesData;\n            },\n            isAttemptingResume: function(id) {\n                return handler._getFileState(id).attemptingResume;\n            },\n            isResumable: function(id) {\n                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n            },\n            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n                var fileState = handler._getFileState(id) || {}, chunkingState = fileState.chunking || {}, inProgress = optInProgress || chunkingState.inProgress, remaining = optRemaining || chunkingState.remaining;\n                if (inProgress) {\n                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                    inProgress.reverse();\n                    qq.each(inProgress, function(idx, chunkIdx) {\n                        remaining.unshift(chunkIdx);\n                    });\n                    inProgress.length = 0;\n                }\n            },\n            pause: function(id) {\n                if (handler.isValid(id)) {\n                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                    handler._getFileState(id).paused = true;\n                    abort(id);\n                    return true;\n                }\n            },\n            reevaluateChunking: function(id) {\n                if (chunking && handler.isValid(id)) {\n                    var state = handler._getFileState(id), totalChunks, i;\n                    delete state.chunking;\n                    state.chunking = {};\n                    totalChunks = handler._getTotalChunks(id);\n                    if (totalChunks > 1 || chunking.mandatory) {\n                        state.chunking.enabled = true;\n                        state.chunking.parts = totalChunks;\n                        state.chunking.remaining = [];\n                        for (i = 0; i < totalChunks; i++) {\n                            state.chunking.remaining.push(i);\n                        }\n                        handler._initTempState(id);\n                    } else {\n                        state.chunking.enabled = false;\n                    }\n                }\n            },\n            updateBlob: function(id, newBlob) {\n                if (handler.isValid(id)) {\n                    handler._getFileState(id).file = newBlob;\n                }\n            },\n            _clearXhrs: function(id) {\n                var tempState = handler._getFileState(id).temp;\n                qq.each(tempState.ajaxRequesters, function(chunkId) {\n                    delete tempState.ajaxRequesters[chunkId];\n                });\n                qq.each(tempState.xhrs, function(chunkId) {\n                    delete tempState.xhrs[chunkId];\n                });\n            },\n            _createXhr: function(id, optChunkIdx) {\n                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n            },\n            _getAjaxRequester: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n            },\n            _getChunkData: function(id, chunkIndex) {\n                var chunkSize = getChunkSize(id), fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n                cachedChunks[chunkIndex] = blob;\n                return {\n                    part: chunkIndex,\n                    start: startBytes,\n                    end: endBytes,\n                    count: totalChunks,\n                    blob: blob,\n                    size: endBytes - startBytes\n                };\n            },\n            _getChunkDataForCallback: function(chunkData) {\n                return {\n                    partIndex: chunkData.part,\n                    startByte: chunkData.start + 1,\n                    endByte: chunkData.end,\n                    totalParts: chunkData.count\n                };\n            },\n            _getLocalStorageId: function(id) {\n                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = getChunkSize(id), endpoint = getEndpoint(id), customKeys = resume.customKeys(id), localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n                customKeys.forEach(function(key) {\n                    localStorageId += \"-\" + key;\n                });\n                return localStorageId;\n            },\n            _getMimeType: function(id) {\n                return handler.getFile(id).type;\n            },\n            _getPersistableData: function(id) {\n                return handler._getFileState(id).chunking;\n            },\n            _getTotalChunks: function(id) {\n                if (chunking) {\n                    var fileSize = getSize(id), chunkSize = getChunkSize(id);\n                    return Math.ceil(fileSize / chunkSize);\n                }\n            },\n            _getXhr: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.xhrs[chunkIdx];\n            },\n            _getXhrs: function(id) {\n                return handler._getFileState(id).temp.xhrs;\n            },\n            _iterateResumeRecords: function(callback) {\n                if (resumeEnabled) {\n                    qq.each(localStorage, function(key, item) {\n                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                            var uploadData = JSON.parse(item);\n                            callback(key, uploadData);\n                        }\n                    });\n                }\n            },\n            _initTempState: function(id) {\n                handler._getFileState(id).temp = {\n                    ajaxRequesters: {},\n                    chunkProgress: {},\n                    xhrs: {},\n                    cachedChunks: {}\n                };\n            },\n            _markNotResumable: function(id) {\n                handler._getFileState(id).notResumable = true;\n            },\n            _maybeDeletePersistedChunkData: function(id) {\n                var localStorageId;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    if (localStorageId && localStorage.getItem(localStorageId)) {\n                        localStorage.removeItem(localStorageId);\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _maybePrepareForResume: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && state.key === undefined) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = localStorage.getItem(localStorageId);\n                    if (persistedData) {\n                        persistedData = JSON.parse(persistedData);\n                        if (getDataByUuid(persistedData.uuid)) {\n                            handler._markNotResumable(id);\n                        } else {\n                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n                            onUuidChanged(id, persistedData.uuid);\n                            state.key = persistedData.key;\n                            state.chunking = persistedData.chunking;\n                            state.loaded = persistedData.loaded;\n                            state.customResumeData = persistedData.customResumeData;\n                            state.attemptingResume = true;\n                            handler.moveInProgressToRemaining(id);\n                        }\n                    }\n                }\n            },\n            _maybePersistChunkedState: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    var customResumeData = getCustomResumeData(id);\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = {\n                        name: getName(id),\n                        size: getSize(id),\n                        uuid: getUuid(id),\n                        key: state.key,\n                        chunking: state.chunking,\n                        loaded: state.loaded,\n                        lastUpdated: Date.now()\n                    };\n                    if (customResumeData) {\n                        persistedData.customResumeData = customResumeData;\n                    }\n                    try {\n                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                    } catch (error) {\n                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                    }\n                }\n            },\n            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        } else {\n                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n                        }\n                    },\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n                xhr.upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n                        progressCalculator[type](e.loaded, e.total);\n                    }\n                };\n            },\n            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n                tempState.xhrs = tempState.xhrs || {};\n                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n                tempState.xhrs[xhrsId] = xhr;\n                if (optAjaxRequester) {\n                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n                }\n                return xhr;\n            },\n            _removeExpiredChunkingRecords: function() {\n                var expirationDays = resume.recordsExpireIn;\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    var expirationDate = new Date(uploadData.lastUpdated);\n                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n                    if (expirationDate.getTime() <= Date.now()) {\n                        log(\"Removing expired resume record with key \" + key);\n                        localStorage.removeItem(key);\n                    }\n                });\n            },\n            _shouldChunkThisFile: function(id) {\n                var state = handler._getFileState(id);\n                if (state) {\n                    if (!state.chunking) {\n                        handler.reevaluateChunking(id);\n                    }\n                    return state.chunking.enabled;\n                }\n            }\n        });\n    };\n    qq.DeleteFileAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {\n                return {};\n            },\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n        qq.extend(options, o);\n        function getMandatedParams() {\n            if (options.method.toUpperCase() === \"POST\") {\n                return {\n                    _method: \"DELETE\"\n                };\n            }\n            return {};\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"POST\", \"DELETE\" ],\n            method: options.method,\n            endpointStore: options.endpointStore,\n            paramsStore: options.paramsStore,\n            mandatedParams: getMandatedParams(),\n            maxConnections: options.maxConnections,\n            customHeaders: function(id) {\n                return options.customHeaders.get(id);\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendDelete: function(id, uuid, additionalMandatedParams) {\n                var additionalOptions = additionalMandatedParams || {};\n                options.log(\"Submitting delete file request for \" + id);\n                if (options.method === \"DELETE\") {\n                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n                } else {\n                    additionalOptions[options.uuidParamName] = uuid;\n                    requester.initTransport(id).withParams(additionalOptions).send();\n                }\n            }\n        });\n    };\n    (function() {\n        function detectSubsampling(img) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n            if (iw * ih > 1024 * 1024) {\n                canvas.width = canvas.height = 1;\n                ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img, -iw + 1, 0);\n                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n            } else {\n                return false;\n            }\n        }\n        function detectVerticalSquash(img, iw, ih) {\n            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n            canvas.width = 1;\n            canvas.height = ih;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            data = ctx.getImageData(0, 0, 1, ih).data;\n            while (py > sy) {\n                alpha = data[(py - 1) * 4 + 3];\n                if (alpha === 0) {\n                    ey = py;\n                } else {\n                    sy = py;\n                }\n                py = ey + sy >> 1;\n            }\n            ratio = py / ih;\n            return ratio === 0 ? 1 : ratio;\n        }\n        function renderImageToDataURL(img, blob, options, doSquash) {\n            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n                promise.success(canvas.toDataURL(mime, options.quality || .8));\n            });\n            return promise;\n        }\n        function maybeCalculateDownsampledDimensions(spec) {\n            var maxPixels = 5241e3;\n            if (!qq.ios()) {\n                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n            }\n            if (spec.origHeight * spec.origWidth > maxPixels) {\n                return {\n                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n                };\n            }\n        }\n        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n            ctx.save();\n            if (options.resize) {\n                return renderImageToCanvasWithCustomResizer({\n                    blob: blob,\n                    canvas: canvas,\n                    image: img,\n                    imageHeight: ih,\n                    imageWidth: iw,\n                    orientation: options.orientation,\n                    resize: options.resize,\n                    targetHeight: height,\n                    targetWidth: width\n                });\n            }\n            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n                modifiedDimensions = maybeCalculateDownsampledDimensions({\n                    origWidth: width,\n                    origHeight: height\n                });\n                if (modifiedDimensions) {\n                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n                    width = modifiedDimensions.newWidth;\n                    height = modifiedDimensions.newHeight;\n                }\n            }\n            transformCoordinate(canvas, width, height, options.orientation);\n            if (qq.ios()) {\n                (function() {\n                    if (detectSubsampling(img)) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n                    tmpCanvas.width = tmpCanvas.height = d;\n                    tmpCtx = tmpCanvas.getContext(\"2d\");\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                })();\n            } else {\n                ctx.drawImage(img, 0, 0, width, height);\n            }\n            canvas.qqImageRendered && canvas.qqImageRendered();\n            promise.success();\n            return promise;\n        }\n        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n            targetCanvas.height = targetHeight;\n            targetCanvas.width = targetWidth;\n            sourceCanvasContext.drawImage(image, 0, 0);\n            resize({\n                blob: blob,\n                height: targetHeight,\n                image: image,\n                sourceCanvas: sourceCanvas,\n                targetCanvas: targetCanvas,\n                width: targetWidth\n            }).then(function success() {\n                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                promise.success();\n            }, promise.failure);\n            return promise;\n        }\n        function transformCoordinate(canvas, width, height, orientation) {\n            switch (orientation) {\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n\n              default:\n                canvas.width = width;\n                canvas.height = height;\n            }\n            var ctx = canvas.getContext(\"2d\");\n            switch (orientation) {\n              case 2:\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n\n              case 7:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n\n              default:\n                break;\n            }\n        }\n        function MegaPixImage(srcImage, errorCallback) {\n            var self = this;\n            if (window.Blob && srcImage instanceof Blob) {\n                (function() {\n                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                    if (!URL) {\n                        throw Error(\"No createObjectURL function found to create blob url\");\n                    }\n                    img.src = URL.createObjectURL(srcImage);\n                    self.blob = srcImage;\n                    srcImage = img;\n                })();\n            }\n            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n                srcImage.onload = function() {\n                    var listeners = self.imageLoadListeners;\n                    if (listeners) {\n                        self.imageLoadListeners = null;\n                        setTimeout(function() {\n                            for (var i = 0, len = listeners.length; i < len; i++) {\n                                listeners[i]();\n                            }\n                        }, 0);\n                    }\n                };\n                srcImage.onerror = errorCallback;\n                this.imageLoadListeners = [];\n            }\n            this.srcImage = srcImage;\n        }\n        MegaPixImage.prototype.render = function(target, options) {\n            options = options || {};\n            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n            if (this.imageLoadListeners) {\n                this.imageLoadListeners.push(function() {\n                    self.render(target, options);\n                });\n                return;\n            }\n            if (width && !height) {\n                height = imgHeight * width / imgWidth << 0;\n            } else if (height && !width) {\n                width = imgWidth * height / imgHeight << 0;\n            } else {\n                width = imgWidth;\n                height = imgHeight;\n            }\n            if (maxWidth && width > maxWidth) {\n                width = maxWidth;\n                height = imgHeight * width / imgWidth << 0;\n            }\n            if (maxHeight && height > maxHeight) {\n                height = maxHeight;\n                width = imgWidth * height / imgHeight << 0;\n            }\n            opt = {\n                width: width,\n                height: height\n            }, qq.each(options, function(optionsKey, optionsValue) {\n                opt[optionsKey] = optionsValue;\n            });\n            if (tagName === \"img\") {\n                (function() {\n                    var oldTargetSrc = target.src;\n                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n                })();\n            } else if (tagName === \"canvas\") {\n                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n            }\n            if (typeof this.onrender === \"function\") {\n                this.onrender(target);\n            }\n        };\n        qq.MegaPixImage = MegaPixImage;\n    })();\n    qq.ImageGenerator = function(log) {\n        \"use strict\";\n        function isImg(el) {\n            return el.tagName.toLowerCase() === \"img\";\n        }\n        function isCanvas(el) {\n            return el.tagName.toLowerCase() === \"canvas\";\n        }\n        function isImgCorsSupported() {\n            return new Image().crossOrigin !== undefined;\n        }\n        function isCanvasSupported() {\n            var canvas = document.createElement(\"canvas\");\n            return canvas.getContext && canvas.getContext(\"2d\");\n        }\n        function determineMimeOfFileName(nameWithPath) {\n            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n            extension = extension && extension.toLowerCase();\n            switch (extension) {\n              case \"jpeg\":\n              case \"jpg\":\n                return \"image/jpeg\";\n\n              case \"png\":\n                return \"image/png\";\n\n              case \"bmp\":\n                return \"image/bmp\";\n\n              case \"gif\":\n                return \"image/gif\";\n\n              case \"tiff\":\n              case \"tif\":\n                return \"image/tiff\";\n            }\n        }\n        function isCrossOrigin(url) {\n            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n            targetAnchor.href = url;\n            targetProtocol = targetAnchor.protocol;\n            targetPort = targetAnchor.port;\n            targetHostname = targetAnchor.hostname;\n            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n                return true;\n            }\n            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n                return true;\n            }\n            if (targetPort !== window.location.port && !qq.ie()) {\n                return true;\n            }\n            return false;\n        }\n        function registerImgLoadListeners(img, promise) {\n            img.onload = function() {\n                img.onload = null;\n                img.onerror = null;\n                promise.success(img);\n            };\n            img.onerror = function() {\n                img.onload = null;\n                img.onerror = null;\n                log(\"Problem drawing thumbnail!\", \"error\");\n                promise.failure(img, \"Problem drawing thumbnail!\");\n            };\n        }\n        function registerCanvasDrawImageListener(canvas, promise) {\n            canvas.qqImageRendered = function() {\n                promise.success(canvas);\n            };\n        }\n        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n            if (isImg(imgOrCanvas)) {\n                registerImgLoadListeners(imgOrCanvas, promise);\n            } else if (isCanvas(imgOrCanvas)) {\n                registerCanvasDrawImageListener(imgOrCanvas, promise);\n            } else {\n                promise.failure(imgOrCanvas);\n                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n            }\n            return registered;\n        }\n        function draw(fileOrBlob, container, options) {\n            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n            identifier.isPreviewable().then(function(mime) {\n                var dummyExif = {\n                    parse: function() {\n                        return new qq.Promise().success();\n                    }\n                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(function(exif) {\n                        var orientation = exif && exif.Orientation;\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            orientation: orientation,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    }, function(failureMsg) {\n                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    });\n                }\n            }, function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            });\n            return drawPreview;\n        }\n        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n            var tempImg = new Image(), tempImgRender = new qq.Promise();\n            registerThumbnailRenderedListener(tempImg, tempImgRender);\n            if (isCrossOrigin(url)) {\n                tempImg.crossOrigin = \"anonymous\";\n            }\n            tempImg.src = url;\n            tempImgRender.then(function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            }, draw.failure);\n        }\n        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n            registerThumbnailRenderedListener(img, draw);\n            qq(img).css({\n                maxWidth: maxSize + \"px\",\n                maxHeight: maxSize + \"px\"\n            });\n            img.src = url;\n        }\n        function drawFromUrl(url, container, options) {\n            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n            if (scale && isImg(container)) {\n                if (isCanvasSupported()) {\n                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                    } else {\n                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                    }\n                } else {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n            } else if (isCanvas(container)) {\n                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n            } else if (registerThumbnailRenderedListener(container, draw)) {\n                container.src = url;\n            }\n            return draw;\n        }\n        qq.extend(this, {\n            generate: function(fileBlobOrUrl, container, options) {\n                if (qq.isString(fileBlobOrUrl)) {\n                    log(\"Attempting to update thumbnail based on server response.\");\n                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n                } else {\n                    log(\"Attempting to draw client-side image preview.\");\n                    return draw(fileBlobOrUrl, container, options || {});\n                }\n            }\n        });\n        this._testing = {};\n        this._testing.isImg = isImg;\n        this._testing.isCanvas = isCanvas;\n        this._testing.isCrossOrigin = isCrossOrigin;\n        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    };\n    qq.Exif = function(fileOrBlob, log) {\n        \"use strict\";\n        var TAG_IDS = [ 274 ], TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n        function parseLittleEndian(hex) {\n            var result = 0, pow = 0;\n            while (hex.length > 0) {\n                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n                hex = hex.substring(2, hex.length);\n                pow += 8;\n            }\n            return result;\n        }\n        function seekToApp1(offset, promise) {\n            var theOffset = offset, thePromise = promise;\n            if (theOffset === undefined) {\n                theOffset = 2;\n                thePromise = new qq.Promise();\n            }\n            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n                if (match) {\n                    if (match[1] !== \"1\") {\n                        segmentLength = parseInt(hex.slice(4, 8), 16);\n                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n                    } else {\n                        thePromise.success(theOffset);\n                    }\n                } else {\n                    thePromise.failure(\"No EXIF header to be found!\");\n                }\n            });\n            return thePromise;\n        }\n        function getApp1Offset() {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n                if (hex.indexOf(\"ffd8\") !== 0) {\n                    promise.failure(\"Not a valid JPEG!\");\n                } else {\n                    seekToApp1().then(function(offset) {\n                        promise.success(offset);\n                    }, function(error) {\n                        promise.failure(error);\n                    });\n                }\n            });\n            return promise;\n        }\n        function isLittleEndian(app1Start) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n                promise.success(hex === \"4949\");\n            });\n            return promise;\n        }\n        function getDirEntryCount(app1Start, littleEndian) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n                if (littleEndian) {\n                    return promise.success(parseLittleEndian(hex));\n                } else {\n                    promise.success(parseInt(hex, 16));\n                }\n            });\n            return promise;\n        }\n        function getIfd(app1Start, dirEntries) {\n            var offset = app1Start + 20, bytes = dirEntries * 12;\n            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n        }\n        function getDirEntries(ifdHex) {\n            var entries = [], offset = 0;\n            while (offset + 24 <= ifdHex.length) {\n                entries.push(ifdHex.slice(offset, offset + 24));\n                offset += 24;\n            }\n            return entries;\n        }\n        function getTagValues(littleEndian, dirEntries) {\n            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n            qq.each(dirEntries, function(idx, entry) {\n                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n                if (tagsToFindIdx >= 0) {\n                    tagName = TAG_INFO[id].name;\n                    tagValLength = TAG_INFO[id].bytes;\n                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n                    tagsToFind.splice(tagsToFindIdx, 1);\n                }\n                if (tagsToFind.length === 0) {\n                    return false;\n                }\n            });\n            return vals;\n        }\n        qq.extend(this, {\n            parse: function() {\n                var parser = new qq.Promise(), onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n                getApp1Offset().then(function(app1Offset) {\n                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n                    isLittleEndian(app1Offset).then(function(littleEndian) {\n                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n                                log(\"Successfully parsed some EXIF tags\");\n                                parser.success(tagValues);\n                            }, onParseFailure);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n                return parser;\n            }\n        });\n        this._testing = {};\n        this._testing.parseLittleEndian = parseLittleEndian;\n    };\n    qq.Identify = function(fileOrBlob, log) {\n        \"use strict\";\n        function isIdentifiable(magicBytes, questionableBytes) {\n            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                    identifiable = true;\n                    return false;\n                }\n            });\n            return identifiable;\n        }\n        qq.extend(this, {\n            isPreviewable: function() {\n                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n                log(\"First pass: check type attribute of blob object.\");\n                if (this.isPreviewableSync()) {\n                    log(\"Second pass: check for magic bytes in file header.\");\n                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                            if (isIdentifiable(bytes, hex)) {\n                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                    previewable = true;\n                                    identifier.success(mime);\n                                }\n                                return false;\n                            }\n                        });\n                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n                        if (!previewable) {\n                            identifier.failure();\n                        }\n                    }, function() {\n                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                        identifier.failure();\n                    });\n                } else {\n                    identifier.failure();\n                }\n                return identifier;\n            },\n            isPreviewableSync: function() {\n                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                if (isRecognizedImage) {\n                    if (fileMime === \"image/tiff\") {\n                        previewable = qq.supportedFeatures.tiffPreviews;\n                    } else {\n                        previewable = true;\n                    }\n                }\n                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n                return previewable;\n            }\n        });\n    };\n    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n        \"image/jpeg\": \"ffd8ff\",\n        \"image/gif\": \"474946\",\n        \"image/png\": \"89504e\",\n        \"image/bmp\": \"424d\",\n        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n    };\n    qq.ImageValidation = function(blob, log) {\n        \"use strict\";\n        function hasNonZeroLimits(limits) {\n            var atLeastOne = false;\n            qq.each(limits, function(limit, value) {\n                if (value > 0) {\n                    atLeastOne = true;\n                    return false;\n                }\n            });\n            return atLeastOne;\n        }\n        function getWidthHeight() {\n            var sizeDetermination = new qq.Promise();\n            new qq.Identify(blob, log).isPreviewable().then(function() {\n                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (url) {\n                    image.onerror = function() {\n                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                        sizeDetermination.failure();\n                    };\n                    image.onload = function() {\n                        sizeDetermination.success({\n                            width: this.width,\n                            height: this.height\n                        });\n                    };\n                    image.src = url.createObjectURL(blob);\n                } else {\n                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                    sizeDetermination.failure();\n                }\n            }, sizeDetermination.failure);\n            return sizeDetermination;\n        }\n        function getFailingLimit(limits, dimensions) {\n            var failingLimit;\n            qq.each(limits, function(limitName, limitValue) {\n                if (limitValue > 0) {\n                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n                    switch (limitMatcher[1]) {\n                      case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n\n                      case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            });\n            return failingLimit;\n        }\n        this.validate = function(limits) {\n            var validationEffort = new qq.Promise();\n            log(\"Attempting to validate image.\");\n            if (hasNonZeroLimits(limits)) {\n                getWidthHeight().then(function(dimensions) {\n                    var failingLimit = getFailingLimit(limits, dimensions);\n                    if (failingLimit) {\n                        validationEffort.failure(failingLimit);\n                    } else {\n                        validationEffort.success();\n                    }\n                }, validationEffort.success);\n            } else {\n                validationEffort.success();\n            }\n            return validationEffort;\n        };\n    };\n    qq.Session = function(spec) {\n        \"use strict\";\n        var options = {\n            endpoint: null,\n            params: {},\n            customHeaders: {},\n            cors: {},\n            addFileRecord: function(sessionData) {},\n            log: function(message, level) {}\n        };\n        qq.extend(options, spec, true);\n        function isJsonResponseValid(response) {\n            if (qq.isArray(response)) {\n                return true;\n            }\n            options.log(\"Session response is not an array.\", \"error\");\n        }\n        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n            var someItemsIgnored = false;\n            success = success && isJsonResponseValid(fileItems);\n            if (success) {\n                qq.each(fileItems, function(idx, fileItem) {\n                    if (fileItem.uuid == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                    } else if (fileItem.name == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                    } else {\n                        try {\n                            options.addFileRecord(fileItem);\n                            return true;\n                        } catch (err) {\n                            someItemsIgnored = true;\n                            options.log(err.message, \"error\");\n                        }\n                    }\n                    return false;\n                });\n            }\n            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n        }\n        this.refresh = function() {\n            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n                onComplete: refreshCompleteCallback\n            }));\n            requester.queryServer();\n            return refreshEffort;\n        };\n    };\n    qq.SessionAjaxRequester = function(spec) {\n        \"use strict\";\n        var requester, options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, spec);\n        function onComplete(id, xhrOrXdr, isError) {\n            var response = null;\n            if (xhrOrXdr.responseText != null) {\n                try {\n                    response = qq.parseJson(xhrOrXdr.responseText);\n                } catch (err) {\n                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                    isError = true;\n                }\n            }\n            options.onComplete(response, !isError, xhrOrXdr);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: onComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            queryServer: function() {\n                var params = qq.extend({}, options.params);\n                options.log(\"Session query request.\");\n                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n            }\n        });\n    };\n    qq.Scaler = function(spec, log) {\n        \"use strict\";\n        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n        qq.extend(this, {\n            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n                if (identifier.isPreviewableSync()) {\n                    qq.each(sizes, function(idx, sizeRecord) {\n                        var outputType = self._determineOutputType({\n                            defaultType: defaultType,\n                            requestedType: sizeRecord.type,\n                            refType: originalBlob.type\n                        });\n                        records.push({\n                            uuid: qq.getUniqueId(),\n                            name: self._getName(originalFileName, {\n                                name: sizeRecord.name,\n                                type: outputType,\n                                refType: originalBlob.type\n                            }),\n                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                                customResizeFunction: customResizeFunction,\n                                maxSize: sizeRecord.maxSize,\n                                orient: orient,\n                                type: outputType,\n                                quality: defaultQuality,\n                                failedText: failedToScaleText,\n                                includeExif: includeExif,\n                                log: log\n                            }))\n                        });\n                    });\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: includeOriginal ? originalBlob : null\n                    });\n                } else {\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: originalBlob\n                    });\n                }\n                return records;\n            },\n            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                    var blobSize = record.size, id;\n                    if (record.blob instanceof qq.BlobProxy) {\n                        blobSize = -1;\n                    }\n                    id = uploadData.addFile({\n                        uuid: record.uuid,\n                        name: record.name,\n                        size: blobSize,\n                        batchId: batchId,\n                        proxyGroupId: proxyGroupId\n                    });\n                    if (record.blob instanceof qq.BlobProxy) {\n                        scaledIds.push(id);\n                    } else {\n                        originalId = id;\n                    }\n                    if (record.blob) {\n                        addFileToHandler(id, record.blob);\n                        fileList.push({\n                            id: id,\n                            file: record.blob\n                        });\n                    } else {\n                        uploadData.setStatus(id, qq.status.REJECTED);\n                    }\n                });\n                if (originalId !== null) {\n                    qq.each(scaledIds, function(idx, scaledId) {\n                        var params = {\n                            qqparentuuid: uploadData.retrieve({\n                                id: originalId\n                            }).uuid,\n                            qqparentsize: uploadData.retrieve({\n                                id: originalId\n                            }).size\n                        };\n                        params[uuidParamName] = uploadData.retrieve({\n                            id: scaledId\n                        }).uuid;\n                        uploadData.setParentId(scaledId, originalId);\n                        paramsStore.addReadOnly(scaledId, params);\n                    });\n                    if (scaledIds.length) {\n                        (function() {\n                            var param = {};\n                            param[uuidParamName] = uploadData.retrieve({\n                                id: originalId\n                            }).uuid;\n                            paramsStore.addReadOnly(originalId, param);\n                        })();\n                    }\n                }\n            }\n        });\n    };\n    qq.extend(qq.Scaler.prototype, {\n        scaleImage: function(id, specs, api) {\n            \"use strict\";\n            if (!qq.supportedFeatures.scaling) {\n                throw new qq.Error(\"Scaling is not supported in this browser!\");\n            }\n            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n                id: id\n            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [ {\n                    name: \"\",\n                    maxSize: specs.maxSize\n                } ]\n            }, scaler = new qq.Scaler(scalingOptions, log);\n            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n                scalingEffort.failure();\n                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n            } else {\n                qq.bind(function() {\n                    var record = scaler.getFileRecords(uuid, name, file)[0];\n                    if (record && record.blob instanceof qq.BlobProxy) {\n                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                    } else {\n                        log(id + \" is not a scalable image!\", \"error\");\n                        scalingEffort.failure();\n                    }\n                }, this)();\n            }\n            return scalingEffort;\n        },\n        _determineOutputType: function(spec) {\n            \"use strict\";\n            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n            if (!defaultType && !requestedType) {\n                if (referenceType !== \"image/jpeg\") {\n                    return \"image/png\";\n                }\n                return referenceType;\n            }\n            if (!requestedType) {\n                return defaultType;\n            }\n            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n                if (requestedType === \"image/tiff\") {\n                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n                }\n                return requestedType;\n            }\n            return defaultType;\n        },\n        _getName: function(originalName, scaledVersionProperties) {\n            \"use strict\";\n            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n            }\n            if (startOfExt >= 0) {\n                scaledName = originalName.substr(0, startOfExt);\n                if (referenceType !== versionType) {\n                    scaledExt = versionType.split(\"/\")[1];\n                }\n                scaledName += nameAppendage + \".\" + scaledExt;\n            } else {\n                scaledName = originalName + nameAppendage;\n            }\n            return scaledName;\n        },\n        _getSortedSizes: function(sizes) {\n            \"use strict\";\n            sizes = qq.extend([], sizes);\n            return sizes.sort(function(a, b) {\n                if (a.maxSize > b.maxSize) {\n                    return 1;\n                }\n                if (a.maxSize < b.maxSize) {\n                    return -1;\n                }\n                return 0;\n            });\n        },\n        _generateScaledImage: function(spec, sourceFile) {\n            \"use strict\";\n            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n            imageGenerator.generate(sourceFile, canvas, {\n                maxSize: maxSize,\n                orient: orient,\n                customResizeFunction: customResizeFunction\n            }).then(function() {\n                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n                if (includeExif) {\n                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                        scaledImageDataUri = scaledImageDataUriWithExif;\n                        signalSuccess();\n                    }, function() {\n                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                        signalSuccess();\n                    });\n                } else {\n                    signalSuccess();\n                }\n            }, function() {\n                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n                scalingEffort.failure(failedText);\n            });\n            return scalingEffort;\n        },\n        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n            \"use strict\";\n            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n            reader.onload = function() {\n                originalImageDataUri = reader.result;\n                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n            };\n            reader.onerror = function() {\n                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n                insertionEffort.failure();\n            };\n            reader.readAsDataURL(originalImage);\n            return insertionEffort;\n        },\n        _dataUriToBlob: function(dataUri) {\n            \"use strict\";\n            var byteString, mimeString, arrayBuffer, intArray;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return this._createBlob(arrayBuffer, mimeString);\n        },\n        _createBlob: function(data, mime) {\n            \"use strict\";\n            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n            if (blobBuilder) {\n                blobBuilder.append(data);\n                return blobBuilder.getBlob(mime);\n            } else {\n                return new Blob([ data ], {\n                    type: mime\n                });\n            }\n        }\n    });\n    qq.ExifRestorer = function() {\n        var ExifRestorer = {};\n        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n        ExifRestorer.encode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n            do {\n                chr1 = input[i++];\n                chr2 = input[i++];\n                chr3 = input[i++];\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return output;\n        };\n        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n            var expectedBase64Header = \"data:image/jpeg;base64,\";\n            if (!origFileBase64.match(expectedBase64Header)) {\n                return resizedFileBase64;\n            }\n            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n            var segments = this.slice2Segments(rawImage);\n            var image = this.exifManipulation(resizedFileBase64, segments);\n            return expectedBase64Header + this.encode64(image);\n        };\n        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n            return aBuffer;\n        };\n        ExifRestorer.getExifArray = function(segments) {\n            var seg;\n            for (var x = 0; x < segments.length; x++) {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) {\n                    return seg;\n                }\n            }\n            return [];\n        };\n        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n            return array;\n        };\n        ExifRestorer.slice2Segments = function(rawImageArray) {\n            var head = 0, segments = [];\n            while (1) {\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n                    break;\n                }\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n                    head += 2;\n                } else {\n                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n                    segments.push(seg);\n                    head = endPoint;\n                }\n                if (head > rawImageArray.length) {\n                    break;\n                }\n            }\n            return segments;\n        };\n        ExifRestorer.decode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n            if (base64test.exec(input)) {\n                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n            }\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n            do {\n                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n                chr1 = enc1 << 2 | enc2 >> 4;\n                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n                chr3 = (enc3 & 3) << 6 | enc4;\n                buf.push(chr1);\n                if (enc3 != 64) {\n                    buf.push(chr2);\n                }\n                if (enc4 != 64) {\n                    buf.push(chr3);\n                }\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return buf;\n        };\n        return ExifRestorer;\n    }();\n    qq.TotalProgress = function(callback, getSize) {\n        \"use strict\";\n        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        }, noRetryableFiles = function(failed, retryable) {\n            var none = true;\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n            return none;\n        }, onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        }, onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        }, onNew = function(id) {\n            var size = getSize(id);\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {\n                    loaded: 0,\n                    total: size\n                };\n            }\n        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            } else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n            callbackProxy(totalLoaded, totalSize);\n        };\n        qq.extend(this, {\n            onAllComplete: onAllComplete,\n            onStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                    onCancel(id);\n                } else if (newStatus === qq.status.SUBMITTING) {\n                    onNew(id);\n                }\n            },\n            onIndividualProgress: function(id, loaded, total) {\n                updateTotalProgress(id, loaded, total);\n                perFileProgress[id] = {\n                    loaded: loaded,\n                    total: total\n                };\n            },\n            onNewSize: function(id) {\n                onNew(id);\n            },\n            reset: function() {\n                perFileProgress = {};\n                totalLoaded = 0;\n                totalSize = 0;\n            }\n        });\n    };\n    qq.PasteSupport = function(o) {\n        \"use strict\";\n        var options, detachPasteHandler;\n        options = {\n            targetElement: null,\n            callbacks: {\n                log: function(message, level) {},\n                pasteReceived: function(blob) {}\n            }\n        };\n        function isImage(item) {\n            return item.type && item.type.indexOf(\"image/\") === 0;\n        }\n        function registerPasteHandler() {\n            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n                var clipboardData = event.clipboardData;\n                if (clipboardData) {\n                    qq.each(clipboardData.items, function(idx, item) {\n                        if (isImage(item)) {\n                            var blob = item.getAsFile();\n                            options.callbacks.pasteReceived(blob);\n                        }\n                    });\n                }\n            });\n        }\n        function unregisterPasteHandler() {\n            if (detachPasteHandler) {\n                detachPasteHandler();\n            }\n        }\n        qq.extend(options, o);\n        registerPasteHandler();\n        qq.extend(this, {\n            reset: function() {\n                unregisterPasteHandler();\n            }\n        });\n    };\n    qq.FormSupport = function(options, startUpload, log) {\n        \"use strict\";\n        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n        qq.extend(this, {\n            newEndpoint: null,\n            newAutoUpload: autoUpload,\n            attachedToForm: false,\n            getFormInputsAsObject: function() {\n                if (formEl == null) {\n                    return null;\n                }\n                return self._form2Obj(formEl);\n            }\n        });\n        function determineNewEndpoint(formEl) {\n            if (formEl.getAttribute(\"action\")) {\n                self.newEndpoint = formEl.getAttribute(\"action\");\n            }\n        }\n        function validateForm(formEl, nativeSubmit) {\n            if (formEl.checkValidity && !formEl.checkValidity()) {\n                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n                nativeSubmit();\n            } else {\n                return true;\n            }\n        }\n        function maybeUploadOnSubmit(formEl) {\n            var nativeSubmit = formEl.submit;\n            qq(formEl).attach(\"submit\", function(event) {\n                event = event || window.event;\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n                validateForm(formEl, nativeSubmit) && startUpload();\n            });\n            formEl.submit = function() {\n                validateForm(formEl, nativeSubmit) && startUpload();\n            };\n        }\n        function determineFormEl(formEl) {\n            if (formEl) {\n                if (qq.isString(formEl)) {\n                    formEl = document.getElementById(formEl);\n                }\n                if (formEl) {\n                    log(\"Attaching to form element.\");\n                    determineNewEndpoint(formEl);\n                    interceptSubmit && maybeUploadOnSubmit(formEl);\n                }\n            }\n            return formEl;\n        }\n        formEl = determineFormEl(formEl);\n        this.attachedToForm = !!formEl;\n    };\n    qq.extend(qq.FormSupport.prototype, {\n        _form2Obj: function(form) {\n            \"use strict\";\n            var obj = {}, notIrrelevantType = function(type) {\n                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            }, radioOrCheckbox = function(type) {\n                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n            }, ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            }, selectValue = function(select) {\n                var value = null;\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n                return value;\n            };\n            qq.each(form.elements, function(idx, el) {\n                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n                    obj[el.name] = el.value;\n                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                    var value = selectValue(el);\n                    if (value !== null) {\n                        obj[el.name] = value;\n                    }\n                }\n            });\n            return obj;\n        }\n    });\n    qq.traditional = qq.traditional || {};\n    qq.traditional.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log;\n        function getIframeContentJson(id, iframe) {\n            var response, doc, innerHtml;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                log(\"converting iframe's innerHTML to JSON\");\n                log(\"innerHTML = \" + innerHtml);\n                if (innerHtml && innerHtml.match(/^<pre/i)) {\n                    innerHtml = doc.body.firstChild.firstChild.nodeValue;\n                }\n                response = handler._parseJsonResponse(innerHtml);\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n                response = {\n                    success: false\n                };\n            }\n            return response;\n        }\n        function createForm(id, iframe) {\n            var params = options.paramsStore.get(id), method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\", endpoint = options.endpointStore.get(id), name = getName(id);\n            params[options.uuidName] = getUuid(id);\n            params[options.filenameParam] = name;\n            return handler._initFormForUpload({\n                method: method,\n                endpoint: endpoint,\n                params: params,\n                paramsInBody: options.paramsInBody,\n                targetName: iframe.name\n            });\n        }\n        this.uploadFile = function(id) {\n            var input = handler.getInput(id), iframe = handler._createIframe(id), promise = new qq.Promise(), form;\n            form = createForm(id, iframe);\n            form.appendChild(input);\n            handler._attachLoadEvent(iframe, function(responseFromMessage) {\n                log(\"iframe loaded\");\n                var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n                handler._detachLoadEvent(id);\n                if (!options.cors.expected) {\n                    qq(iframe).remove();\n                }\n                if (response.success) {\n                    promise.success(response);\n                } else {\n                    promise.failure(response);\n                }\n            });\n            log(\"Sending upload request for \" + id);\n            form.submit();\n            qq(form).remove();\n            return promise;\n        };\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: options.cors.expected,\n                inputName: options.inputName\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n    };\n    qq.traditional = qq.traditional || {};\n    qq.traditional.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, log = proxy.log, multipart = spec.forceMultipart || spec.paramsInBody, addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id), name = getName(id);\n            if (!spec.omitDefaultParams) {\n                params[spec.chunking.paramNames.partIndex] = chunkData.part;\n                params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n                params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n                params[spec.chunking.paramNames.totalParts] = chunkData.count;\n                params[spec.totalFileSizeName] = size;\n            }\n            if (multipart && !spec.omitDefaultParams) {\n                params[spec.filenameParam] = name;\n            }\n        }, allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            headers: spec.chunking.success.headers,\n            jsonPayload: spec.chunking.success.jsonPayload,\n            log: log,\n            method: spec.chunking.success.method,\n            params: spec.chunking.success.params\n        }), createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    } else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n            return promise;\n        }, getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id), name = getName(id), size = getSize(id);\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n            return params;\n        }, isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([ 200, 201, 202, 203, 204 ], xhr.status) < 0 || spec.requireSuccessJson && !response.success || response.reset;\n        }, onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n            response = parseResponse(true, xhr);\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        }, parseResponse = function(upload, xhr) {\n            var response = {};\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            } catch (error) {\n                upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n            return response;\n        }, sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n            allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function(xhr) {\n                promise.success(parseResponse(false, xhr), xhr);\n            }, function(xhr) {\n                promise.failure(parseResponse(false, xhr), xhr);\n            });\n            return promise;\n        }, setParamsAndGetEntityToSend = function(entityToSendParams) {\n            var fileOrBlob = entityToSendParams.fileOrBlob;\n            var id = entityToSendParams.id;\n            var xhr = entityToSendParams.xhr;\n            var xhrOverrides = entityToSendParams.xhrOverrides || {};\n            var customParams = entityToSendParams.customParams || {};\n            var defaultParams = entityToSendParams.params || {};\n            var xhrOverrideParams = xhrOverrides.params || {};\n            var params;\n            var formData = multipart ? new FormData() : null, method = xhrOverrides.method || spec.method, endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id), name = getName(id), size = getSize(id);\n            if (spec.omitDefaultParams) {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n            } else {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n                qq.extend(params, defaultParams);\n                params[spec.uuidName] = getUuid(id);\n                params[spec.filenameParam] = name;\n                if (multipart) {\n                    params[spec.totalFileSizeName] = size;\n                } else if (!spec.paramsInBody) {\n                    params[spec.inputName] = name;\n                }\n            }\n            if (!spec.paramsInBody) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            xhr.open(method, endpoint, true);\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n            return fileOrBlob;\n        }, setUploadHeaders = function(headersOptions) {\n            var headerOverrides = headersOptions.headerOverrides;\n            var id = headersOptions.id;\n            var xhr = headersOptions.xhr;\n            if (headerOverrides) {\n                qq.each(headerOverrides, function(headerName, headerValue) {\n                    xhr.setRequestHeader(headerName, headerValue);\n                });\n            } else {\n                var extraHeaders = spec.customHeaders.get(id), fileOrBlob = handler.getFile(id);\n                xhr.setRequestHeader(\"Accept\", \"application/json\");\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                if (!multipart) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                    xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n                }\n                qq.each(extraHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        };\n        qq.extend(this, {\n            uploadChunk: function(uploadChunkParams) {\n                var id = uploadChunkParams.id;\n                var chunkIdx = uploadChunkParams.chunkIdx;\n                var overrides = uploadChunkParams.overrides || {};\n                var resuming = uploadChunkParams.resuming;\n                var chunkData = handler._getChunkData(id, chunkIdx), xhr = handler._createXhr(id, chunkIdx), promise, toSend, customParams, params = {};\n                promise = createReadyStateChangedHandler(id, xhr);\n                handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                customParams = spec.paramsStore.get(id);\n                addChunkingSpecificParams(id, params, chunkData);\n                if (resuming) {\n                    params[spec.resume.paramNames.resuming] = true;\n                }\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: chunkData.blob,\n                    id: id,\n                    customParams: customParams,\n                    params: params,\n                    xhr: xhr,\n                    xhrOverrides: overrides\n                });\n                setUploadHeaders({\n                    headerOverrides: overrides.headers,\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            },\n            uploadFile: function(id) {\n                var fileOrBlob = handler.getFile(id), promise, xhr, customParams, toSend;\n                xhr = handler._createXhr(id);\n                handler._registerProgressHandler(id);\n                promise = createReadyStateChangedHandler(id, xhr);\n                customParams = spec.paramsStore.get(id);\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: fileOrBlob,\n                    id: id,\n                    customParams: customParams,\n                    xhr: xhr\n                });\n                setUploadHeaders({\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            }\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"traditional\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                finalizeChunks: function(id) {\n                    proxy.onFinalizing(id);\n                    if (spec.chunking.success.endpoint) {\n                        return sendChunksCompleteRequest(id);\n                    } else {\n                        return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                    }\n                }\n            };\n        });\n    };\n    qq.traditional.AllChunksDoneAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {},\n            method: \"POST\"\n        }, promises = {}, endpointHandler = {\n            get: function(id) {\n                if (qq.isFunction(options.endpoint)) {\n                    return options.endpoint(id);\n                }\n                return options.endpoint;\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n            validMethods: [ options.method ],\n            method: options.method,\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: options.cors,\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure(xhr);\n                } else {\n                    promise.success(xhr);\n                }\n            }\n        }));\n        qq.extend(this, {\n            complete: function(id, xhr, params, headers) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting All Chunks Done request for \" + id);\n                promises[id] = promise;\n                requester.initTransport(id).withParams(options.params(id) || params).withHeaders(options.headers(id) || headers).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.DragAndDrop = function(o) {\n        \"use strict\";\n        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n        options = {\n            dropZoneElements: [],\n            allowMultipleItems: true,\n            classes: {\n                dropActive: null\n            },\n            callbacks: new qq.DragAndDrop.callbacks()\n        };\n        qq.extend(options, o, true);\n        function uploadDroppedFiles(files, uploadDropZone) {\n            var filesAsArray = Array.prototype.slice.call(files);\n            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n            uploadDropZone.dropDisabled(false);\n            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n        }\n        function traverseFileTree(entry) {\n            var parseEntryPromise = new qq.Promise();\n            if (entry.isFile) {\n                entry.file(function(file) {\n                    file.qqPath = extractDirectoryPath(entry);\n                    droppedFiles.push(file);\n                    parseEntryPromise.success();\n                }, function(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            } else if (entry.isDirectory) {\n                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n                    var entriesLeft = entries.length;\n                    qq.each(entries, function(idx, entry) {\n                        traverseFileTree(entry).done(function() {\n                            entriesLeft -= 1;\n                            if (entriesLeft === 0) {\n                                parseEntryPromise.success();\n                            }\n                        });\n                    });\n                    if (!entries.length) {\n                        parseEntryPromise.success();\n                    }\n                }, function readFailure(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            }\n            return parseEntryPromise;\n        }\n        function extractDirectoryPath(entry) {\n            var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.lastIndexOf(name);\n            fullPath = fullPath.substr(0, indexOfNameInFullPath);\n            if (fullPath.charAt(0) === \"/\") {\n                fullPath = fullPath.substr(1);\n            }\n            return fullPath;\n        }\n        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n            dirReader.readEntries(function readSuccess(entries) {\n                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n                if (entries.length) {\n                    setTimeout(function() {\n                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n                    }, 0);\n                } else {\n                    promise.success(newEntries);\n                }\n            }, promise.failure);\n            return promise;\n        }\n        function handleDataTransfer(dataTransfer, uploadDropZone) {\n            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n            options.callbacks.processingDroppedFiles();\n            uploadDropZone.dropDisabled(true);\n            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n                options.callbacks.processingDroppedFilesComplete([]);\n                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n                uploadDropZone.dropDisabled(false);\n                handleDataTransferPromise.failure();\n            } else {\n                droppedFiles = [];\n                if (qq.isFolderDropSupported(dataTransfer)) {\n                    qq.each(dataTransfer.items, function(idx, item) {\n                        var entry = item.webkitGetAsEntry();\n                        if (entry) {\n                            if (entry.isFile) {\n                                droppedFiles.push(item.getAsFile());\n                            } else {\n                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n                                    pendingFolderPromises.pop();\n                                    if (pendingFolderPromises.length === 0) {\n                                        handleDataTransferPromise.success();\n                                    }\n                                }));\n                            }\n                        }\n                    });\n                } else {\n                    droppedFiles = dataTransfer.files;\n                }\n                if (pendingFolderPromises.length === 0) {\n                    handleDataTransferPromise.success();\n                }\n            }\n            return handleDataTransferPromise;\n        }\n        function setupDropzone(dropArea) {\n            var dropZone = new qq.UploadDropZone({\n                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n                element: dropArea,\n                onEnter: function(e) {\n                    qq(dropArea).addClass(options.classes.dropActive);\n                    e.stopPropagation();\n                },\n                onLeaveNotDescendants: function(e) {\n                    qq(dropArea).removeClass(options.classes.dropActive);\n                },\n                onDrop: function(e) {\n                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n                        uploadDroppedFiles(droppedFiles, dropZone);\n                    }, function() {\n                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n                    });\n                }\n            });\n            disposeSupport.addDisposer(function() {\n                dropZone.dispose();\n            });\n            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n            uploadDropZones.push(dropZone);\n            return dropZone;\n        }\n        function isFileDrag(dragEvent) {\n            var fileDrag;\n            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n                if (val === \"Files\") {\n                    fileDrag = true;\n                    return false;\n                }\n            });\n            return fileDrag;\n        }\n        function leavingDocumentOut(e) {\n            if (qq.safari()) {\n                return e.x < 0 || e.y < 0;\n            }\n            return e.x === 0 && e.y === 0;\n        }\n        function setupDragDrop() {\n            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n                setTimeout(function() {\n                    qq.each(dropZones, function(idx, dropZone) {\n                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n                        qq(dropZone).removeClass(options.classes.dropActive);\n                    });\n                }, 10);\n            };\n            qq.each(dropZones, function(idx, dropZone) {\n                var uploadDropZone = setupDropzone(dropZone);\n                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n                    disposeSupport.attach(document, \"dragenter\", function(e) {\n                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n                            qq.each(dropZones, function(idx, dropZone) {\n                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n                                    qq(dropZone).css({\n                                        display: \"block\"\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            disposeSupport.attach(document, \"dragleave\", function(e) {\n                if (leavingDocumentOut(e)) {\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, \"drop\", function(e) {\n                if (isFileDrag(e)) {\n                    e.preventDefault();\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n        }\n        setupDragDrop();\n        qq.extend(this, {\n            setupExtraDropzone: function(element) {\n                options.dropZoneElements.push(element);\n                setupDropzone(element);\n            },\n            removeDropzone: function(element) {\n                var i, dzs = options.dropZoneElements;\n                for (i in dzs) {\n                    if (dzs[i] === element) {\n                        return dzs.splice(i, 1);\n                    }\n                }\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n                qq.each(uploadDropZones, function(idx, dropZone) {\n                    dropZone.dispose();\n                });\n            }\n        });\n        this._testing = {};\n        this._testing.extractDirectoryPath = extractDirectoryPath;\n    };\n    qq.DragAndDrop.callbacks = function() {\n        \"use strict\";\n        return {\n            processingDroppedFiles: function() {},\n            processingDroppedFilesComplete: function(files, targetEl) {},\n            dropError: function(code, errorSpecifics) {\n                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n            },\n            dropLog: function(message, level) {\n                qq.log(message, level);\n            }\n        };\n    };\n    qq.UploadDropZone = function(o) {\n        \"use strict\";\n        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n        options = {\n            element: null,\n            onEnter: function(e) {},\n            onLeave: function(e) {},\n            onLeaveNotDescendants: function(e) {},\n            onDrop: function(e) {}\n        };\n        qq.extend(options, o);\n        element = options.element;\n        function dragoverShouldBeCanceled() {\n            return qq.safari() || qq.firefox() && qq.windows();\n        }\n        function disableDropOutside(e) {\n            if (!dropOutsideDisabled) {\n                if (dragoverShouldBeCanceled) {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        if (e.dataTransfer) {\n                            e.dataTransfer.dropEffect = \"none\";\n                            e.preventDefault();\n                        }\n                    });\n                }\n                dropOutsideDisabled = true;\n            }\n        }\n        function isValidFileDrag(e) {\n            if (!qq.supportedFeatures.fileDrop) {\n                return false;\n            }\n            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n            return dt && effectTest && (dt.files && dt.files.length || !isSafari && dt.types.contains && dt.types.contains(\"Files\") || dt.types.includes && dt.types.includes(\"Files\"));\n        }\n        function isOrSetDropDisabled(isDisabled) {\n            if (isDisabled !== undefined) {\n                preventDrop = isDisabled;\n            }\n            return preventDrop;\n        }\n        function triggerHidezonesEvent() {\n            var hideZonesEvent;\n            function triggerUsingOldApi() {\n                hideZonesEvent = document.createEvent(\"Event\");\n                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n            }\n            if (window.CustomEvent) {\n                try {\n                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n                } catch (err) {\n                    triggerUsingOldApi();\n                }\n            } else {\n                triggerUsingOldApi();\n            }\n            document.dispatchEvent(hideZonesEvent);\n        }\n        function attachEvents() {\n            disposeSupport.attach(element, \"dragover\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n                if (effect === \"move\" || effect === \"linkMove\") {\n                    e.dataTransfer.dropEffect = \"move\";\n                } else {\n                    e.dataTransfer.dropEffect = \"copy\";\n                }\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            disposeSupport.attach(element, \"dragenter\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    options.onEnter(e);\n                }\n            });\n            disposeSupport.attach(element, \"dragleave\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                options.onLeave(e);\n                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n                if (qq(this).contains(relatedTarget)) {\n                    return;\n                }\n                options.onLeaveNotDescendants(e);\n            });\n            disposeSupport.attach(element, \"drop\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    options.onDrop(e);\n                    triggerHidezonesEvent();\n                }\n            });\n        }\n        disableDropOutside();\n        attachEvents();\n        qq.extend(this, {\n            dropDisabled: function(isDisabled) {\n                return isOrSetDropDisabled(isDisabled);\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n            },\n            getElement: function() {\n                return element;\n            }\n        });\n        this._testing = {};\n        this._testing.isValidFileDrag = isValidFileDrag;\n    };\n    (function() {\n        \"use strict\";\n        qq.uiPublicApi = {\n            addInitialFiles: function(cannedFileList) {\n                this._parent.prototype.addInitialFiles.apply(this, arguments);\n                this._templating.addCacheToDom();\n            },\n            clearStoredFiles: function() {\n                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n                this._templating.clearFiles();\n            },\n            addExtraDropzone: function(element) {\n                this._dnd && this._dnd.setupExtraDropzone(element);\n            },\n            removeExtraDropzone: function(element) {\n                if (this._dnd) {\n                    return this._dnd.removeDropzone(element);\n                }\n            },\n            getItemByFileId: function(id) {\n                if (!this._templating.isHiddenForever(id)) {\n                    return this._templating.getFileContainer(id);\n                }\n            },\n            reset: function() {\n                this._parent.prototype.reset.apply(this, arguments);\n                this._templating.reset();\n                if (!this._options.button && this._templating.getButton()) {\n                    this._defaultButtonId = this._createUploadButton({\n                        element: this._templating.getButton(),\n                        title: this._options.text.fileInputTitle\n                    }).getButtonId();\n                }\n                if (this._dnd) {\n                    this._dnd.dispose();\n                    this._dnd = this._setupDragAndDrop();\n                }\n                this._totalFilesInBatch = 0;\n                this._filesInBatchAddedToUi = 0;\n                this._setupClickAndEditEventHandlers();\n            },\n            setName: function(id, newName) {\n                var formattedFilename = this._options.formatFileName(newName);\n                this._parent.prototype.setName.apply(this, arguments);\n                this._templating.updateFilename(id, formattedFilename);\n            },\n            pauseUpload: function(id) {\n                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n                paused && this._templating.uploadPaused(id);\n                return paused;\n            },\n            continueUpload: function(id) {\n                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n                continued && this._templating.uploadContinued(id);\n                return continued;\n            },\n            getId: function(fileContainerOrChildEl) {\n                return this._templating.getFileId(fileContainerOrChildEl);\n            },\n            getDropTarget: function(fileId) {\n                var file = this.getFile(fileId);\n                return file.qqDropTarget;\n            }\n        };\n        qq.uiPrivateApi = {\n            _getButton: function(buttonId) {\n                var button = this._parent.prototype._getButton.apply(this, arguments);\n                if (!button) {\n                    if (buttonId === this._defaultButtonId) {\n                        button = this._templating.getButton();\n                    }\n                }\n                return button;\n            },\n            _removeFileItem: function(fileId) {\n                this._templating.removeFile(fileId);\n            },\n            _setupClickAndEditEventHandlers: function() {\n                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n                this._focusinEventSupported = !qq.firefox();\n                if (this._isEditFilenameEnabled()) {\n                    this._filenameClickHandler = this._bindFilenameClickEvent();\n                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n                }\n            },\n            _setupDragAndDrop: function() {\n                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n                defaultDropZone && dropZoneElements.push(defaultDropZone);\n                return new qq.DragAndDrop({\n                    dropZoneElements: dropZoneElements,\n                    allowMultipleItems: this._options.multiple,\n                    classes: {\n                        dropActive: this._options.classes.dropActive\n                    },\n                    callbacks: {\n                        processingDroppedFiles: function() {\n                            templating.showDropProcessing();\n                        },\n                        processingDroppedFilesComplete: function(files, targetEl) {\n                            templating.hideDropProcessing();\n                            qq.each(files, function(idx, file) {\n                                file.qqDropTarget = targetEl;\n                            });\n                            if (files.length) {\n                                self.addFiles(files, null, null);\n                            }\n                        },\n                        dropError: function(code, errorData) {\n                            self._itemError(code, errorData);\n                        },\n                        dropLog: function(message, level) {\n                            self.log(message, level);\n                        }\n                    }\n                });\n            },\n            _bindFileButtonsClickEvent: function() {\n                var self = this;\n                return new qq.FileButtonsClickHandler({\n                    templating: this._templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onDeleteFile: function(fileId) {\n                        self.deleteFile(fileId);\n                    },\n                    onCancel: function(fileId) {\n                        self.cancel(fileId);\n                    },\n                    onRetry: function(fileId) {\n                        self.retry(fileId);\n                    },\n                    onPause: function(fileId) {\n                        self.pauseUpload(fileId);\n                    },\n                    onContinue: function(fileId) {\n                        self.continueUpload(fileId);\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    }\n                });\n            },\n            _isEditFilenameEnabled: function() {\n                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n            },\n            _filenameEditHandler: function() {\n                var self = this, templating = this._templating;\n                return {\n                    templating: templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onGetUploadStatus: function(fileId) {\n                        return self.getUploads({\n                            id: fileId\n                        }).status;\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    },\n                    onSetName: function(id, newName) {\n                        self.setName(id, newName);\n                    },\n                    onEditingStatusChange: function(id, isEditing) {\n                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n                        if (isEditing) {\n                            qqInput.addClass(\"qq-editing\");\n                            templating.hideFilename(id);\n                            templating.hideEditIcon(id);\n                        } else {\n                            qqInput.removeClass(\"qq-editing\");\n                            templating.showFilename(id);\n                            templating.showEditIcon(id);\n                        }\n                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n                    }\n                };\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n                if (this._isEditFilenameEnabled()) {\n                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n                        this._templating.markFilenameEditable(id);\n                        this._templating.hideEditIcon(id);\n                    }\n                }\n                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n                    this._templating.hideRetry(id);\n                    this._templating.setStatusText(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n                    this._templating.hidePause(id);\n                }\n            },\n            _bindFilenameInputFocusInEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusInHandler(spec);\n            },\n            _bindFilenameInputFocusEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusHandler(spec);\n            },\n            _bindFilenameClickEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameClickHandler(spec);\n            },\n            _storeForLater: function(id) {\n                this._parent.prototype._storeForLater.apply(this, arguments);\n                this._templating.hideSpinner(id);\n            },\n            _onAllComplete: function(successful, failed) {\n                this._parent.prototype._onAllComplete.apply(this, arguments);\n                this._templating.resetTotalProgress();\n            },\n            _onSubmit: function(id, name) {\n                var file = this.getFile(id);\n                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n                    this._paramsStore.addReadOnly(id, {\n                        qqpath: file.qqPath\n                    });\n                }\n                this._parent.prototype._onSubmit.apply(this, arguments);\n                this._addToList(id, name);\n            },\n            _onSubmitted: function(id) {\n                if (this._isEditFilenameEnabled()) {\n                    this._templating.markFilenameEditable(id);\n                    this._templating.showEditIcon(id);\n                    if (!this._focusinEventSupported) {\n                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                    }\n                }\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._parent.prototype._onProgress.apply(this, arguments);\n                this._templating.updateProgress(id, loaded, total);\n                if (total === 0 || Math.round(loaded / total * 100) === 100) {\n                    this._templating.hideCancel(id);\n                    this._templating.hidePause(id);\n                    this._templating.hideProgress(id);\n                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n                    this._displayFileSize(id);\n                } else {\n                    this._displayFileSize(id, loaded, total);\n                }\n            },\n            _onTotalProgress: function(loaded, total) {\n                this._parent.prototype._onTotalProgress.apply(this, arguments);\n                this._templating.updateTotalProgress(loaded, total);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n                function completeUpload(result) {\n                    if (!fileContainer) {\n                        return;\n                    }\n                    templating.setStatusText(id);\n                    qq(fileContainer).removeClass(self._classes.retrying);\n                    templating.hideProgress(id);\n                    if (self.getUploads({\n                        id: id\n                    }).status !== qq.status.UPLOAD_FAILED) {\n                        templating.hideCancel(id);\n                    }\n                    templating.hideSpinner(id);\n                    if (result.success) {\n                        self._markFileAsSuccessful(id);\n                    } else {\n                        qq(fileContainer).addClass(self._classes.fail);\n                        templating.showCancel(id);\n                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n                            qq(fileContainer).addClass(self._classes.retryable);\n                            templating.showRetry(id);\n                        }\n                        self._controlFailureTextDisplay(id, result);\n                    }\n                }\n                if (parentRetVal instanceof qq.Promise) {\n                    parentRetVal.done(function(newResult) {\n                        completeUpload(newResult);\n                    });\n                } else {\n                    completeUpload(result);\n                }\n                return parentRetVal;\n            },\n            _markFileAsSuccessful: function(id) {\n                var templating = this._templating;\n                if (this._isDeletePossible()) {\n                    templating.showDeleteButton(id);\n                }\n                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n                this._maybeUpdateThumbnail(id);\n            },\n            _onUploadPrep: function(id) {\n                this._parent.prototype._onUploadPrep.apply(this, arguments);\n                this._templating.showSpinner(id);\n            },\n            _onUpload: function(id, name) {\n                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n                this._templating.showSpinner(id);\n                return parentRetVal;\n            },\n            _onUploadChunk: function(id, chunkData) {\n                this._parent.prototype._onUploadChunk.apply(this, arguments);\n                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n                    this._templating.allowPause(id);\n                }\n            },\n            _onCancel: function(id, name) {\n                this._parent.prototype._onCancel.apply(this, arguments);\n                this._removeFileItem(id);\n                if (this._getNotFinished() === 0) {\n                    this._templating.resetTotalProgress();\n                }\n            },\n            _onBeforeAutoRetry: function(id) {\n                var retryNumForDisplay, maxAuto, retryNote;\n                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n                this._showCancelLink(id);\n                if (this._options.retry.showAutoRetryNote) {\n                    retryNumForDisplay = this._autoRetries[id];\n                    maxAuto = this._options.retry.maxAutoAttempts;\n                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n                    this._templating.setStatusText(id, retryNote);\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n                }\n            },\n            _onBeforeManualRetry: function(id) {\n                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n                    this._templating.resetProgress(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n                    this._templating.setStatusText(id);\n                    this._templating.showSpinner(id);\n                    this._showCancelLink(id);\n                    return true;\n                } else {\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n                    this._templating.showRetry(id);\n                    return false;\n                }\n            },\n            _onSubmitDelete: function(id) {\n                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n            },\n            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n                if (this._options.deleteFile.forceConfirm) {\n                    this._showDeleteConfirm.apply(this, arguments);\n                } else {\n                    this._sendDeleteRequest.apply(this, arguments);\n                }\n            },\n            _onDeleteComplete: function(id, xhr, isError) {\n                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n                this._templating.hideSpinner(id);\n                if (isError) {\n                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n                    this._templating.showDeleteButton(id);\n                } else {\n                    this._removeFileItem(id);\n                }\n            },\n            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n                this._templating.hideDeleteButton(id);\n                this._templating.showSpinner(id);\n                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n                this._deleteHandler.sendDelete.apply(this, arguments);\n            },\n            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n                retVal = this._options.showConfirm(confirmMessage);\n                if (qq.isGenericPromise(retVal)) {\n                    retVal.then(function() {\n                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                    });\n                } else if (retVal !== false) {\n                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                }\n            },\n            _addToList: function(id, name, canned) {\n                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n                if (this._options.display.prependFiles) {\n                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n                        prependIndex = this._filesInBatchAddedToUi - 1;\n                    }\n                    prependData = {\n                        index: prependIndex\n                    };\n                }\n                if (!canned) {\n                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n                        this._templating.disableCancel();\n                    }\n                    if (!this._options.multiple) {\n                        record = this.getUploads({\n                            id: id\n                        });\n                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n                            this._handler.cancelAll();\n                            this._clearList();\n                            this._handledProxyGroup = null;\n                        }\n                    }\n                }\n                if (canned) {\n                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n                } else {\n                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n                }\n                this._filesInBatchAddedToUi += 1;\n                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n                    this._displayFileSize(id);\n                }\n            },\n            _clearList: function() {\n                this._templating.clearFiles();\n                this.clearStoredFiles();\n            },\n            _displayFileSize: function(id, loadedSize, totalSize) {\n                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n                if (size >= 0) {\n                    if (loadedSize !== undefined && totalSize !== undefined) {\n                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n                    }\n                    this._templating.updateSize(id, sizeForDisplay);\n                }\n            },\n            _formatProgress: function(uploadedSize, totalSize) {\n                var message = this._options.text.formatProgress;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n                r(\"{total_size}\", this._formatSize(totalSize));\n                return message;\n            },\n            _controlFailureTextDisplay: function(id, response) {\n                var mode, responseProperty, failureReason;\n                mode = this._options.failedUploadTextDisplay.mode;\n                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n                if (mode === \"custom\") {\n                    failureReason = response[responseProperty];\n                    if (!failureReason) {\n                        failureReason = this._options.text.failUpload;\n                    }\n                    this._templating.setStatusText(id, failureReason);\n                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n                        this._showTooltip(id, failureReason);\n                    }\n                } else if (mode === \"default\") {\n                    this._templating.setStatusText(id, this._options.text.failUpload);\n                } else if (mode !== \"none\") {\n                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n                }\n            },\n            _showTooltip: function(id, text) {\n                this._templating.getFileContainer(id).title = text;\n            },\n            _showCancelLink: function(id) {\n                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n                    this._templating.showCancel(id);\n                }\n            },\n            _itemError: function(code, name, item) {\n                var message = this._parent.prototype._itemError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _batchError: function(message) {\n                this._parent.prototype._batchError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _setupPastePrompt: function() {\n                var self = this;\n                this._options.callbacks.onPasteReceived = function() {\n                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n                    return self._options.showPrompt(message, defaultVal);\n                };\n            },\n            _fileOrBlobRejected: function(id, name) {\n                this._totalFilesInBatch -= 1;\n                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                this._totalFilesInBatch = items.length;\n                this._filesInBatchAddedToUi = 0;\n                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n            },\n            _maybeUpdateThumbnail: function(fileId) {\n                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n                    id: fileId\n                }).status;\n                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n                this._addToList(id, this.getName(id), true);\n                this._templating.hideSpinner(id);\n                this._templating.hideCancel(id);\n                this._markFileAsSuccessful(id);\n                return id;\n            },\n            _setSize: function(id, newSize) {\n                this._parent.prototype._setSize.apply(this, arguments);\n                this._templating.updateSize(id, this._formatSize(newSize));\n            },\n            _sessionRequestComplete: function() {\n                this._templating.addCacheToDom();\n                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n            }\n        };\n    })();\n    qq.FineUploader = function(o, namespace) {\n        \"use strict\";\n        var self = this;\n        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n        this._parent.apply(this, arguments);\n        qq.extend(this._options, {\n            element: null,\n            button: null,\n            listElement: null,\n            dragAndDrop: {\n                extraDropzones: [],\n                reportDirectoryPaths: false\n            },\n            text: {\n                formatProgress: \"{percent}% of {total_size}\",\n                failUpload: \"Upload failed\",\n                waitingForResponse: \"Processing...\",\n                paused: \"Paused\"\n            },\n            template: \"qq-template\",\n            classes: {\n                retrying: \"qq-upload-retrying\",\n                retryable: \"qq-upload-retryable\",\n                success: \"qq-upload-success\",\n                fail: \"qq-upload-fail\",\n                editable: \"qq-editable\",\n                hide: \"qq-hide\",\n                dropActive: \"qq-upload-drop-area-active\"\n            },\n            failedUploadTextDisplay: {\n                mode: \"default\",\n                responseProperty: \"error\",\n                enableTooltip: true\n            },\n            messages: {\n                tooManyFilesError: \"You may only drop one file\",\n                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n            },\n            retry: {\n                showAutoRetryNote: true,\n                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n            },\n            deleteFile: {\n                forceConfirm: false,\n                confirmMessage: \"Are you sure you want to delete {filename}?\",\n                deletingStatusText: \"Deleting...\",\n                deletingFailedText: \"Delete failed\"\n            },\n            display: {\n                fileSizeOnSubmit: false,\n                prependFiles: false\n            },\n            paste: {\n                promptForName: false,\n                namePromptMessage: \"Please name this image\"\n            },\n            thumbnails: {\n                customResizer: null,\n                maxCount: 0,\n                placeholders: {\n                    waitUntilResponse: false,\n                    notAvailablePath: null,\n                    waitingPath: null\n                },\n                timeBetweenThumbs: 750\n            },\n            scaling: {\n                hideScaled: false\n            },\n            showMessage: function(message) {\n                if (self._templating.hasDialog(\"alert\")) {\n                    return self._templating.showDialog(\"alert\", message);\n                } else {\n                    setTimeout(function() {\n                        window.alert(message);\n                    }, 0);\n                }\n            },\n            showConfirm: function(message) {\n                if (self._templating.hasDialog(\"confirm\")) {\n                    return self._templating.showDialog(\"confirm\", message);\n                } else {\n                    return window.confirm(message);\n                }\n            },\n            showPrompt: function(message, defaultValue) {\n                if (self._templating.hasDialog(\"prompt\")) {\n                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n                } else {\n                    return window.prompt(message, defaultValue);\n                }\n            }\n        }, true);\n        qq.extend(this._options, o, true);\n        this._templating = new qq.Templating({\n            log: qq.bind(this.log, this),\n            templateIdOrEl: this._options.template,\n            containerEl: this._options.element,\n            fileContainerEl: this._options.listElement,\n            button: this._options.button,\n            imageGenerator: this._imageGenerator,\n            classes: {\n                hide: this._options.classes.hide,\n                editable: this._options.classes.editable\n            },\n            limits: {\n                maxThumbs: this._options.thumbnails.maxCount,\n                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n            },\n            placeholders: {\n                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n            },\n            text: this._options.text\n        });\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n        } else {\n            this._wrapCallbacks();\n            this._templating.render();\n            this._classes = this._options.classes;\n            if (!this._options.button && this._templating.getButton()) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._templating.getButton(),\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._setupClickAndEditEventHandlers();\n            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n                this._dnd = this._setupDragAndDrop();\n            }\n            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n                if (qq.PasteSupport) {\n                    this._setupPastePrompt();\n                } else {\n                    this.log(\"Paste support module not found.\", \"error\");\n                }\n            }\n            this._totalFilesInBatch = 0;\n            this._filesInBatchAddedToUi = 0;\n        }\n    };\n    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n    qq.Templating = function(spec) {\n        \"use strict\";\n        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n            content: document.createDocumentFragment(),\n            map: {}\n        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n            log: null,\n            limits: {\n                maxThumbs: 0,\n                timeBetweenThumbs: 750\n            },\n            templateIdOrEl: \"qq-template\",\n            containerEl: null,\n            fileContainerEl: null,\n            button: null,\n            imageGenerator: null,\n            classes: {\n                hide: \"qq-hide\",\n                editable: \"qq-editable\"\n            },\n            placeholders: {\n                waitUntilUpdate: false,\n                thumbnailNotAvailable: null,\n                waitingForThumbnail: null\n            },\n            text: {\n                paused: \"Paused\"\n            }\n        }, selectorClasses = {\n            button: \"qq-upload-button-selector\",\n            alertDialog: \"qq-alert-dialog-selector\",\n            dialogCancelButton: \"qq-cancel-button-selector\",\n            confirmDialog: \"qq-confirm-dialog-selector\",\n            dialogMessage: \"qq-dialog-message-selector\",\n            dialogOkButton: \"qq-ok-button-selector\",\n            promptDialog: \"qq-prompt-dialog-selector\",\n            uploader: \"qq-uploader-selector\",\n            drop: \"qq-upload-drop-area-selector\",\n            list: \"qq-upload-list-selector\",\n            progressBarContainer: \"qq-progress-bar-container-selector\",\n            progressBar: \"qq-progress-bar-selector\",\n            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n            totalProgressBar: \"qq-total-progress-bar-selector\",\n            file: \"qq-upload-file-selector\",\n            spinner: \"qq-upload-spinner-selector\",\n            size: \"qq-upload-size-selector\",\n            cancel: \"qq-upload-cancel-selector\",\n            pause: \"qq-upload-pause-selector\",\n            continueButton: \"qq-upload-continue-selector\",\n            deleteButton: \"qq-upload-delete-selector\",\n            retry: \"qq-upload-retry-selector\",\n            statusText: \"qq-upload-status-text-selector\",\n            editFilenameInput: \"qq-edit-filename-selector\",\n            editNameIcon: \"qq-edit-filename-icon-selector\",\n            dropText: \"qq-upload-drop-area-text-selector\",\n            dropProcessing: \"qq-drop-processing-selector\",\n            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n            thumbnail: \"qq-thumbnail-selector\"\n        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateDom, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n                maxSize: thumbnailMaxSize,\n                scale: serverScale\n            };\n            if (showThumbnails) {\n                if (notAvailableUrl) {\n                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedThumbnailNotAvailableImg.success(updatedImg);\n                    }, function() {\n                        cachedThumbnailNotAvailableImg.failure();\n                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n                    });\n                } else {\n                    cachedThumbnailNotAvailableImg.failure();\n                }\n                if (waitingUrl) {\n                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedWaitingForThumbnailImg.success(updatedImg);\n                    }, function() {\n                        cachedWaitingForThumbnailImg.failure();\n                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n                    });\n                } else {\n                    cachedWaitingForThumbnailImg.failure();\n                }\n            }\n        }, displayWaitingImg = function(thumbnail) {\n            var waitingImgPlacement = new qq.Promise();\n            cachedWaitingForThumbnailImg.then(function(img) {\n                maybeScalePlaceholderViaCss(img, thumbnail);\n                if (!thumbnail.src) {\n                    thumbnail.src = img.src;\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        show(thumbnail);\n                        waitingImgPlacement.success();\n                    };\n                } else {\n                    waitingImgPlacement.success();\n                }\n            }, function() {\n                hide(thumbnail);\n                waitingImgPlacement.success();\n            });\n            return waitingImgPlacement;\n        }, generateNewPreview = function(id, blob, spec) {\n            var thumbnail = getThumbnail(id);\n            log(\"Generating new thumbnail for \" + id);\n            blob.qqThumbnailId = id;\n            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n                generatedThumbnails++;\n                show(thumbnail);\n                previewGeneration[id].success();\n            }, function() {\n                previewGeneration[id].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                }\n            });\n        }, generateNextQueuedPreview = function() {\n            if (thumbGenerationQueue.length) {\n                thumbnailQueueMonitorRunning = true;\n                var queuedThumbRequest = thumbGenerationQueue.shift();\n                if (queuedThumbRequest.update) {\n                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n                } else {\n                    processNewQueuedPreviewRequest(queuedThumbRequest);\n                }\n            } else {\n                thumbnailQueueMonitorRunning = false;\n            }\n        }, getCancel = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.cancel);\n        }, getContinue = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n        }, getDialog = function(type) {\n            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n        }, getDelete = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n        }, getDropProcessing = function() {\n            return getTemplateEl(container, selectorClasses.dropProcessing);\n        }, getEditIcon = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n        }, getFile = function(id) {\n            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n        }, getFilename = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.file);\n        }, getPause = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.pause);\n        }, getProgress = function(id) {\n            if (id == null) {\n                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n            }\n            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n        }, getRetry = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.retry);\n        }, getSize = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.size);\n        }, getSpinner = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.spinner);\n        }, getTemplateEl = function(context, cssClass) {\n            return context && qq(context).getFirstByClass(cssClass);\n        }, getThumbnail = function(id) {\n            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n        }, hide = function(el) {\n            el && qq(el).addClass(options.classes.hide);\n        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n                qq(thumbnail).css({\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight\n                });\n            }\n        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n            cachedThumbnailNotAvailableImg.then(function(img) {\n                previewing.then(function() {\n                    notAvailableImgPlacement.success();\n                }, function() {\n                    maybeScalePlaceholderViaCss(img, thumbnail);\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        notAvailableImgPlacement.success();\n                    };\n                    thumbnail.src = img.src;\n                    show(thumbnail);\n                });\n            });\n            return notAvailableImgPlacement;\n        }, parseAndGetTemplate = function() {\n            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListEl, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n            log(\"Parsing template\");\n            if (options.templateIdOrEl == null) {\n                throw new Error(\"You MUST specify either a template element or ID!\");\n            }\n            if (qq.isString(options.templateIdOrEl)) {\n                scriptEl = document.getElementById(options.templateIdOrEl);\n                if (scriptEl === null) {\n                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n                }\n                scriptHtml = scriptEl.innerHTML;\n            } else {\n                if (options.templateIdOrEl.innerHTML === undefined) {\n                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n                }\n                scriptHtml = options.templateIdOrEl.innerHTML;\n            }\n            scriptHtml = qq.trimStr(scriptHtml);\n            tempTemplateEl = document.createElement(\"div\");\n            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n            if (options.button) {\n                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n                if (defaultButton) {\n                    qq(defaultButton).remove();\n                }\n            }\n            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n                if (dropProcessing) {\n                    qq(dropProcessing).remove();\n                }\n            }\n            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n            if (dropArea && !qq.DragAndDrop) {\n                log(\"DnD module unavailable.\", \"info\");\n                qq(dropArea).remove();\n            }\n            if (!qq.supportedFeatures.fileDrop) {\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n                    qq(dropArea).css({\n                        display: \"none\"\n                    });\n                }\n            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n                dropTextEl && qq(dropTextEl).remove();\n            }\n            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n            if (!showThumbnails) {\n                thumbnail && qq(thumbnail).remove();\n            } else if (thumbnail) {\n                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n            }\n            showThumbnails = showThumbnails && thumbnail;\n            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n            if (fileListNode == null) {\n                throw new Error(\"Could not find the file list container in the template!\");\n            }\n            fileListEl = fileListNode.children[0].cloneNode(true);\n            fileListNode.innerHTML = \"\";\n            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n                document.createElement(\"dialog\");\n            }\n            log(\"Template parsing complete\");\n            return {\n                template: tempTemplateEl,\n                fileTemplate: fileListEl\n            };\n        }, prependFile = function(el, index, fileList) {\n            var parentEl = fileList, beforeEl = parentEl.firstChild;\n            if (index > 0) {\n                beforeEl = qq(parentEl).children()[index].nextSibling;\n            }\n            parentEl.insertBefore(el, beforeEl);\n        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                maxSize: thumbnailMaxSize,\n                orient: true,\n                scale: true\n            };\n            if (qq.supportedFeatures.imagePreviews) {\n                if (thumbnail) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        displayWaitingImg(thumbnail).done(function() {\n                            previewGeneration[id] = new qq.Promise();\n                            previewGeneration[id].done(function() {\n                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                            });\n                            if (relatedThumbnailId != null) {\n                                useCachedPreview(id, relatedThumbnailId);\n                            } else {\n                                generateNewPreview(id, optFileOrBlob, spec);\n                            }\n                        });\n                    }\n                } else {\n                    generateNextQueuedPreview();\n                }\n            } else if (thumbnail) {\n                displayWaitingImg(thumbnail);\n                generateNextQueuedPreview();\n            }\n        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                scale: serverScale,\n                maxSize: thumbnailMaxSize\n            };\n            if (thumbnail) {\n                if (thumbnailUrl) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        if (showWaitingImg) {\n                            displayWaitingImg(thumbnail);\n                        }\n                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n                            show(thumbnail);\n                            generatedThumbnails++;\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        }, function() {\n                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        });\n                    }\n                } else {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                    generateNextQueuedPreview();\n                }\n            }\n        }, setProgressBarWidth = function(id, percent) {\n            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n                bar = qq(bar).getFirstByClass(progressBarSelector);\n            }\n            if (bar) {\n                qq(bar).css({\n                    width: percent + \"%\"\n                });\n                bar.setAttribute(\"aria-valuenow\", percent);\n            }\n        }, show = function(el) {\n            el && qq(el).removeClass(options.classes.hide);\n        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n            previewGeneration[cachedThumbnailId].then(function() {\n                generatedThumbnails++;\n                previewGeneration[targetThumbnailId].success();\n                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n                targetThumbnail.src = cachedThumbnail.src;\n                show(targetThumbnail);\n            }, function() {\n                previewGeneration[targetThumbnailId].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n                }\n            });\n        };\n        qq.extend(options, spec);\n        log = options.log;\n        if (!qq.supportedFeatures.imagePreviews) {\n            options.limits.timeBetweenThumbs = 0;\n            options.limits.maxThumbs = 0;\n        }\n        container = options.containerEl;\n        showThumbnails = options.imageGenerator !== undefined;\n        templateDom = parseAndGetTemplate();\n        cacheThumbnailPlaceholders();\n        qq.extend(this, {\n            render: function() {\n                log(\"Rendering template in DOM.\");\n                generatedThumbnails = 0;\n                container.appendChild(templateDom.template.cloneNode(true));\n                hide(getDropProcessing());\n                this.hideTotalProgress();\n                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n                log(\"Template rendering complete\");\n            },\n            renderFailure: function(message) {\n                var cantRenderEl = qq.toElement(message);\n                container.innerHTML = \"\";\n                container.appendChild(cantRenderEl);\n            },\n            reset: function() {\n                container.innerHTML = \"\";\n                this.render();\n            },\n            clearFiles: function() {\n                fileList.innerHTML = \"\";\n            },\n            disableCancel: function() {\n                isCancelDisabled = true;\n            },\n            addFile: function(id, name, prependInfo, hideForever, batch) {\n                var fileEl = templateDom.fileTemplate.cloneNode(true), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n                if (batch) {\n                    fileBatch.map[id] = fileEl;\n                }\n                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (fileNameEl) {\n                    qq(fileNameEl).setText(name);\n                    fileNameEl.setAttribute(\"title\", name);\n                }\n                fileEl.setAttribute(FILE_ID_ATTR, id);\n                if (prependInfo) {\n                    prependFile(fileEl, prependInfo.index, fileContainer);\n                } else {\n                    fileContainer.appendChild(fileEl);\n                }\n                if (hideForever) {\n                    fileEl.style.display = \"none\";\n                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n                } else {\n                    hide(getProgress(id));\n                    hide(getSize(id));\n                    hide(getDelete(id));\n                    hide(getRetry(id));\n                    hide(getPause(id));\n                    hide(getContinue(id));\n                    if (isCancelDisabled) {\n                        this.hideCancel(id);\n                    }\n                    thumb = getThumbnail(id);\n                    if (thumb && !thumb.src) {\n                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n                            thumb.src = waitingImg.src;\n                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n                                qq(thumb).css({\n                                    maxHeight: waitingImg.style.maxHeight,\n                                    maxWidth: waitingImg.style.maxWidth\n                                });\n                            }\n                            show(thumb);\n                        });\n                    }\n                }\n            },\n            addFileToCache: function(id, name, prependInfo, hideForever) {\n                this.addFile(id, name, prependInfo, hideForever, true);\n            },\n            addCacheToDom: function() {\n                fileList.appendChild(fileBatch.content);\n                fileBatch.content = document.createDocumentFragment();\n                fileBatch.map = {};\n            },\n            removeFile: function(id) {\n                qq(getFile(id)).remove();\n            },\n            getFileId: function(el) {\n                var currentNode = el;\n                if (currentNode) {\n                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n                        currentNode = currentNode.parentNode;\n                    }\n                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n                }\n            },\n            getFileList: function() {\n                return fileList;\n            },\n            markFilenameEditable: function(id) {\n                var filename = getFilename(id);\n                filename && qq(filename).addClass(options.classes.editable);\n            },\n            updateFilename: function(id, name) {\n                var filenameEl = getFilename(id);\n                if (filenameEl) {\n                    qq(filenameEl).setText(name);\n                    filenameEl.setAttribute(\"title\", name);\n                }\n            },\n            hideFilename: function(id) {\n                hide(getFilename(id));\n            },\n            showFilename: function(id) {\n                show(getFilename(id));\n            },\n            isFileName: function(el) {\n                return qq(el).hasClass(selectorClasses.file);\n            },\n            getButton: function() {\n                return options.button || getTemplateEl(container, selectorClasses.button);\n            },\n            hideDropProcessing: function() {\n                hide(getDropProcessing());\n            },\n            showDropProcessing: function() {\n                show(getDropProcessing());\n            },\n            getDropZone: function() {\n                return getTemplateEl(container, selectorClasses.drop);\n            },\n            isEditFilenamePossible: function() {\n                return isEditElementsExist;\n            },\n            hideRetry: function(id) {\n                hide(getRetry(id));\n            },\n            isRetryPossible: function() {\n                return isRetryElementExist;\n            },\n            showRetry: function(id) {\n                show(getRetry(id));\n            },\n            getFileContainer: function(id) {\n                return getFile(id);\n            },\n            showEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).addClass(options.classes.editable);\n            },\n            isHiddenForever: function(id) {\n                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n            },\n            hideEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).removeClass(options.classes.editable);\n            },\n            isEditIcon: function(el) {\n                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n            },\n            getEditInput: function(id) {\n                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n            },\n            isEditInput: function(el) {\n                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n            },\n            updateProgress: function(id, loaded, total) {\n                var bar = getProgress(id), percent;\n                if (bar && total > 0) {\n                    percent = Math.round(loaded / total * 100);\n                    if (percent === 100) {\n                        hide(bar);\n                    } else {\n                        show(bar);\n                    }\n                    setProgressBarWidth(id, percent);\n                }\n            },\n            updateTotalProgress: function(loaded, total) {\n                this.updateProgress(null, loaded, total);\n            },\n            hideProgress: function(id) {\n                var bar = getProgress(id);\n                bar && hide(bar);\n            },\n            hideTotalProgress: function() {\n                this.hideProgress();\n            },\n            resetProgress: function(id) {\n                setProgressBarWidth(id, 0);\n                this.hideTotalProgress(id);\n            },\n            resetTotalProgress: function() {\n                this.resetProgress();\n            },\n            showCancel: function(id) {\n                if (!isCancelDisabled) {\n                    var cancel = getCancel(id);\n                    cancel && qq(cancel).removeClass(options.classes.hide);\n                }\n            },\n            hideCancel: function(id) {\n                hide(getCancel(id));\n            },\n            isCancel: function(el) {\n                return qq(el).hasClass(selectorClasses.cancel, true);\n            },\n            allowPause: function(id) {\n                show(getPause(id));\n                hide(getContinue(id));\n            },\n            uploadPaused: function(id) {\n                this.setStatusText(id, options.text.paused);\n                this.allowContinueButton(id);\n                hide(getSpinner(id));\n            },\n            hidePause: function(id) {\n                hide(getPause(id));\n            },\n            isPause: function(el) {\n                return qq(el).hasClass(selectorClasses.pause, true);\n            },\n            isContinueButton: function(el) {\n                return qq(el).hasClass(selectorClasses.continueButton, true);\n            },\n            allowContinueButton: function(id) {\n                show(getContinue(id));\n                hide(getPause(id));\n            },\n            uploadContinued: function(id) {\n                this.setStatusText(id, \"\");\n                this.allowPause(id);\n                show(getSpinner(id));\n            },\n            showDeleteButton: function(id) {\n                show(getDelete(id));\n            },\n            hideDeleteButton: function(id) {\n                hide(getDelete(id));\n            },\n            isDeleteButton: function(el) {\n                return qq(el).hasClass(selectorClasses.deleteButton, true);\n            },\n            isRetry: function(el) {\n                return qq(el).hasClass(selectorClasses.retry, true);\n            },\n            updateSize: function(id, text) {\n                var size = getSize(id);\n                if (size) {\n                    show(size);\n                    qq(size).setText(text);\n                }\n            },\n            setStatusText: function(id, text) {\n                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n                if (textEl) {\n                    if (text == null) {\n                        qq(textEl).clearText();\n                    } else {\n                        qq(textEl).setText(text);\n                    }\n                }\n            },\n            hideSpinner: function(id) {\n                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n                hide(getSpinner(id));\n            },\n            showSpinner: function(id) {\n                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n                show(getSpinner(id));\n            },\n            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        id: id,\n                        customResizeFunction: customResizeFunction,\n                        optFileOrBlob: optFileOrBlob\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        customResizeFunction: customResizeFunction,\n                        update: true,\n                        id: id,\n                        thumbnailUrl: thumbnailUrl,\n                        showWaitingImg: showWaitingImg\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            hasDialog: function(type) {\n                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n            },\n            showDialog: function(type, message, defaultValue) {\n                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n                    promise.failure();\n                }, cancelClickHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    dialog.close();\n                }, okClickHandler = function() {\n                    dialog.removeEventListener(\"close\", closeHandler);\n                    okBtn.removeEventListener(\"click\", okClickHandler);\n                    dialog.close();\n                    promise.success(inputEl && inputEl.value);\n                };\n                dialog.addEventListener(\"close\", closeHandler);\n                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n                if (inputEl) {\n                    inputEl.value = defaultValue;\n                }\n                messageEl.textContent = message;\n                dialog.showModal();\n                return promise;\n            }\n        });\n    };\n    qq.UiEventHandler = function(s, protectedApi) {\n        \"use strict\";\n        var disposer = new qq.DisposeSupport(), spec = {\n            eventType: \"click\",\n            attachTo: null,\n            onHandled: function(target, event) {}\n        };\n        qq.extend(this, {\n            addHandler: function(element) {\n                addHandler(element);\n            },\n            dispose: function() {\n                disposer.dispose();\n            }\n        });\n        function addHandler(element) {\n            disposer.attach(element, spec.eventType, function(event) {\n                event = event || window.event;\n                var target = event.target || event.srcElement;\n                spec.onHandled(target, event);\n            });\n        }\n        qq.extend(protectedApi, {\n            getFileIdFromItem: function(item) {\n                return item.qqFileId;\n            },\n            getDisposeSupport: function() {\n                return disposer;\n            }\n        });\n        qq.extend(spec, s);\n        if (spec.attachTo) {\n            addHandler(spec.attachTo);\n        }\n    };\n    qq.FileButtonsClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onDeleteFile: function(fileId) {},\n            onCancel: function(fileId) {},\n            onRetry: function(fileId) {},\n            onPause: function(fileId) {},\n            onContinue: function(fileId) {},\n            onGetName: function(fileId) {}\n        }, buttonHandlers = {\n            cancel: function(id) {\n                spec.onCancel(id);\n            },\n            retry: function(id) {\n                spec.onRetry(id);\n            },\n            deleteButton: function(id) {\n                spec.onDeleteFile(id);\n            },\n            pause: function(id) {\n                spec.onPause(id);\n            },\n            continueButton: function(id) {\n                spec.onContinue(id);\n            }\n        };\n        function examineEvent(target, event) {\n            qq.each(buttonHandlers, function(buttonType, handler) {\n                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n                    fileId = spec.templating.getFileId(target);\n                    qq.preventDefault(event);\n                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    handler(fileId);\n                    return false;\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            classes: {\n                file: \"qq-upload-file\",\n                editNameIcon: \"qq-edit-filename-icon\"\n            },\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {}\n        };\n        qq.extend(spec, s);\n        function examineEvent(target, event) {\n            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    qq.preventDefault(event);\n                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n                }\n            }\n        }\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            onGetUploadStatus: function(fileId) {},\n            log: function(message, lvl) {}\n        };\n        if (!inheritedInternalApi) {\n            inheritedInternalApi = {};\n        }\n        function handleInputFocus(target, event) {\n            if (spec.templating.isEditInput(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n                }\n            }\n        }\n        spec.eventType = \"focusin\";\n        spec.onHandled = handleInputFocus;\n        qq.extend(spec, s);\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusHandler = function(spec) {\n        \"use strict\";\n        spec.eventType = \"focus\";\n        spec.attachTo = null;\n        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n    };\n    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {},\n            onSetName: function(fileId, newName) {},\n            onEditingStatusChange: function(fileId, isEditing) {}\n        };\n        function getFilenameSansExtension(fileId) {\n            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n            if (extIdx > 0) {\n                filenameSansExt = filenameSansExt.substr(0, extIdx);\n            }\n            return filenameSansExt;\n        }\n        function getOriginalExtension(fileId) {\n            var origName = spec.onGetName(fileId);\n            return qq.getExtension(origName);\n        }\n        function handleNameUpdate(newFilenameInputEl, fileId) {\n            var newName = newFilenameInputEl.value, origExtension;\n            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n                origExtension = getOriginalExtension(fileId);\n                if (origExtension !== undefined) {\n                    newName = newName + \".\" + origExtension;\n                }\n                spec.onSetName(fileId, newName);\n            }\n            spec.onEditingStatusChange(fileId, false);\n        }\n        function registerInputBlurHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n                handleNameUpdate(inputEl, fileId);\n            });\n        }\n        function registerInputEnterKeyHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n                var code = event.keyCode || event.which;\n                if (code === 13) {\n                    handleNameUpdate(inputEl, fileId);\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n        qq.extend(inheritedInternalApi, {\n            handleFilenameEdit: function(id, target, focusInput) {\n                var newFilenameInputEl = spec.templating.getEditInput(id);\n                spec.onEditingStatusChange(id, true);\n                newFilenameInputEl.value = getFilenameSansExtension(id);\n                if (focusInput) {\n                    newFilenameInputEl.focus();\n                }\n                registerInputBlurHandler(newFilenameInputEl, id);\n                registerInputEnterKeyHandler(newFilenameInputEl, id);\n            }\n        });\n    };\n})(window);\n//# sourceMappingURL=fine-uploader.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fine-uploader/fine-uploader/fine-uploader.js\n// module id = 5\n// module chunks = 0","/*!\n\nHolder - client side image placeholders\nVersion 2.9.4+cabil\n© 2016 Ivan Malopinsky - http://imsky.co\n\nSite:     http://holderjs.com\nIssues:   https://github.com/imsky/holder/issues\nLicense:  MIT\n\n*/\n(function (window) {\n  if (!window.document) return;\n  var document = window.document;\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n    if (!document.querySelectorAll) {\n      document.querySelectorAll = function (selectors) {\n        var style = document.createElement('style'), elements = [], element;\n        document.documentElement.firstChild.appendChild(style);\n        document._qsa = [];\n\n        style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';\n        window.scrollBy(0, 0);\n        style.parentNode.removeChild(style);\n\n        while (document._qsa.length) {\n          element = document._qsa.shift();\n          element.style.removeAttribute('x-qsa');\n          elements.push(element);\n        }\n        document._qsa = null;\n        return elements;\n      };\n    }\n\n    if (!document.querySelector) {\n      document.querySelector = function (selectors) {\n        var elements = document.querySelectorAll(selectors);\n        return (elements.length) ? elements[0] : null;\n      };\n    }\n\n    if (!document.getElementsByClassName) {\n      document.getElementsByClassName = function (classNames) {\n        classNames = String(classNames).replace(/^|\\s+/g, '.');\n        return document.querySelectorAll(classNames);\n      };\n    }\n\n  //https://github.com/inexorabletash/polyfill\n  // ES5 15.2.3.14 Object.keys ( O )\n  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }\n      var ret = [], p;\n      for (p in o) {\n        if (Object.prototype.hasOwnProperty.call(o, p)) {\n          ret.push(p);\n        }\n      }\n      return ret;\n    };\n  }\n\n  // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function (fun /*, thisp */) {\n      if (this === void 0 || this === null) { throw TypeError(); }\n\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (typeof fun !== \"function\") { throw TypeError(); }\n\n      var thisp = arguments[1], i;\n      for (i = 0; i < len; i++) {\n        if (i in t) {\n          fun.call(thisp, t[i], i, t);\n        }\n      }\n    };\n  }\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n  (function (global) {\n    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    global.atob = global.atob || function (input) {\n      input = String(input);\n      var position = 0,\n          output = [],\n          buffer = 0, bits = 0, n;\n\n      input = input.replace(/\\s/g, '');\n      if ((input.length % 4) === 0) { input = input.replace(/=+$/, ''); }\n      if ((input.length % 4) === 1) { throw Error('InvalidCharacterError'); }\n      if (/[^+/0-9A-Za-z]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        n = B64_ALPHABET.indexOf(input.charAt(position));\n        buffer = (buffer << 6) | n;\n        bits += 6;\n\n        if (bits === 24) {\n          output.push(String.fromCharCode((buffer >> 16) & 0xFF));\n          output.push(String.fromCharCode((buffer >>  8) & 0xFF));\n          output.push(String.fromCharCode(buffer & 0xFF));\n          bits = 0;\n          buffer = 0;\n        }\n        position += 1;\n      }\n\n      if (bits === 12) {\n        buffer = buffer >> 4;\n        output.push(String.fromCharCode(buffer & 0xFF));\n      } else if (bits === 18) {\n        buffer = buffer >> 2;\n        output.push(String.fromCharCode((buffer >> 8) & 0xFF));\n        output.push(String.fromCharCode(buffer & 0xFF));\n      }\n\n      return output.join('');\n    };\n\n    global.btoa = global.btoa || function (input) {\n      input = String(input);\n      var position = 0,\n          out = [],\n          o1, o2, o3,\n          e1, e2, e3, e4;\n\n      if (/[^\\x00-\\xFF]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        o1 = input.charCodeAt(position++);\n        o2 = input.charCodeAt(position++);\n        o3 = input.charCodeAt(position++);\n\n        // 111111 112222 222233 333333\n        e1 = o1 >> 2;\n        e2 = ((o1 & 0x3) << 4) | (o2 >> 4);\n        e3 = ((o2 & 0xf) << 2) | (o3 >> 6);\n        e4 = o3 & 0x3f;\n\n        if (position === input.length + 2) {\n          e3 = 64; e4 = 64;\n        }\n        else if (position === input.length + 1) {\n          e4 = 64;\n        }\n\n        out.push(B64_ALPHABET.charAt(e1),\n                 B64_ALPHABET.charAt(e2),\n                 B64_ALPHABET.charAt(e3),\n                 B64_ALPHABET.charAt(e4));\n      }\n\n      return out.join('');\n    };\n  }(window));\n\n  //https://gist.github.com/jimeh/332357\n  if (!Object.prototype.hasOwnProperty){\n      /*jshint -W001, -W103 */\n      Object.prototype.hasOwnProperty = function(prop) {\n      var proto = this.__proto__ || this.constructor.prototype;\n      return (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);\n    };\n      /*jshint +W001, +W103 */\n  }\n\n  // @license http://opensource.org/licenses/MIT\n  // copyright Paul Irish 2015\n\n\n  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n\n  (function(){\n\n    if ('performance' in window === false) {\n        window.performance = {};\n    }\n    \n    Date.now = (Date.now || function () {  // thanks IE8\n      return new Date().getTime();\n    });\n\n    if ('now' in window.performance === false){\n      \n      var nowOffset = Date.now();\n      \n      if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n      }\n\n      window.performance.now = function now(){\n        return Date.now() - nowOffset;\n      };\n    }\n\n  })();\n\n  //requestAnimationFrame polyfill for older Firefox/Chrome versions\n  if (!window.requestAnimationFrame) {\n    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {\n    //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return webkitRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.webkitCancelAnimationFrame;\n    }(window));\n    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {\n      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return mozRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.mozCancelAnimationFrame;\n    }(window));\n    } else {\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return global.setTimeout(callback, 1000 / 60);\n      };\n\n      global.cancelAnimationFrame = global.clearTimeout;\n    })(window);\n    }\n  }\n})(this);\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Holder\"] = factory();\n\telse\n\t\troot[\"Holder\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2015 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2016 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\t//Libraries and functions\n\tvar onDomReady = __webpack_require__(2);\n\tvar querystring = __webpack_require__(3);\n\n\tvar SceneGraph = __webpack_require__(6);\n\tvar utils = __webpack_require__(7);\n\tvar SVG = __webpack_require__(8);\n\tvar DOM = __webpack_require__(9);\n\tvar Color = __webpack_require__(10);\n\tvar constants = __webpack_require__(11);\n\n\tvar svgRenderer = __webpack_require__(12);\n\tvar sgCanvasRenderer = __webpack_require__(15);\n\n\tvar extend = utils.extend;\n\tvar dimensionCheck = utils.dimensionCheck;\n\n\t//Constants and definitions\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar Holder = {\n\t    version: constants.version,\n\n\t    /**\n\t     * Adds a theme to default settings\n\t     *\n\t     * @param {string} name Theme name\n\t     * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.\n\t     */\n\t    addTheme: function(name, theme) {\n\t        name != null && theme != null && (App.settings.themes[name] = theme);\n\t        delete App.vars.cache.themeKeys;\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Appends a placeholder to an element\n\t     *\n\t     * @param {string} src Placeholder URL string\n\t     * @param el A selector or a reference to a DOM node\n\t     */\n\t    addImage: function(src, el) {\n\t        //todo: use jquery fallback if available for all QSA references\n\t        var nodes = DOM.getNodeArray(el);\n\t        nodes.forEach(function (node) {\n\t            var img = DOM.newEl('img');\n\t            var domProps = {};\n\t            domProps[App.setup.dataAttr] = src;\n\t            DOM.setAttr(img, domProps);\n\t            node.appendChild(img);\n\t        });\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Sets whether or not an image is updated on resize.\n\t     * If an image is set to be updated, it is immediately rendered.\n\t     *\n\t     * @param {Object} el Image DOM element\n\t     * @param {Boolean} value Resizable update flag value\n\t     */\n\t    setResizeUpdate: function(el, value) {\n\t        if (el.holderData) {\n\t            el.holderData.resizeUpdate = !!value;\n\t            if (el.holderData.resizeUpdate) {\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Runs Holder with options. By default runs Holder on all images with \"holder.js\" in their source attributes.\n\t     *\n\t     * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties\n\t     */\n\t    run: function(userOptions) {\n\t        //todo: split processing into separate queues\n\t        userOptions = userOptions || {};\n\t        var engineSettings = {};\n\t        var options = extend(App.settings, userOptions);\n\n\t        App.vars.preempted = true;\n\t        App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;\n\n\t        engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;\n\t        if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {\n\t            engineSettings.renderer = App.setup.supportsSVG ? 'svg' : (App.setup.supportsCanvas ? 'canvas' : 'html');\n\t        }\n\n\t        var images = DOM.getNodeArray(options.images);\n\t        var bgnodes = DOM.getNodeArray(options.bgnodes);\n\t        var stylenodes = DOM.getNodeArray(options.stylenodes);\n\t        var objects = DOM.getNodeArray(options.objects);\n\n\t        engineSettings.stylesheets = [];\n\t        engineSettings.svgXMLStylesheet = true;\n\t        engineSettings.noFontFallback = !!options.noFontFallback;\n\t        engineSettings.noBackgroundSize = !!options.noBackgroundSize;\n\n\t        stylenodes.forEach(function (styleNode) {\n\t            if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {\n\t                var href = styleNode.attributes.href.value;\n\t                //todo: write isomorphic relative-to-absolute URL function\n\t                var proxyLink = DOM.newEl('a');\n\t                proxyLink.href = href;\n\t                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;\n\t                engineSettings.stylesheets.push(stylesheetURL);\n\t            }\n\t        });\n\n\t        bgnodes.forEach(function (bgNode) {\n\t            //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background\n\t            if (!global.getComputedStyle) return;\n\t            var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');\n\t            var dataBackgroundImage = bgNode.getAttribute('data-background-src');\n\t            var rawURL = dataBackgroundImage || backgroundImage;\n\n\t            var holderURL = null;\n\t            var holderString = options.domain + '/';\n\t            var holderStringIndex = rawURL.indexOf(holderString);\n\n\t            if (holderStringIndex === 0) {\n\t                holderURL = rawURL;\n\t            } else if (holderStringIndex === 1 && rawURL[0] === '?') {\n\t                holderURL = rawURL.slice(1);\n\t            } else {\n\t                var fragment = rawURL.substr(holderStringIndex).match(/([^\\\"]*)\"?\\)/);\n\t                if (fragment !== null) {\n\t                    holderURL = fragment[1];\n\t                } else if (rawURL.indexOf('url(') === 0) {\n\t                    throw 'Holder: unable to parse background URL: ' + rawURL;\n\t                }\n\t            }\n\n\t            if (holderURL) {\n\t                var holderFlags = parseURL(holderURL, options);\n\t                if (holderFlags) {\n\t                    prepareDOMElement({\n\t                        mode: 'background',\n\t                        el: bgNode,\n\t                        flags: holderFlags,\n\t                        engineSettings: engineSettings\n\t                    });\n\t                }\n\t            }\n\t        });\n\n\t        objects.forEach(function (object) {\n\t            var objectAttr = {};\n\n\t            try {\n\t                objectAttr.data = object.getAttribute('data');\n\t                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);\n\t            } catch (e) {}\n\n\t            var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;\n\t            var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;\n\n\t            if (objectHasSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.data, object);\n\t            } else if (objectHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);\n\t            }\n\t        });\n\n\t        images.forEach(function (image) {\n\t            var imageAttr = {};\n\n\t            try {\n\t                imageAttr.src = image.getAttribute('src');\n\t                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);\n\t                imageAttr.rendered = image.getAttribute('data-holder-rendered');\n\t            } catch (e) {}\n\n\t            var imageHasSrc = imageAttr.src != null;\n\t            var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;\n\t            var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';\n\n\t            if (imageHasSrc) {\n\t                if (imageAttr.src.indexOf(options.domain) === 0) {\n\t                    prepareImageElement(options, engineSettings, imageAttr.src, image);\n\t                } else if (imageHasDataSrcURL) {\n\t                    //Image has a valid data-src and an invalid src\n\t                    if (imageRendered) {\n\t                        //If the placeholder has already been render, re-render it\n\t                        prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t                    } else {\n\t                        //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't\n\t                        (function(src, options, engineSettings, dataSrc, image) {\n\t                            utils.imageExists(src, function(exists) {\n\t                                if (!exists) {\n\t                                    prepareImageElement(options, engineSettings, dataSrc, image);\n\t                                }\n\t                            });\n\t                        })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);\n\t                    }\n\t                }\n\t            } else if (imageHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t            }\n\t        });\n\n\t        return this;\n\t    }\n\t};\n\n\tvar App = {\n\t    settings: {\n\t        domain: 'holder.js',\n\t        images: 'img',\n\t        objects: 'object',\n\t        bgnodes: 'body .holderjs',\n\t        stylenodes: 'head link.holderjs',\n\t        themes: {\n\t            'gray': {\n\t                bg: '#EEEEEE',\n\t                fg: '#AAAAAA'\n\t            },\n\t            'social': {\n\t                bg: '#3a5a97',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'industrial': {\n\t                bg: '#434A52',\n\t                fg: '#C2F200'\n\t            },\n\t            'sky': {\n\t                bg: '#0D8FDB',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'vine': {\n\t                bg: '#39DBAC',\n\t                fg: '#1E292C'\n\t            },\n\t            'lava': {\n\t                bg: '#F8591A',\n\t                fg: '#1C2846'\n\t            }\n\t        }\n\t    },\n\t    defaults: {\n\t        size: 10,\n\t        units: 'pt',\n\t        scale: 1 / 16\n\t    }\n\t};\n\n\t/**\n\t * Processes provided source attribute and sets up the appropriate rendering workflow\n\t *\n\t * @private\n\t * @param options Instance options from Holder.run\n\t * @param renderSettings Instance configuration\n\t * @param src Image URL\n\t * @param el Image DOM element\n\t */\n\tfunction prepareImageElement(options, engineSettings, src, el) {\n\t    var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);\n\t    if (holderFlags) {\n\t        prepareDOMElement({\n\t            mode: null,\n\t            el: el,\n\t            flags: holderFlags,\n\t            engineSettings: engineSettings\n\t        });\n\t    }\n\t}\n\n\t/**\n\t * Processes a Holder URL and extracts configuration from query string\n\t *\n\t * @private\n\t * @param url URL\n\t * @param instanceOptions Instance options from Holder.run\n\t */\n\tfunction parseURL(url, instanceOptions) {\n\t    var holder = {\n\t        theme: extend(App.settings.themes.gray, null),\n\t        stylesheets: instanceOptions.stylesheets,\n\t        instanceOptions: instanceOptions\n\t    };\n\n\t    var firstQuestionMark = url.indexOf('?');\n\t    var parts = [url];\n\n\t    if (firstQuestionMark !== -1) {\n\t        parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];\n\t    }\n\n\t    var basics = parts[0].split('/');\n\n\t    holder.holderURL = url;\n\n\t    var dimensions = basics[1];\n\t    var dimensionData = dimensions.match(/([\\d]+p?)x([\\d]+p?)/);\n\n\t    if (!dimensionData) return false;\n\n\t    holder.fluid = dimensions.indexOf('p') !== -1;\n\n\t    holder.dimensions = {\n\t        width: dimensionData[1].replace('p', '%'),\n\t        height: dimensionData[2].replace('p', '%')\n\t    };\n\n\t    if (parts.length === 2) {\n\t        var options = querystring.parse(parts[1]);\n\n\t        // Dimensions\n\n\t        if (utils.truthy(options.ratio)) {\n\t            holder.fluid = true;\n\t            var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));\n\t            var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));\n\n\t            ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));\n\t            ratioWidth = 100;\n\n\t            holder.dimensions.width = ratioWidth + '%';\n\t            holder.dimensions.height = ratioHeight + '%';\n\t        }\n\n\t        holder.auto = utils.truthy(options.auto);\n\n\t        // Colors\n\n\t        if (options.bg) {\n\t            holder.theme.bg = utils.parseColor(options.bg);\n\t        }\n\n\t        if (options.fg) {\n\t            holder.theme.fg = utils.parseColor(options.fg);\n\t        }\n\n\t        //todo: add automatic foreground to themes without foreground\n\t        if (options.bg && !options.fg) {\n\t            holder.autoFg = true;\n\t        }\n\n\t        if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {\n\t            holder.theme = extend(holder.instanceOptions.themes[options.theme], null);\n\t        }\n\n\t        // Text\n\n\t        if (options.text) {\n\t            holder.text = options.text;\n\t        }\n\n\t        if (options.textmode) {\n\t            holder.textmode = options.textmode;\n\t        }\n\n\t        if (options.size) {\n\t            holder.size = options.size;\n\t        }\n\n\t        if (options.font) {\n\t            holder.font = options.font;\n\t        }\n\n\t        if (options.align) {\n\t            holder.align = options.align;\n\t        }\n\n\t        if (options.lineWrap) {\n\t            holder.lineWrap = options.lineWrap;\n\t        }\n\n\t        holder.nowrap = utils.truthy(options.nowrap);\n\n\t        // Miscellaneous\n\n\t        holder.outline = utils.truthy(options.outline);\n\n\t        if (utils.truthy(options.random)) {\n\t            App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);\n\t            var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];\n\t            holder.theme = extend(holder.instanceOptions.themes[_theme], null);\n\t        }\n\t    }\n\n\t    return holder;\n\t}\n\n\t/**\n\t * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)\n\t *\n\t * @private\n\t * @param settings DOM prep settings\n\t */\n\tfunction prepareDOMElement(prepSettings) {\n\t    var mode = prepSettings.mode;\n\t    var el = prepSettings.el;\n\t    var flags = prepSettings.flags;\n\t    var _engineSettings = prepSettings.engineSettings;\n\t    var dimensions = flags.dimensions,\n\t        theme = flags.theme;\n\t    var dimensionsCaption = dimensions.width + 'x' + dimensions.height;\n\t    mode = mode == null ? (flags.fluid ? 'fluid' : 'image') : mode;\n\t    var holderTemplateRe = /holder_([a-z]+)/g;\n\t    var dimensionsInText = false;\n\n\t    if (flags.text != null) {\n\t        theme.text = flags.text;\n\n\t        //<object> SVG embedding doesn't parse Unicode properly\n\t        if (el.nodeName.toLowerCase() === 'object') {\n\t            var textLines = theme.text.split('\\\\n');\n\t            for (var k = 0; k < textLines.length; k++) {\n\t                textLines[k] = utils.encodeHtmlEntity(textLines[k]);\n\t            }\n\t            theme.text = textLines.join('\\\\n');\n\t        }\n\t    }\n\n\t    if (theme.text) {\n\t        var holderTemplateMatches = theme.text.match(holderTemplateRe);\n\n\t        if (holderTemplateMatches !== null) {\n\t            //todo: optimize template replacement\n\t            holderTemplateMatches.forEach(function (match) {\n\t                if (match === 'holder_dimensions') {\n\t                    theme.text = theme.text.replace(match, dimensionsCaption);\n\t                }\n\t            });\n\t        }\n\t    }\n\n\t    var holderURL = flags.holderURL;\n\t    var engineSettings = extend(_engineSettings, null);\n\n\t    if (flags.font) {\n\t        /*\n\t        If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.\n\n\t        This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.\n\t        The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.\n\t        */\n\t        theme.font = flags.font;\n\t        if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {\n\t            engineSettings = extend(engineSettings, {\n\t                renderer: 'canvas'\n\t            });\n\t        }\n\t    }\n\n\t    //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas\n\t    if (flags.font && engineSettings.renderer == 'canvas') {\n\t        engineSettings.reRender = true;\n\t    }\n\n\t    if (mode == 'background') {\n\t        if (el.getAttribute('data-background-src') == null) {\n\t            DOM.setAttr(el, {\n\t                'data-background-src': holderURL\n\t            });\n\t        }\n\t    } else {\n\t        var domProps = {};\n\t        domProps[App.vars.dataAttr] = holderURL;\n\t        DOM.setAttr(el, domProps);\n\t    }\n\n\t    flags.theme = theme;\n\n\t    //todo consider using all renderSettings in holderData\n\t    el.holderData = {\n\t        flags: flags,\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image' || mode == 'fluid') {\n\t        DOM.setAttr(el, {\n\t            'alt': theme.text ? (dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']') : dimensionsCaption\n\t        });\n\t    }\n\n\t    var renderSettings = {\n\t        mode: mode,\n\t        el: el,\n\t        holderSettings: {\n\t            dimensions: dimensions,\n\t            theme: theme,\n\t            flags: flags\n\t        },\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image') {\n\t        if (!flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            render(renderSettings);\n\n\t            if (flags.textmode == 'exact') {\n\t                el.holderData.resizeUpdate = true;\n\t                App.vars.resizableImages.push(el);\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    } else if (mode == 'background' && engineSettings.renderer != 'html') {\n\t        render(renderSettings);\n\t    } else if (mode == 'fluid') {\n\t        el.holderData.resizeUpdate = true;\n\n\t        if (dimensions.height.slice(-1) == '%') {\n\t            el.style.height = dimensions.height;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\t        if (dimensions.width.slice(-1) == '%') {\n\t            el.style.width = dimensions.width;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t        }\n\t        if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {\n\t            el.style.display = 'block';\n\t        }\n\n\t        setInitialDimensions(el);\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            App.vars.resizableImages.push(el);\n\t            updateResizableElements(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Core function that takes output from renderers and sets it as the source or background-image of the target element\n\t *\n\t * @private\n\t * @param renderSettings Renderer settings\n\t */\n\tfunction render(renderSettings) {\n\t    var image = null;\n\t    var mode = renderSettings.mode;\n\t    var el = renderSettings.el;\n\t    var holderSettings = renderSettings.holderSettings;\n\t    var engineSettings = renderSettings.engineSettings;\n\n\t    switch (engineSettings.renderer) {\n\t        case 'svg':\n\t            if (!App.setup.supportsSVG) return;\n\t            break;\n\t        case 'canvas':\n\t            if (!App.setup.supportsCanvas) return;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\n\t    //todo: move generation of scene up to flag generation to reduce extra object creation\n\t    var scene = {\n\t        width: holderSettings.dimensions.width,\n\t        height: holderSettings.dimensions.height,\n\t        theme: holderSettings.theme,\n\t        flags: holderSettings.flags\n\t    };\n\n\t    var sceneGraph = buildSceneGraph(scene);\n\n\t    function getRenderedImage() {\n\t        var image = null;\n\t        switch (engineSettings.renderer) {\n\t            case 'canvas':\n\t                image = sgCanvasRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            case 'svg':\n\t                image = svgRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            default:\n\t                throw 'Holder: invalid renderer: ' + engineSettings.renderer;\n\t        }\n\n\t        return image;\n\t    }\n\n\t    image = getRenderedImage();\n\n\t    if (image == null) {\n\t        throw 'Holder: couldn\\'t render placeholder';\n\t    }\n\n\t    //todo: add <object> canvas rendering\n\t    if (mode == 'background') {\n\t        el.style.backgroundImage = 'url(' + image + ')';\n\n\t        if (!engineSettings.noBackgroundSize) {\n\t            el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';\n\t        }\n\t    } else {\n\t        if (el.nodeName.toLowerCase() === 'img') {\n\t            DOM.setAttr(el, {\n\t                'src': image\n\t            });\n\t        } else if (el.nodeName.toLowerCase() === 'object') {\n\t            DOM.setAttr(el, {\n\t                'data': image,\n\t                'type': 'image/svg+xml'\n\t            });\n\t        }\n\t        if (engineSettings.reRender) {\n\t            global.setTimeout(function () {\n\t                var image = getRenderedImage();\n\t                if (image == null) {\n\t                    throw 'Holder: couldn\\'t render placeholder';\n\t                }\n\t                //todo: refactor this code into a function\n\t                if (el.nodeName.toLowerCase() === 'img') {\n\t                    DOM.setAttr(el, {\n\t                        'src': image\n\t                    });\n\t                } else if (el.nodeName.toLowerCase() === 'object') {\n\t                    DOM.setAttr(el, {\n\t                        'data': image,\n\t                        'type': 'image/svg+xml'\n\t                    });\n\t                }\n\t            }, 150);\n\t        }\n\t    }\n\t    //todo: account for re-rendering\n\t    DOM.setAttr(el, {\n\t        'data-holder-rendered': true\n\t    });\n\t}\n\n\t/**\n\t * Core function that takes a Holder scene description and builds a scene graph\n\t *\n\t * @private\n\t * @param scene Holder scene object\n\t */\n\t//todo: make this function reusable\n\t//todo: merge app defaults and setup properties into the scene argument\n\tfunction buildSceneGraph(scene) {\n\t    var fontSize = App.defaults.size;\n\t    if (parseFloat(scene.theme.size)) {\n\t        fontSize = scene.theme.size;\n\t    } else if (parseFloat(scene.flags.size)) {\n\t        fontSize = scene.flags.size;\n\t    }\n\n\t    scene.font = {\n\t        family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',\n\t        size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),\n\t        units: scene.theme.units ? scene.theme.units : App.defaults.units,\n\t        weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'\n\t    };\n\n\t    scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);\n\n\t    scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;\n\n\t    scene.align = scene.theme.align || scene.flags.align || 'center';\n\n\t    switch (scene.flags.textmode) {\n\t        case 'literal':\n\t            scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;\n\t            break;\n\t        case 'exact':\n\t            if (!scene.flags.exactDimensions) break;\n\t            scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);\n\t            break;\n\t    }\n\n\t    var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;\n\t    var sceneMargin = scene.width * lineWrap;\n\t    var maxLineWidth = sceneMargin;\n\n\t    var sceneGraph = new SceneGraph({\n\t        width: scene.width,\n\t        height: scene.height\n\t    });\n\n\t    var Shape = sceneGraph.Shape;\n\n\t    var holderBg = new Shape.Rect('holderBg', {\n\t        fill: scene.theme.bg\n\t    });\n\n\t    holderBg.resize(scene.width, scene.height);\n\t    sceneGraph.root.add(holderBg);\n\n\t    if (scene.flags.outline) {\n\t        var outlineColor = new Color(holderBg.properties.fill);\n\t        outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);\n\t        holderBg.properties.outline = {\n\t            fill: outlineColor.toHex(true),\n\t            width: 2\n\t        };\n\t    }\n\n\t    var holderTextColor = scene.theme.fg;\n\n\t    if (scene.flags.autoFg) {\n\t        var holderBgColor = new Color(holderBg.properties.fill);\n\t        var lightColor = new Color('fff');\n\t        var darkColor = new Color('000', {\n\t            'alpha': 0.285714\n\t        });\n\n\t        holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);\n\t    }\n\n\t    var holderTextGroup = new Shape.Group('holderTextGroup', {\n\t        text: scene.text,\n\t        align: scene.align,\n\t        font: scene.font,\n\t        fill: holderTextColor\n\t    });\n\n\t    holderTextGroup.moveTo(null, null, 1);\n\t    sceneGraph.root.add(holderTextGroup);\n\n\t    var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);\n\t    if (!tpdata) {\n\t        throw 'Holder: staging fallback not supported yet.';\n\t    }\n\t    holderTextGroup.properties.leading = tpdata.boundingBox.height;\n\n\t    var textNode = null;\n\t    var line = null;\n\n\t    function finalizeLine(parent, line, width, height) {\n\t        line.width = width;\n\t        line.height = height;\n\t        parent.width = Math.max(parent.width, line.width);\n\t        parent.height += line.height;\n\t    }\n\n\t    if (tpdata.lineCount > 1) {\n\t        var offsetX = 0;\n\t        var offsetY = 0;\n\t        var lineIndex = 0;\n\t        var lineKey;\n\t        line = new Shape.Group('line' + lineIndex);\n\n\t        //Double margin so that left/right-aligned next is not flush with edge of image\n\t        if (scene.align === 'left' || scene.align === 'right') {\n\t            maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);\n\t        }\n\n\t        for (var i = 0; i < tpdata.words.length; i++) {\n\t            var word = tpdata.words[i];\n\t            textNode = new Shape.Text(word.text);\n\t            var newline = word.text == '\\\\n';\n\t            if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {\n\t                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t                holderTextGroup.add(line);\n\t                offsetX = 0;\n\t                offsetY += holderTextGroup.properties.leading;\n\t                lineIndex += 1;\n\t                line = new Shape.Group('line' + lineIndex);\n\t                line.y = offsetY;\n\t            }\n\t            if (newline === true) {\n\t                continue;\n\t            }\n\t            textNode.moveTo(offsetX, 0);\n\t            offsetX += tpdata.spaceWidth + word.width;\n\t            line.add(textNode);\n\t        }\n\n\t        finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo(scene.width - line.width, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);\n\n\t        //If the text exceeds vertical space, move it down so the first line is visible\n\t        if ((scene.height - holderTextGroup.height) / 2 < 0) {\n\t            holderTextGroup.moveTo(null, 0, null);\n\t        }\n\t    } else {\n\t        textNode = new Shape.Text(scene.text);\n\t        line = new Shape.Group('line0');\n\t        line.add(textNode);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);\n\t    }\n\n\t    //todo: renderlist\n\t    return sceneGraph;\n\t}\n\n\t/**\n\t * Adaptive text sizing function\n\t *\n\t * @private\n\t * @param width Parent width\n\t * @param height Parent height\n\t * @param fontSize Requested text size\n\t * @param scale Proportional scale of text\n\t */\n\tfunction textSize(width, height, fontSize, scale) {\n\t    var stageWidth = parseInt(width, 10);\n\t    var stageHeight = parseInt(height, 10);\n\n\t    var bigSide = Math.max(stageWidth, stageHeight);\n\t    var smallSide = Math.min(stageWidth, stageHeight);\n\n\t    var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);\n\t    return Math.round(Math.max(fontSize, newHeight));\n\t}\n\n\t/**\n\t * Iterates over resizable (fluid or auto) placeholders and renders them\n\t *\n\t * @private\n\t * @param element Optional element selector, specified only if a specific element needs to be re-rendered\n\t */\n\tfunction updateResizableElements(element) {\n\t    var images;\n\t    if (element == null || element.nodeType == null) {\n\t        images = App.vars.resizableImages;\n\t    } else {\n\t        images = [element];\n\t    }\n\t    for (var i = 0, l = images.length; i < l; i++) {\n\t        var el = images[i];\n\t        if (el.holderData) {\n\t            var flags = el.holderData.flags;\n\t            var dimensions = dimensionCheck(el);\n\t            if (dimensions) {\n\t                if (!el.holderData.resizeUpdate) {\n\t                    continue;\n\t                }\n\n\t                if (flags.fluid && flags.auto) {\n\t                    var fluidConfig = el.holderData.fluidConfig;\n\t                    switch (fluidConfig.mode) {\n\t                        case 'width':\n\t                            dimensions.height = dimensions.width / fluidConfig.ratio;\n\t                            break;\n\t                        case 'height':\n\t                            dimensions.width = dimensions.height * fluidConfig.ratio;\n\t                            break;\n\t                    }\n\t                }\n\n\t                var settings = {\n\t                    mode: 'image',\n\t                    holderSettings: {\n\t                        dimensions: dimensions,\n\t                        theme: flags.theme,\n\t                        flags: flags\n\t                    },\n\t                    el: el,\n\t                    engineSettings: el.holderData.engineSettings\n\t                };\n\n\t                if (flags.textmode == 'exact') {\n\t                    flags.exactDimensions = dimensions;\n\t                    settings.holderSettings.dimensions = flags.dimensions;\n\t                }\n\n\t                render(settings);\n\t            } else {\n\t                setInvisible(el);\n\t            }\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing\n\t *\n\t * @private\n\t * @param el Image DOM element\n\t */\n\tfunction setInitialDimensions(el) {\n\t    if (el.holderData) {\n\t        var dimensions = dimensionCheck(el);\n\t        if (dimensions) {\n\t            var flags = el.holderData.flags;\n\n\t            var fluidConfig = {\n\t                fluidHeight: flags.dimensions.height.slice(-1) == '%',\n\t                fluidWidth: flags.dimensions.width.slice(-1) == '%',\n\t                mode: null,\n\t                initialDimensions: dimensions\n\t            };\n\n\t            if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'width';\n\t                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);\n\t            } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'height';\n\t                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;\n\t            }\n\n\t            el.holderData.fluidConfig = fluidConfig;\n\t        } else {\n\t            setInvisible(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.\n\t *\n\t * @private\n\t */\n\tfunction visibilityCheck() {\n\t    var renderableImages = [];\n\t    var keys = Object.keys(App.vars.invisibleImages);\n\t    var el;\n\n\t    keys.forEach(function (key) {\n\t        el = App.vars.invisibleImages[key];\n\t        if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {\n\t            renderableImages.push(el);\n\t            delete App.vars.invisibleImages[key];\n\t        }\n\t    });\n\n\t    if (renderableImages.length) {\n\t        Holder.run({\n\t            images: renderableImages\n\t        });\n\t    }\n\n\t    // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame\n\t    setTimeout(function () {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t    }, 10);\n\t}\n\n\t/**\n\t * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.\n\t *\n\t * @private\n\t */\n\tfunction startVisibilityCheck() {\n\t    if (!App.vars.visibilityCheckStarted) {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t        App.vars.visibilityCheckStarted = true;\n\t    }\n\t}\n\n\t/**\n\t * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck\n\t *\n\t * @private\n\t * @param el Invisible DOM element\n\t */\n\tfunction setInvisible(el) {\n\t    if (!el.holderData.invisibleId) {\n\t        App.vars.invisibleId += 1;\n\t        App.vars.invisibleImages['i' + App.vars.invisibleId] = el;\n\t        el.holderData.invisibleId = App.vars.invisibleId;\n\t    }\n\t}\n\n\t//todo: see if possible to convert stagingRenderer to use HTML only\n\tvar stagingRenderer = (function() {\n\t    var svg = null,\n\t        stagingText = null,\n\t        stagingTextNode = null;\n\t    return function(graph) {\n\t        var rootNode = graph.root;\n\t        if (App.setup.supportsSVG) {\n\t            var firstTimeSetup = false;\n\t            var tnode = function(text) {\n\t                return document.createTextNode(text);\n\t            };\n\t            if (svg == null || svg.parentNode !== document.body) {\n\t                firstTimeSetup = true;\n\t            }\n\n\t            svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);\n\t            //Show staging element before staging\n\t            svg.style.display = 'block';\n\n\t            if (firstTimeSetup) {\n\t                stagingText = DOM.newEl('text', SVG_NS);\n\t                stagingTextNode = tnode(null);\n\t                DOM.setAttr(stagingText, {\n\t                    x: 0\n\t                });\n\t                stagingText.appendChild(stagingTextNode);\n\t                svg.appendChild(stagingText);\n\t                document.body.appendChild(svg);\n\t                svg.style.visibility = 'hidden';\n\t                svg.style.position = 'absolute';\n\t                svg.style.top = '-100%';\n\t                svg.style.left = '-100%';\n\t                //todo: workaround for zero-dimension <svg> tag in Opera 12\n\t                //svg.setAttribute('width', 0);\n\t                //svg.setAttribute('height', 0);\n\t            }\n\n\t            var holderTextGroup = rootNode.children.holderTextGroup;\n\t            var htgProps = holderTextGroup.properties;\n\t            DOM.setAttr(stagingText, {\n\t                'y': htgProps.font.size,\n\t                'style': utils.cssProps({\n\t                    'font-weight': htgProps.font.weight,\n\t                    'font-size': htgProps.font.size + htgProps.font.units,\n\t                    'font-family': htgProps.font.family\n\t                })\n\t            });\n\n\t            //Get bounding box for the whole string (total width and height)\n\t            stagingTextNode.nodeValue = htgProps.text;\n\t            var stagingTextBBox = stagingText.getBBox();\n\n\t            //Get line count and split the string into words\n\t            var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);\n\t            var words = htgProps.text.split(' ');\n\t            var newlines = htgProps.text.match(/\\\\n/g);\n\t            lineCount += newlines == null ? 0 : newlines.length;\n\n\t            //Get bounding box for the string with spaces removed\n\t            stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');\n\t            var computedNoSpaceLength = stagingText.getComputedTextLength();\n\n\t            //Compute average space width\n\t            var diffLength = stagingTextBBox.width - computedNoSpaceLength;\n\t            var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));\n\n\t            //Get widths for every word with space only if there is more than one line\n\t            var wordWidths = [];\n\t            if (lineCount > 1) {\n\t                stagingTextNode.nodeValue = '';\n\t                for (var i = 0; i < words.length; i++) {\n\t                    if (words[i].length === 0) continue;\n\t                    stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);\n\t                    var bbox = stagingText.getBBox();\n\t                    wordWidths.push({\n\t                        text: words[i],\n\t                        width: bbox.width\n\t                    });\n\t                }\n\t            }\n\n\t            //Hide staging element after staging\n\t            svg.style.display = 'none';\n\n\t            return {\n\t                spaceWidth: spaceWidth,\n\t                lineCount: lineCount,\n\t                boundingBox: stagingTextBBox,\n\t                words: wordWidths\n\t            };\n\t        } else {\n\t            //todo: canvas fallback for measuring text on android 2.3\n\t            return false;\n\t        }\n\t    };\n\t})();\n\n\t//Helpers\n\n\t/**\n\t * Prevents a function from being called too often, waits until a timer elapses to call it again\n\t *\n\t * @param fn Function to call\n\t */\n\tfunction debounce(fn) {\n\t    if (!App.vars.debounceTimer) fn.call(this);\n\t    if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);\n\t    App.vars.debounceTimer = global.setTimeout(function() {\n\t        App.vars.debounceTimer = null;\n\t        fn.call(this);\n\t    }, App.setup.debounce);\n\t}\n\n\t/**\n\t * Holder-specific resize/orientation change callback, debounced to prevent excessive execution\n\t */\n\tfunction resizeEvent() {\n\t    debounce(function() {\n\t        updateResizableElements(null);\n\t    });\n\t}\n\n\t//Set up flags\n\n\tfor (var flag in App.flags) {\n\t    if (!App.flags.hasOwnProperty(flag)) continue;\n\t    App.flags[flag].match = function(val) {\n\t        return val.match(this.regex);\n\t    };\n\t}\n\n\t//Properties set once on setup\n\n\tApp.setup = {\n\t    renderer: 'html',\n\t    debounce: 100,\n\t    ratio: 1,\n\t    supportsCanvas: false,\n\t    supportsSVG: false,\n\t    lineWrapRatio: 0.9,\n\t    dataAttr: 'data-src',\n\t    renderers: ['html', 'canvas', 'svg']\n\t};\n\n\t//Properties modified during runtime\n\n\tApp.vars = {\n\t    preempted: false,\n\t    resizableImages: [],\n\t    invisibleImages: {},\n\t    invisibleId: 0,\n\t    visibilityCheckStarted: false,\n\t    debounceTimer: null,\n\t    cache: {}\n\t};\n\n\t//Pre-flight\n\n\t(function() {\n\t    var canvas = DOM.newEl('canvas');\n\n\t    if (canvas.getContext) {\n\t        if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {\n\t            App.setup.renderer = 'canvas';\n\t            App.setup.supportsCanvas = true;\n\t        }\n\t    }\n\n\t    if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {\n\t        App.setup.renderer = 'svg';\n\t        App.setup.supportsSVG = true;\n\t    }\n\t})();\n\n\t//Starts checking for invisible placeholders\n\tstartVisibilityCheck();\n\n\tif (onDomReady) {\n\t    onDomReady(function() {\n\t        if (!App.vars.preempted) {\n\t            Holder.run();\n\t        }\n\t        if (global.addEventListener) {\n\t            global.addEventListener('resize', resizeEvent, false);\n\t            global.addEventListener('orientationchange', resizeEvent, false);\n\t        } else {\n\t            global.attachEvent('onresize', resizeEvent);\n\t        }\n\n\t        if (typeof global.Turbolinks == 'object') {\n\t            global.document.addEventListener('page:change', function() {\n\t                Holder.run();\n\t            });\n\t        }\n\t    });\n\t}\n\n\tmodule.exports = Holder;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license\n\t *\n\t * Specially modified to work with Holder.js\n\t */\n\n\tfunction _onDomReady(win) {\n\t    //Lazy loading fix for Firefox < 3.6\n\t    //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\t    if (document.readyState == null && document.addEventListener) {\n\t        document.addEventListener(\"DOMContentLoaded\", function DOMContentLoaded() {\n\t            document.removeEventListener(\"DOMContentLoaded\", DOMContentLoaded, false);\n\t            document.readyState = \"complete\";\n\t        }, false);\n\t        document.readyState = \"loading\";\n\t    }\n\t    \n\t    var doc = win.document,\n\t        docElem = doc.documentElement,\n\t    \n\t        LOAD = \"load\",\n\t        FALSE = false,\n\t        ONLOAD = \"on\"+LOAD,\n\t        COMPLETE = \"complete\",\n\t        READYSTATE = \"readyState\",\n\t        ATTACHEVENT = \"attachEvent\",\n\t        DETACHEVENT = \"detachEvent\",\n\t        ADDEVENTLISTENER = \"addEventListener\",\n\t        DOMCONTENTLOADED = \"DOMContentLoaded\",\n\t        ONREADYSTATECHANGE = \"onreadystatechange\",\n\t        REMOVEEVENTLISTENER = \"removeEventListener\",\n\t    \n\t        // W3C Event model\n\t        w3c = ADDEVENTLISTENER in doc,\n\t        _top = FALSE,\n\t    \n\t        // isReady: Is the DOM ready to be used? Set to true once it occurs.\n\t        isReady = FALSE,\n\t    \n\t        // Callbacks pending execution until DOM is ready\n\t        callbacks = [];\n\t    \n\t    // Handle when the DOM is ready\n\t    function ready( fn ) {\n\t        if ( !isReady ) {\n\t    \n\t            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t            if ( !doc.body ) {\n\t                return defer( ready );\n\t            }\n\t    \n\t            // Remember that the DOM is ready\n\t            isReady = true;\n\t    \n\t            // Execute all callbacks\n\t            while ( fn = callbacks.shift() ) {\n\t                defer( fn );\n\t            }\n\t        }\n\t    }\n\t    \n\t    // The ready event handler\n\t    function completed( event ) {\n\t        // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t        if ( w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE ) {\n\t            detach();\n\t            ready();\n\t        }\n\t    }\n\t    \n\t    // Clean-up method for dom ready events\n\t    function detach() {\n\t        if ( w3c ) {\n\t            doc[REMOVEEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t            win[REMOVEEVENTLISTENER]( LOAD, completed, FALSE );\n\t        } else {\n\t            doc[DETACHEVENT]( ONREADYSTATECHANGE, completed );\n\t            win[DETACHEVENT]( ONLOAD, completed );\n\t        }\n\t    }\n\t    \n\t    // Defers a function, scheduling it to run after the current call stack has cleared.\n\t    function defer( fn, wait ) {\n\t        // Allow 0 to be passed\n\t        setTimeout( fn, +wait >= 0 ? wait : 1 );\n\t    }\n\t    \n\t    // Attach the listeners:\n\t    \n\t    // Catch cases where onDomReady is called after the browser event has already occurred.\n\t    // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t    if ( doc[READYSTATE] === COMPLETE ) {\n\t        // Handle it asynchronously to allow scripts the opportunity to delay ready\n\t        defer( ready );\n\t    \n\t    // Standards-based browsers support DOMContentLoaded\n\t    } else if ( w3c ) {\n\t        // Use the handy event callback\n\t        doc[ADDEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ADDEVENTLISTENER]( LOAD, completed, FALSE );\n\t    \n\t    // If IE event model is used\n\t    } else {\n\t        // Ensure firing before onload, maybe late but safe also for iframes\n\t        doc[ATTACHEVENT]( ONREADYSTATECHANGE, completed );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ATTACHEVENT]( ONLOAD, completed );\n\t    \n\t        // If IE and not a frame\n\t        // continually check to see if the document is ready\n\t        try {\n\t            _top = win.frameElement == null && docElem;\n\t        } catch(e) {}\n\t    \n\t        if ( _top && _top.doScroll ) {\n\t            (function doScrollCheck() {\n\t                if ( !isReady ) {\n\t                    try {\n\t                        // Use the trick by Diego Perini\n\t                        // http://javascript.nwbox.com/IEContentLoaded/\n\t                        _top.doScroll(\"left\");\n\t                    } catch(e) {\n\t                        return defer( doScrollCheck, 50 );\n\t                    }\n\t    \n\t                    // detach all dom ready events\n\t                    detach();\n\t    \n\t                    // and execute any waiting functions\n\t                    ready();\n\t                }\n\t            })();\n\t        }\n\t    }\n\t    \n\t    function onDomReady( fn ) {\n\t        // If DOM is ready, execute the function (async), otherwise wait\n\t        isReady ? defer( fn ) : callbacks.push( fn );\n\t    }\n\t    \n\t    // Add version\n\t    onDomReady.version = \"1.4.0\";\n\t    // Add method to check if DOM is ready\n\t    onDomReady.isReady = function(){\n\t        return isReady;\n\t    };\n\n\t    return onDomReady;\n\t}\n\n\tmodule.exports = typeof window !== \"undefined\" && _onDomReady(window);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Modified version of component/querystring\n\t//Changes: updated dependencies, dot notation parsing, JSHint fixes\n\t//Fork at https://github.com/imsky/querystring\n\n\t/**\n\t * Module dependencies.\n\t */\n\n\tvar encode = encodeURIComponent;\n\tvar decode = decodeURIComponent;\n\tvar trim = __webpack_require__(4);\n\tvar type = __webpack_require__(5);\n\n\tvar arrayRegex = /(\\w+)\\[(\\d+)\\]/;\n\tvar objectRegex = /\\w+\\.\\w+/;\n\n\t/**\n\t * Parse the given query `str`.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api public\n\t */\n\n\texports.parse = function(str){\n\t  if ('string' !== typeof str) return {};\n\n\t  str = trim(str);\n\t  if ('' === str) return {};\n\t  if ('?' === str.charAt(0)) str = str.slice(1);\n\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    var parts = pairs[i].split('=');\n\t    var key = decode(parts[0]);\n\t    var m, ctx, prop;\n\n\t    if (m = arrayRegex.exec(key)) {\n\t      obj[m[1]] = obj[m[1]] || [];\n\t      obj[m[1]][m[2]] = decode(parts[1]);\n\t      continue;\n\t    }\n\n\t    if (m = objectRegex.test(key)) {\n\t      m = key.split('.');\n\t      ctx = obj;\n\t      \n\t      while (m.length) {\n\t        prop = m.shift();\n\n\t        if (!prop.length) continue;\n\n\t        if (!ctx[prop]) {\n\t          ctx[prop] = {};\n\t        } else if (ctx[prop] && typeof ctx[prop] !== 'object') {\n\t          break;\n\t        }\n\n\t        if (!m.length) {\n\t          ctx[prop] = decode(parts[1]);\n\t        }\n\n\t        ctx = ctx[prop];\n\t      }\n\n\t      continue;\n\t    }\n\n\t    obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);\n\t  }\n\n\t  return obj;\n\t};\n\n\t/**\n\t * Stringify the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api public\n\t */\n\n\texports.stringify = function(obj){\n\t  if (!obj) return '';\n\t  var pairs = [];\n\n\t  for (var key in obj) {\n\t    var value = obj[key];\n\n\t    if ('array' == type(value)) {\n\t      for (var i = 0; i < value.length; ++i) {\n\t        pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));\n\t      }\n\t      continue;\n\t    }\n\n\t    pairs.push(encode(key) + '=' + encode(obj[key]));\n\t  }\n\n\t  return pairs.join('&');\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\n\texports = module.exports = trim;\n\n\tfunction trim(str){\n\t  return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\n\texports.left = function(str){\n\t  return str.replace(/^\\s*/, '');\n\t};\n\n\texports.right = function(str){\n\t  return str.replace(/\\s*$/, '');\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * toString ref.\n\t */\n\n\tvar toString = Object.prototype.toString;\n\n\t/**\n\t * Return the type of `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {String}\n\t * @api public\n\t */\n\n\tmodule.exports = function(val){\n\t  switch (toString.call(val)) {\n\t    case '[object Date]': return 'date';\n\t    case '[object RegExp]': return 'regexp';\n\t    case '[object Arguments]': return 'arguments';\n\t    case '[object Array]': return 'array';\n\t    case '[object Error]': return 'error';\n\t  }\n\n\t  if (val === null) return 'null';\n\t  if (val === undefined) return 'undefined';\n\t  if (val !== val) return 'nan';\n\t  if (val && val.nodeType === 1) return 'element';\n\n\t  if (isBuffer(val)) return 'buffer';\n\n\t  val = val.valueOf\n\t    ? val.valueOf()\n\t    : Object.prototype.valueOf.apply(val);\n\n\t  return typeof val;\n\t};\n\n\t// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js\n\tfunction isBuffer(obj) {\n\t  return !!(obj != null &&\n\t    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n\t      (obj.constructor &&\n\t      typeof obj.constructor.isBuffer === 'function' &&\n\t      obj.constructor.isBuffer(obj))\n\t    ))\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar SceneGraph = function(sceneProperties) {\n\t    var nodeCount = 1;\n\n\t    //todo: move merge to helpers section\n\t    function merge(parent, child) {\n\t        for (var prop in child) {\n\t            parent[prop] = child[prop];\n\t        }\n\t        return parent;\n\t    }\n\n\t    var SceneNode = function(name) {\n\t        nodeCount++;\n\t        this.parent = null;\n\t        this.children = {};\n\t        this.id = nodeCount;\n\t        this.name = 'n' + nodeCount;\n\t        if (typeof name !== 'undefined') {\n\t            this.name = name;\n\t        }\n\t        this.x = this.y = this.z = 0;\n\t        this.width = this.height = 0;\n\t    };\n\n\t    SceneNode.prototype.resize = function(width, height) {\n\t        if (width != null) {\n\t            this.width = width;\n\t        }\n\t        if (height != null) {\n\t            this.height = height;\n\t        }\n\t    };\n\n\t    SceneNode.prototype.moveTo = function(x, y, z) {\n\t        this.x = x != null ? x : this.x;\n\t        this.y = y != null ? y : this.y;\n\t        this.z = z != null ? z : this.z;\n\t    };\n\n\t    SceneNode.prototype.add = function(child) {\n\t        var name = child.name;\n\t        if (typeof this.children[name] === 'undefined') {\n\t            this.children[name] = child;\n\t            child.parent = this;\n\t        } else {\n\t            throw 'SceneGraph: child already exists: ' + name;\n\t        }\n\t    };\n\n\t    var RootNode = function() {\n\t        SceneNode.call(this, 'root');\n\t        this.properties = sceneProperties;\n\t    };\n\n\t    RootNode.prototype = new SceneNode();\n\n\t    var Shape = function(name, props) {\n\t        SceneNode.call(this, name);\n\t        this.properties = {\n\t            'fill': '#000000'\n\t        };\n\t        if (typeof props !== 'undefined') {\n\t            merge(this.properties, props);\n\t        } else if (typeof name !== 'undefined' && typeof name !== 'string') {\n\t            throw 'SceneGraph: invalid node name';\n\t        }\n\t    };\n\n\t    Shape.prototype = new SceneNode();\n\n\t    var Group = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'group';\n\t    };\n\n\t    Group.prototype = new Shape();\n\n\t    var Rect = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'rect';\n\t    };\n\n\t    Rect.prototype = new Shape();\n\n\t    var Text = function(text) {\n\t        Shape.call(this);\n\t        this.type = 'text';\n\t        this.properties.text = text;\n\t    };\n\n\t    Text.prototype = new Shape();\n\n\t    var root = new RootNode();\n\n\t    this.Shape = {\n\t        'Rect': Rect,\n\t        'Text': Text,\n\t        'Group': Group\n\t    };\n\n\t    this.root = root;\n\t    return this;\n\t};\n\n\tmodule.exports = SceneGraph;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Shallow object clone and merge\n\t *\n\t * @param a Object A\n\t * @param b Object B\n\t * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties\n\t */\n\texports.extend = function(a, b) {\n\t    var c = {};\n\t    for (var x in a) {\n\t        if (a.hasOwnProperty(x)) {\n\t            c[x] = a[x];\n\t        }\n\t    }\n\t    if (b != null) {\n\t        for (var y in b) {\n\t            if (b.hasOwnProperty(y)) {\n\t                c[y] = b[y];\n\t            }\n\t        }\n\t    }\n\t    return c;\n\t};\n\n\t/**\n\t * Takes a k/v list of CSS properties and returns a rule\n\t *\n\t * @param props CSS properties object\n\t */\n\texports.cssProps = function(props) {\n\t    var ret = [];\n\t    for (var p in props) {\n\t        if (props.hasOwnProperty(p)) {\n\t            ret.push(p + ':' + props[p]);\n\t        }\n\t    }\n\t    return ret.join(';');\n\t};\n\n\t/**\n\t * Encodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.encodeHtmlEntity = function(str) {\n\t    var buf = [];\n\t    var charCode = 0;\n\t    for (var i = str.length - 1; i >= 0; i--) {\n\t        charCode = str.charCodeAt(i);\n\t        if (charCode > 128) {\n\t            buf.unshift(['&#', charCode, ';'].join(''));\n\t        } else {\n\t            buf.unshift(str[i]);\n\t        }\n\t    }\n\t    return buf.join('');\n\t};\n\n\t/**\n\t * Checks if an image exists\n\t *\n\t * @param src URL of image\n\t * @param callback Callback to call once image status has been found\n\t */\n\texports.imageExists = function(src, callback) {\n\t    var image = new Image();\n\t    image.onerror = function() {\n\t        callback.call(this, false);\n\t    };\n\t    image.onload = function() {\n\t        callback.call(this, true);\n\t    };\n\t    image.src = src;\n\t};\n\n\t/**\n\t * Decodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.decodeHtmlEntity = function(str) {\n\t    return str.replace(/&#(\\d+);/g, function(match, dec) {\n\t        return String.fromCharCode(dec);\n\t    });\n\t};\n\n\n\t/**\n\t * Returns an element's dimensions if it's visible, `false` otherwise.\n\t *\n\t * @param el DOM element\n\t */\n\texports.dimensionCheck = function(el) {\n\t    var dimensions = {\n\t        height: el.clientHeight,\n\t        width: el.clientWidth\n\t    };\n\n\t    if (dimensions.height && dimensions.width) {\n\t        return dimensions;\n\t    } else {\n\t        return false;\n\t    }\n\t};\n\n\n\t/**\n\t * Returns true if value is truthy or if it is \"semantically truthy\"\n\t * @param val\n\t */\n\texports.truthy = function(val) {\n\t    if (typeof val === 'string') {\n\t        return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === '✓';\n\t    }\n\t    return !!val;\n\t};\n\n\t/**\n\t * Parses input into a well-formed CSS color\n\t * @param val\n\t */\n\texports.parseColor = function(val) {\n\t    var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;\n\t    var rgbre = /^rgb\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\n\t    var rgbare = /^rgba\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(0\\.\\d{1,}|1)\\)$/;\n\n\t    var match = val.match(hexre);\n\t    var retval;\n\n\t    if (match !== null) {\n\t        retval = match[1] || match[2];\n\t        if (retval[0] !== '#') {\n\t            return '#' + retval;\n\t        } else {\n\t            return retval;\n\t        }\n\t    }\n\n\t    match = val.match(rgbre);\n\n\t    if (match !== null) {\n\t        retval = 'rgb(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    match = val.match(rgbare);\n\n\t    if (match !== null) {\n\t        retval = 'rgba(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    return null;\n\t};\n\n\t/**\n\t * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)\n\t */\n\texports.canvasRatio = function () {\n\t    var devicePixelRatio = 1;\n\t    var backingStoreRatio = 1;\n\n\t    if (global.document) {\n\t        var canvas = global.document.createElement('canvas');\n\t        if (canvas.getContext) {\n\t            var ctx = canvas.getContext('2d');\n\t            devicePixelRatio = global.devicePixelRatio || 1;\n\t            backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n\t        }\n\t    }\n\n\t    return devicePixelRatio / backingStoreRatio;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var DOM = __webpack_require__(9);\n\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\tvar NODE_TYPE_COMMENT = 8;\n\n\t/**\n\t * Generic SVG element creation function\n\t *\n\t * @param svg SVG context, set to null if new\n\t * @param width Document width\n\t * @param height Document height\n\t */\n\texports.initSVG = function(svg, width, height) {\n\t    var defs, style, initialize = false;\n\n\t    if (svg && svg.querySelector) {\n\t        style = svg.querySelector('style');\n\t        if (style === null) {\n\t            initialize = true;\n\t        }\n\t    } else {\n\t        svg = DOM.newEl('svg', SVG_NS);\n\t        initialize = true;\n\t    }\n\n\t    if (initialize) {\n\t        defs = DOM.newEl('defs', SVG_NS);\n\t        style = DOM.newEl('style', SVG_NS);\n\t        DOM.setAttr(style, {\n\t            'type': 'text/css'\n\t        });\n\t        defs.appendChild(style);\n\t        svg.appendChild(defs);\n\t    }\n\n\t    //IE throws an exception if this is set and Chrome requires it to be set\n\t    if (svg.webkitMatchesSelector) {\n\t        svg.setAttribute('xmlns', SVG_NS);\n\t    }\n\n\t    //Remove comment nodes\n\t    for (var i = 0; i < svg.childNodes.length; i++) {\n\t        if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {\n\t            svg.removeChild(svg.childNodes[i]);\n\t        }\n\t    }\n\n\t    //Remove CSS\n\t    while (style.childNodes.length) {\n\t        style.removeChild(style.childNodes[0]);\n\t    }\n\n\t    DOM.setAttr(svg, {\n\t        'width': width,\n\t        'height': height,\n\t        'viewBox': '0 0 ' + width + ' ' + height,\n\t        'preserveAspectRatio': 'none'\n\t    });\n\n\t    return svg;\n\t};\n\n\t/**\n\t * Converts serialized SVG to a string suitable for data URI use\n\t * @param svgString Serialized SVG string\n\t * @param [base64] Use base64 encoding for data URI\n\t */\n\texports.svgStringToDataURI = function() {\n\t    var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';\n\t    var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';\n\n\t    return function(svgString, base64) {\n\t        if (base64) {\n\t            return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));\n\t        } else {\n\t            return rawPrefix + encodeURIComponent(svgString);\n\t        }\n\t    };\n\t}();\n\n\t/**\n\t * Returns serialized SVG with XML processing instructions\n\t *\n\t * @param svg SVG context\n\t * @param stylesheets CSS stylesheets to include\n\t */\n\texports.serializeSVG = function(svg, engineSettings) {\n\t    if (!global.XMLSerializer) return;\n\t    var serializer = new XMLSerializer();\n\t    var svgCSS = '';\n\t    var stylesheets = engineSettings.stylesheets;\n\n\t    //External stylesheets: Processing Instruction method\n\t    if (engineSettings.svgXMLStylesheet) {\n\t        var xml = DOM.createXML();\n\t        //Add <?xml-stylesheet ?> directives\n\t        for (var i = stylesheets.length - 1; i >= 0; i--) {\n\t            var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href=\"' + stylesheets[i] + '\" rel=\"stylesheet\"');\n\t            xml.insertBefore(csspi, xml.firstChild);\n\t        }\n\n\t        xml.removeChild(xml.documentElement);\n\t        svgCSS = serializer.serializeToString(xml);\n\t    }\n\n\t    var svgText = serializer.serializeToString(svg);\n\t    svgText = svgText.replace(/\\&amp;(\\#[0-9]{2,}\\;)/g, '&$1');\n\t    return svgCSS + svgText;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Generic new DOM element function\n\t *\n\t * @param tag Tag to create\n\t * @param namespace Optional namespace value\n\t */\n\texports.newEl = function(tag, namespace) {\n\t    if (!global.document) return;\n\n\t    if (namespace == null) {\n\t        return global.document.createElement(tag);\n\t    } else {\n\t        return global.document.createElementNS(namespace, tag);\n\t    }\n\t};\n\n\t/**\n\t * Generic setAttribute function\n\t *\n\t * @param el Reference to DOM element\n\t * @param attrs Object with attribute keys and values\n\t */\n\texports.setAttr = function (el, attrs) {\n\t    for (var a in attrs) {\n\t        el.setAttribute(a, attrs[a]);\n\t    }\n\t};\n\n\t/**\n\t * Creates a XML document\n\t * @private\n\t */\n\texports.createXML = function() {\n\t    if (!global.DOMParser) return;\n\t    return new DOMParser().parseFromString('<xml />', 'application/xml');\n\t};\n\n\t/**\n\t * Converts a value into an array of DOM nodes\n\t *\n\t * @param val A string, a NodeList, a Node, or an HTMLCollection\n\t */\n\texports.getNodeArray = function(val) {\n\t    var retval = null;\n\t    if (typeof(val) == 'string') {\n\t        retval = document.querySelectorAll(val);\n\t    } else if (global.NodeList && val instanceof global.NodeList) {\n\t        retval = val;\n\t    } else if (global.Node && val instanceof global.Node) {\n\t        retval = [val];\n\t    } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {\n\t        retval = val;\n\t    } else if (val instanceof Array) {\n\t        retval = val;\n\t    } else if (val === null) {\n\t        retval = [];\n\t    }\n\n\t    retval = Array.prototype.slice.call(retval);\n\n\t    return retval;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar Color = function(color, options) {\n\t    //todo: support rgba, hsla, and rrggbbaa notation\n\t    //todo: use CIELAB internally\n\t    //todo: add clamp function (with sign)\n\t    if (typeof color !== 'string') return;\n\n\t    this.original = color;\n\n\t    if (color.charAt(0) === '#') {\n\t        color = color.slice(1);\n\t    }\n\n\t    if (/[^a-f0-9]+/i.test(color)) return;\n\n\t    if (color.length === 3) {\n\t        color = color.replace(/./g, '$&$&');\n\t    }\n\n\t    if (color.length !== 6) return;\n\n\t    this.alpha = 1;\n\n\t    if (options && options.alpha) {\n\t        this.alpha = options.alpha;\n\t    }\n\n\t    this.set(parseInt(color, 16));\n\t};\n\n\t//todo: jsdocs\n\tColor.rgb2hex = function(r, g, b) {\n\t    function format (decimal) {\n\t        var hex = (decimal | 0).toString(16);\n\t        if (decimal < 16) {\n\t            hex = '0' + hex;\n\t        }\n\t        return hex;\n\t    }\n\n\t    return [r, g, b].map(format).join('');\n\t};\n\n\t//todo: jsdocs\n\tColor.hsl2rgb = function (h, s, l) {\n\t    var H = h / 60;\n\t    var C = (1 - Math.abs(2 * l - 1)) * s;\n\t    var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));\n\t    var m = l - (C / 2);\n\n\t    var r = 0, g = 0, b = 0;\n\n\t    if (H >= 0 && H < 1) {\n\t        r = C;\n\t        g = X;\n\t    } else if (H >= 1 && H < 2) {\n\t        r = X;\n\t        g = C;\n\t    } else if (H >= 2 && H < 3) {\n\t        g = C;\n\t        b = X;\n\t    } else if (H >= 3 && H < 4) {\n\t        g = X;\n\t        b = C;\n\t    } else if (H >= 4 && H < 5) {\n\t        r = X;\n\t        b = C;\n\t    } else if (H >= 5 && H < 6) {\n\t        r = C;\n\t        b = X;\n\t    }\n\n\t    r += m;\n\t    g += m;\n\t    b += m;\n\n\t    r = parseInt(r * 255);\n\t    g = parseInt(g * 255);\n\t    b = parseInt(b * 255);\n\n\t    return [r, g, b];\n\t};\n\n\t/**\n\t * Sets the color from a raw RGB888 integer\n\t * @param raw RGB888 representation of color\n\t */\n\t//todo: refactor into a static method\n\t//todo: factor out individual color spaces\n\t//todo: add HSL, CIELAB, and CIELUV\n\tColor.prototype.set = function (val) {\n\t    this.raw = val;\n\n\t    var r = (this.raw & 0xFF0000) >> 16;\n\t    var g = (this.raw & 0x00FF00) >> 8;\n\t    var b = (this.raw & 0x0000FF);\n\n\t    // BT.709\n\t    var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\t    var u = -0.09991 * r - 0.33609 * g + 0.436 * b;\n\t    var v = 0.615 * r - 0.55861 * g - 0.05639 * b;\n\n\t    this.rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b\n\t    };\n\n\t    this.yuv = {\n\t        y: y,\n\t        u: u,\n\t        v: v\n\t    };\n\n\t    return this;\n\t};\n\n\t/**\n\t * Lighten or darken a color\n\t * @param multiplier Amount to lighten or darken (-1 to 1)\n\t */\n\tColor.prototype.lighten = function(multiplier) {\n\t    var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);\n\t    var bm = (255 * cm) | 0;\n\t    var cr = Math.min(255, Math.max(0, this.rgb.r + bm));\n\t    var cg = Math.min(255, Math.max(0, this.rgb.g + bm));\n\t    var cb = Math.min(255, Math.max(0, this.rgb.b + bm));\n\t    var hex = Color.rgb2hex(cr, cg, cb);\n\t    return new Color(hex);\n\t};\n\n\t/**\n\t * Output color in hex format\n\t * @param addHash Add a hash character to the beginning of the output\n\t */\n\tColor.prototype.toHex = function(addHash) {\n\t    return (addHash ? '#' : '') + this.raw.toString(16);\n\t};\n\n\t/**\n\t * Returns whether or not current color is lighter than another color\n\t * @param color Color to compare against\n\t */\n\tColor.prototype.lighterThan = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    return this.yuv.y > color.yuv.y;\n\t};\n\n\t/**\n\t * Returns the result of mixing current color with another color\n\t * @param color Color to mix with\n\t * @param multiplier How much to mix with the other color\n\t */\n\t/*\n\tColor.prototype.mix = function (color, multiplier) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var r = this.rgb.r;\n\t    var g = this.rgb.g;\n\t    var b = this.rgb.b;\n\t    var a = this.alpha;\n\n\t    var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;\n\n\t    //todo: write a lerp function\n\t    r = r + m * (color.rgb.r - r);\n\t    g = g + m * (color.rgb.g - g);\n\t    b = b + m * (color.rgb.b - b);\n\t    a = a + m * (color.alpha - a);\n\n\t    return new Color(Color.rgbToHex(r, g, b), {\n\t        'alpha': a\n\t    });\n\t};\n\t*/\n\n\t/**\n\t * Returns the result of blending another color on top of current color with alpha\n\t * @param color Color to blend on top of current color, i.e. \"Ca\"\n\t */\n\t//todo: see if .blendAlpha can be merged into .mix\n\tColor.prototype.blendAlpha = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var Ca = color;\n\t    var Cb = this;\n\n\t    //todo: write alpha blending function\n\t    var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;\n\t    var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;\n\t    var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;\n\n\t    return new Color(Color.rgb2hex(r, g, b));\n\t};\n\n\tmodule.exports = Color;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t  'version': '2.9.4',\n\t  'svg_ns': 'http://www.w3.org/2000/svg'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shaven = __webpack_require__(13);\n\n\tvar SVG = __webpack_require__(8);\n\tvar constants = __webpack_require__(11);\n\tvar utils = __webpack_require__(7);\n\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar templates = {\n\t  'element': function (options) {\n\t    var tag = options.tag;\n\t    var content = options.content || '';\n\t    delete options.tag;\n\t    delete options.content;\n\t    return  [tag, content, options];\n\t  }\n\t};\n\n\t//todo: deprecate tag arg, infer tag from shape object\n\tfunction convertShape (shape, tag) {\n\t  return templates.element({\n\t    'tag': tag,\n\t    'width': shape.width,\n\t    'height': shape.height,\n\t    'fill': shape.properties.fill\n\t  });\n\t}\n\n\tfunction textCss (properties) {\n\t  return utils.cssProps({\n\t    'fill': properties.fill,\n\t    'font-weight': properties.font.weight,\n\t    'font-family': properties.font.family + ', monospace',\n\t    'font-size': properties.font.size + properties.font.units\n\t  });\n\t}\n\n\tfunction outlinePath (bgWidth, bgHeight, outlineWidth) {\n\t  var outlineOffsetWidth = outlineWidth / 2;\n\n\t  return [\n\t    'M', outlineOffsetWidth, outlineOffsetWidth,\n\t    'H', bgWidth - outlineOffsetWidth,\n\t    'V', bgHeight - outlineOffsetWidth,\n\t    'H', outlineOffsetWidth,\n\t    'V', 0,\n\t    'M', 0, outlineOffsetWidth,\n\t    'L', bgWidth, bgHeight - outlineOffsetWidth,\n\t    'M', 0, bgHeight - outlineOffsetWidth,\n\t    'L', bgWidth, outlineOffsetWidth\n\t  ].join(' ');\n\t}\n\n\tmodule.exports = function (sceneGraph, renderSettings) {\n\t  var engineSettings = renderSettings.engineSettings;\n\t  var stylesheets = engineSettings.stylesheets;\n\t  var stylesheetXml = stylesheets.map(function (stylesheet) {\n\t    return '<?xml-stylesheet rel=\"stylesheet\" href=\"' + stylesheet + '\"?>';\n\t  }).join('\\n');\n\n\t  var holderId = 'holder_' + Number(new Date()).toString(16);\n\n\t  var root = sceneGraph.root;\n\t  var textGroup = root.children.holderTextGroup;\n\n\t  var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } ';\n\n\t  // push text down to be equally vertically aligned with canvas renderer\n\t  textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;\n\n\t  var wordTags = [];\n\n\t  Object.keys(textGroup.children).forEach(function (lineKey) {\n\t    var line = textGroup.children[lineKey];\n\n\t    Object.keys(line.children).forEach(function (wordKey) {\n\t      var word = line.children[wordKey];\n\t      var x = textGroup.x + line.x + word.x;\n\t      var y = textGroup.y + line.y + word.y;\n\n\t      var wordTag = templates.element({\n\t        'tag': 'text',\n\t        'content': word.properties.text,\n\t        'x': x,\n\t        'y': y\n\t      });\n\n\t      wordTags.push(wordTag);\n\t    });\n\t  });\n\n\t  var text = templates.element({\n\t    'tag': 'g',\n\t    'content': wordTags\n\t  });\n\n\t  var outline = null;\n\n\t  if (root.children.holderBg.properties.outline) {\n\t    var outlineProperties = root.children.holderBg.properties.outline;\n\t    outline = templates.element({\n\t      'tag': 'path',\n\t      'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),\n\t      'stroke-width': outlineProperties.width,\n\t      'stroke': outlineProperties.fill,\n\t      'fill': 'none'\n\t    });\n\t  }\n\n\t  var bg = convertShape(root.children.holderBg, 'rect');\n\n\t  var sceneContent = [];\n\n\t  sceneContent.push(bg);\n\t  if (outlineProperties) {\n\t    sceneContent.push(outline);\n\t  }\n\t  sceneContent.push(text);\n\n\t  var scene = templates.element({\n\t    'tag': 'g',\n\t    'id': holderId,\n\t    'content': sceneContent\n\t  });\n\n\t  var style = templates.element({\n\t    'tag': 'style',\n\t    //todo: figure out how to add CDATA directive\n\t    'content': css,\n\t    'type': 'text/css'\n\t  });\n\n\t  var defs = templates.element({\n\t    'tag': 'defs',\n\t    'content': style\n\t  });\n\n\t  var svg = templates.element({\n\t    'tag': 'svg',\n\t    'content': [defs, scene],\n\t    'width': root.properties.width,\n\t    'height': root.properties.height,\n\t    'xmlns': SVG_NS,\n\t    'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),\n\t    'preserveAspectRatio': 'none'\n\t  });\n\n\t  var output = shaven(svg);\n\t  \n\t  output = stylesheetXml + output[0];\n\n\t  var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');\n\t  return svgString;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar escape = __webpack_require__(14)\n\n\t// TODO: remove namespace\n\n\tmodule.exports = function shaven (array, namespace, returnObject) {\n\n\t\t'use strict'\n\n\t\tvar i = 1\n\t\tvar doesEscape = true\n\t\tvar HTMLString\n\t\tvar attributeKey\n\t\tvar callback\n\t\tvar key\n\n\n\t\treturnObject = returnObject || {}\n\n\n\t\tfunction createElement (sugarString) {\n\n\t\t\tvar tags = sugarString.match(/^[\\w-]+/)\n\t\t\tvar element = {\n\t\t\t\ttag: tags ? tags[0] : 'div',\n\t\t\t\tattr: {},\n\t\t\t\tchildren: []\n\t\t\t}\n\t\t\tvar id = sugarString.match(/#([\\w-]+)/)\n\t\t\tvar reference = sugarString.match(/\\$([\\w-]+)/)\n\t\t\tvar classNames = sugarString.match(/\\.[\\w-]+/g)\n\n\n\t\t\t// Assign id if is set\n\t\t\tif (id) {\n\t\t\t\telement.attr.id = id[1]\n\n\t\t\t\t// Add element to the return object\n\t\t\t\treturnObject[id[1]] = element\n\t\t\t}\n\n\t\t\tif (reference)\n\t\t\t\treturnObject[reference[1]] = element\n\n\t\t\tif (classNames)\n\t\t\t\telement.attr.class = classNames.join(' ').replace(/\\./g, '')\n\n\t\t\tif (sugarString.match(/&$/g))\n\t\t\t\tdoesEscape = false\n\n\t\t\treturn element\n\t\t}\n\n\t\tfunction replacer (key, value) {\n\n\t\t\tif (value === null || value === false || value === undefined)\n\t\t\t\treturn\n\n\t\t\tif (typeof value !== 'string' && typeof value !== 'object')\n\t\t\t\treturn String(value)\n\n\t\t\treturn value\n\t\t}\n\n\t\tfunction escapeAttribute (string) {\n\t\t\treturn (string || string === 0) ?\n\t\t\t\tString(string)\n\t\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t\t.replace(/\"/g, '&quot;') :\n\t\t\t\t''\n\t\t}\n\n\t\tfunction escapeHTML (string) {\n\t\t\treturn String(string)\n\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t\t.replace(/'/g, '&apos;')\n\t\t\t\t.replace(/</g, '&lt;')\n\t\t\t\t.replace(/>/g, '&gt;')\n\t\t}\n\n\n\t\tif (typeof array[0] === 'string')\n\t\t\tarray[0] = createElement(array[0])\n\n\t\telse if (Array.isArray(array[0]))\n\t\t\ti = 0\n\n\t\telse\n\t\t\tthrow new Error(\n\t\t\t\t'First element of array must be a string, ' +\n\t\t\t\t'or an array and not ' + JSON.stringify(array[0])\n\t\t\t)\n\n\n\t\tfor (; i < array.length; i++) {\n\n\t\t\t// Don't render element if value is false or null\n\t\t\tif (array[i] === false || array[i] === null) {\n\t\t\t\tarray[0] = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Continue with next array value if current value is undefined or true\n\t\t\telse if (array[i] === undefined || array[i] === true) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'string') {\n\t\t\t\tif (doesEscape)\n\t\t\t\t\tarray[i] = escapeHTML(array[i])\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'number') {\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (Array.isArray(array[i])) {\n\n\t\t\t\tif (Array.isArray(array[i][0])) {\n\t\t\t\t\tarray[i].reverse().forEach(function (subArray) {\n\t\t\t\t\t\tarray.splice(i + 1, 0, subArray)\n\t\t\t\t\t})\n\n\t\t\t\t\tif (i !== 0)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\ti++\n\t\t\t\t}\n\n\t\t\t\tshaven(array[i], namespace, returnObject)\n\n\t\t\t\tif (array[i][0])\n\t\t\t\t\tarray[0].children.push(array[i][0])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'function')\n\t\t\t\tcallback = array[i]\n\n\n\t\t\telse if (typeof array[i] === 'object') {\n\t\t\t\tfor (attributeKey in array[i])\n\t\t\t\t\tif (array[i].hasOwnProperty(attributeKey))\n\t\t\t\t\t\tif (array[i][attributeKey] !== null &&\n\t\t\t\t\t\t\tarray[i][attributeKey] !== false)\n\t\t\t\t\t\t\tif (attributeKey === 'style' &&\n\t\t\t\t\t\t\t\ttypeof array[i][attributeKey] === 'object')\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = JSON\n\t\t\t\t\t\t\t\t\t.stringify(array[i][attributeKey], replacer)\n\t\t\t\t\t\t\t\t\t.slice(2, -2)\n\t\t\t\t\t\t\t\t\t.replace(/\",\"/g, ';')\n\t\t\t\t\t\t\t\t\t.replace(/\":\"/g, ':')\n\t\t\t\t\t\t\t\t\t.replace(/\\\\\"/g, '\\'')\n\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = array[i][attributeKey]\n\t\t\t}\n\n\t\t\telse\n\t\t\t\tthrow new TypeError('\"' + array[i] + '\" is not allowed as a value.')\n\t\t}\n\n\n\t\tif (array[0] !== false) {\n\n\t\t\tHTMLString = '<' + array[0].tag\n\n\t\t\tfor (key in array[0].attr)\n\t\t\t\tif (array[0].attr.hasOwnProperty(key))\n\t\t\t\t\tHTMLString += ' ' + key + '=\"' +\n\t\t\t\t\t\tescapeAttribute(array[0].attr[key]) + '\"'\n\n\t\t\tHTMLString += '>'\n\n\t\t\tarray[0].children.forEach(function (child) {\n\t\t\t\tHTMLString += child\n\t\t\t})\n\n\t\t\tHTMLString += '</' + array[0].tag + '>'\n\n\t\t\tarray[0] = HTMLString\n\t\t}\n\n\t\t// Return root element on index 0\n\t\treturnObject[0] = array[0]\n\n\t\tif (callback)\n\t\t\tcallback(array[0])\n\n\t\t// returns object containing all elements with an id and the root element\n\t\treturn returnObject\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\n\t'use strict';\n\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\n\tmodule.exports = escapeHtml;\n\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\n\t  if (!match) {\n\t    return str;\n\t  }\n\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DOM = __webpack_require__(9);\n\tvar utils = __webpack_require__(7);\n\n\tmodule.exports = (function() {\n\t    var canvas = DOM.newEl('canvas');\n\t    var ctx = null;\n\n\t    return function(sceneGraph) {\n\t        if (ctx == null) {\n\t            ctx = canvas.getContext('2d');\n\t        }\n\n\t        var dpr = utils.canvasRatio();\n\t        var root = sceneGraph.root;\n\t        canvas.width = dpr * root.properties.width;\n\t        canvas.height = dpr * root.properties.height ;\n\t        ctx.textBaseline = 'middle';\n\n\t        var bg = root.children.holderBg;\n\t        var bgWidth = dpr * bg.width;\n\t        var bgHeight = dpr * bg.height;\n\t        //todo: parametrize outline width (e.g. in scene object)\n\t        var outlineWidth = 2;\n\t        var outlineOffsetWidth = outlineWidth / 2;\n\n\t        ctx.fillStyle = bg.properties.fill;\n\t        ctx.fillRect(0, 0, bgWidth, bgHeight);\n\n\t        if (bg.properties.outline) {\n\t            //todo: abstract this into a method\n\t            ctx.strokeStyle = bg.properties.outline.fill;\n\t            ctx.lineWidth = bg.properties.outline.width;\n\t            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // TL, TR, BR, BL\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // Diagonals\n\t            ctx.moveTo(0, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.moveTo(0, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, outlineOffsetWidth);\n\t            ctx.stroke();\n\t        }\n\n\t        var textGroup = root.children.holderTextGroup;\n\t        ctx.font = textGroup.properties.font.weight + ' ' + (dpr * textGroup.properties.font.size) + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';\n\t        ctx.fillStyle = textGroup.properties.fill;\n\n\t        for (var lineKey in textGroup.children) {\n\t            var line = textGroup.children[lineKey];\n\t            for (var wordKey in line.children) {\n\t                var word = line.children[wordKey];\n\t                var x = dpr * (textGroup.x + line.x + word.x);\n\t                var y = dpr * (textGroup.y + line.y + word.y + (textGroup.properties.leading / 2));\n\n\t                ctx.fillText(word.properties.text, x, y);\n\t            }\n\t        }\n\n\t        return canvas.toDataURL('image/png');\n\t    };\n\t})();\n\n/***/ }\n/******/ ])\n});\n;\n(function(ctx, isMeteorPackage) {\n    if (isMeteorPackage) {\n        Holder = ctx.Holder;\n    }\n})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/holderjs/holder.js\n// module id = 6\n// module chunks = 0","/**\n * 文件容量转换具体的bytes数值\n * @param fileSize 参数类型（String），例：2MB，230KB，1TB等\n * @param thousand 参数类型（boolean），是否以1000为计算单位，否则以默认的1024为计算单位\n */\nlet fileSize2Bytes = (fileSize, thousand)=>{\n    if(!fileSize) return null;\n    let baseUnit = thousand ? 1000 : 1024;\n    let kb = baseUnit, mb = kb * baseUnit, gb = mb * baseUnit;\n    let tmpCode = fileSize.substring(fileSize.length - 2).toUpperCase();\n    let sizeNumber = fileSize.substring(0, fileSize.length - 2);\n    let num = Number.parseInt(sizeNumber);\n    let result = 0;\n    switch (tmpCode) {\n        case 'KB':\n            result = num * kb;\n            break;\n        case 'MB':\n            result = num * mb;\n            break;\n        case 'GB':\n            result = num * gb;\n            break;\n    }\n    return result;\n};\n\nconst i18n = {\n    cn: {\n        messages: {\n            'typeError' : \"{file} 文件格式不正确。有效格式： {extensions}\",\n            'sizeError' : \"{file} 文件容量超过限制, 文件最大容量为： {sizeLimit}\",\n            'minSizeError' : \"{file} 文件容量低于限制, 上传的文件最小容量为： {minSizeLimit}.\",\n            'emptyError' : \"{file} 文件为空，请选择其他文件进行上传。\",\n            'noFilesError' : \"未选择任何文件进行上传\",\n            'tooManyItemsError' : \"太多文件 ({netItems}) 需要被上传，上传文件数量限制为： {itemLimit}个\",\n            'maxHeightImageError' : \"图片高度超过限制\",\n            'maxWidthImageError' : \"图片宽度超过限制\",\n            'minHeightImageError' : \"图片高度不足\",\n            'minWidthImageError' : \"图片宽度不足\",\n            'retryFailTooManyItems' : \"重试失败 - 您已达到文件数量上限。\",\n            'onLeave' : \"文件正在上传，若离开该页面，正在上传的文件将被取消\"\n        },\n        text: {\n            'failUpload' : '上传失败',\n            'fileInputTitle' : '选择文件进行上传'\n        },\n        ui: {\n            thumbnail: '图片预览',\n            choseFileButton: '选择文件',\n            dropHere: '将文件拖到这里进行上传……',\n            done: '完成',\n            fileTypes: '文件类型',\n            fileSizeLimit: '文件容量限制'\n        }\n\n    },\n    vi: {\n        messages: {\n            'typeError' : \"{file} Định dạng tệp không chính xác. Định dạng hợp lệ: {extensions}\",\n            'sizeError' : \"{file} Dung lượng tệp vượt quá giới hạn và kích thước tệp tối đa là: {sizeLimit}\",\n            'minSizeError' : \"{file} Kích thước tệp dưới giới hạn và kích thước tệp tối thiểu để tải lên là: {minSizeLimit}.\",\n            'emptyError' : \"{file} Tệp này trống. Vui lòng chọn một tệp khác để tải lên.\",\n            'noFilesError' : \"Không có tệp nào được chọn để tải lên\",\n            'tooManyItemsError' : \"Quá nhiều tệp ({netItems}) được tải lên, số lượng tệp tải lên được giới hạn trong: {itemLimit}个\",\n            'maxHeightImageError' : \"Chiều cao hình ảnh vượt quá giới hạn\",\n            'maxWidthImageError' : \"Chiều rộng hình ảnh vượt quá giới hạn\",\n            'minHeightImageError' : \"Chiều cao hình ảnh quá nhỏ\",\n            'minWidthImageError' : \"Chiều rộng hình ảnh quá nhỏ\",\n            'retryFailTooManyItems' : \"Thử lại không thành công - Bạn đã đạt đến số lượng tệp tối đa.\",\n            'onLeave' : \"Tệp đang được tải lên. Nếu bạn rời khỏi trang, tệp đang được tải lên sẽ bị hủy.\"\n        },\n        text: {\n            'failUpload' : 'Tải lên không thành công',\n            'fileInputTitle' : 'Chọn tệp để tải lên'\n        },\n        ui: {\n            thumbnail: 'Xem trước hình ảnh',\n            choseFileButton: 'Chọn tệp',\n            dropHere: 'Kéo tệp vào đây để tải lên...',\n            done: 'Hoàn thành',\n            fileTypes: 'Loại tệp',\n            fileSizeLimit: 'Giới hạn kích thước tệp'\n        }\n\n    },\n    en: {\n        ui: {\n            thumbnail: 'thumbnail',\n            choseFileButton: 'select file',\n            dropHere: 'drop files here',\n            done: 'done',\n            fileTypes: 'file extensions',\n            fileSizeLimit: 'file size limit'\n        }\n    }\n};\n\nconst buildOptions = function(){\n    let p = {\n        multiple: this.multiple,\n        request: {\n            endpoint: this.uploadFileUrl,\n            inputName: this.uploadFileObjName,\n            //server side validate file info\n            params: {\n                'fileSizeLimit': this.fileSizeLimit,\n                'fileTypeExts': this.fileTypeExts\n            }\n        },\n        deleteFile: {\n            enabled: true,\n            method: \"POST\"//,\n            //'endpoint' : $webroot + 'upload/deleteUploadFile'\n        },\n        debug: true,\n        validation: {\n            allowedExtensions: this.fileTypeExts.split(','),\n            sizeLimit: fileSize2Bytes(this.fileSizeLimit, true),\n            sizeLimitStr: this.fileSizeLimit,\n            image: {\n                maxHeight: this.imageMaxHeight,\n                maxWidth: this.imageMaxWidth,\n                minHeight: this.imageMinHeight,\n                minWidth: this.imageMinWidth\n            }\n        },\n        callbacks: {\n            //the callback when file upload finish\n            onComplete: function(id,name,json,xhr){},\n            //the callback before delete file, return false can stop it.\n            onSubmitDelete: function(id){}\n        }\n    };\n    if(this.language && this.language === 'vi'){\n        p.messages = i18n.vi.messages;\n        p.text = i18n.vi.text;\n    }\n    if(this.callback && typeof this.callback === 'function'){\n        p.callbacks.onComplete = (id,name,json,xhr) => {\n            if(json) this.callback(json);\n        };\n    }\n    return p;\n}\n\nconst getI18n = language => (!language || language !== 'en') ? i18n.vi.ui : i18n.en.ui ;\n\nexport {buildOptions};\nexport {getI18n};\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:[_vm.uploaderClass]},[(!_vm.multiple)?_c('div',{staticClass:\"single-upload\"},[(_vm.preview)?_c('div',{staticClass:\"image-box\"},[_c('img',{ref:\"simpleImg\",attrs:{\"src\":_vm.singleUploadImg,\"alt\":\"\",\"width\":_vm.previewWidth,\"height\":_vm.previewHeight}})]):_vm._e(),_vm._v(\" \"),_c('div',{ref:\"upload\",staticClass:\"btn singleFileUpload uploader-button\"},[(_vm.buttonIcon)?_c('i',{staticClass:\"fi-camera\"}):_vm._e(),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(_vm.buttonText?_vm.buttonText:_vm.ui.choseFileButton))])])]):_vm._e(),_vm._v(\" \"),(_vm.multiple)?_c('div',{ref:\"multipleUpload\",staticClass:\"upload-list\"}):_vm._e(),_vm._v(\" \"),(_vm.multiple)?_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(false),expression:\"false\"}],ref:\"uploadArea\"},[_c('div',{staticClass:\"qq-uploader-selector qq-uploader qq-gallery\",staticStyle:{\"height\":\"100%\"},attrs:{\"qq-drop-area-text\":_vm.ui.dropHere}},[_vm._m(0),_vm._v(\" \"),_vm._m(1),_vm._v(\" \"),_c('div',{staticClass:\"qq-upload-button-selector qq-upload-button uploader-button\"},[_c('div',[(_vm.buttonIcon)?_c('i',{staticClass:\"fi-camera v-upload-iconfont icon-uploader-open\"}):_vm._e(),_vm._v(\"\\n                    \"+_vm._s(_vm.buttonText?_vm.buttonText:_vm.ui.choseFileButton)+\"\\n                \")])]),_vm._v(\" \"),_c('div',{staticClass:\"info-show\"},[_c('div',[_vm._v(\"\\n                    \"+_vm._s(_vm.ui.fileSizeLimit)+\"：\"),_c('span',{domProps:{\"textContent\":_vm._s(_vm.fileSizeLimit)}}),_c('br'),_vm._v(\"\\n                    \"+_vm._s(_vm.ui.fileTypes)+\"：\"),_c('span',{domProps:{\"textContent\":_vm._s(_vm.fileTypeExts)}})])]),_vm._v(\" \"),_vm._m(2)])]):_vm._e()])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',{staticClass:\"qq-upload-list-selector qq-upload-list grid-x grid-padding-x\",attrs:{\"role\":\"region\",\"aria-live\":\"polite\",\"aria-relevant\":\"additions removals\"}},[_c('li',[_c('span',{staticClass:\"qq-upload-status-text-selector qq-upload-status-text\",attrs:{\"role\":\"status\"}}),_vm._v(\" \"),_c('div',{staticClass:\"qq-progress-bar-container-selector qq-progress-bar-container\"},[_c('div',{staticClass:\"qq-progress-bar-selector qq-progress-bar\",attrs:{\"role\":\"progressbar\",\"aria-valuenow\":\"0\",\"aria-valuemin\":\"0\",\"aria-valuemax\":\"100\"}})]),_vm._v(\" \"),_c('span',{staticClass:\"qq-upload-spinner-selector qq-upload-spinner\"}),_vm._v(\" \"),_c('div',{staticClass:\"qq-thumbnail-wrapper\"},[_c('img',{staticClass:\"qq-thumbnail-selector\",attrs:{\"qq-max-size\":\"120\",\"qq-server-scale\":\"\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-upload-cancel-selector qq-upload-cancel\",attrs:{\"type\":\"button\"}},[_vm._v(\"X\")]),_vm._v(\" \"),_c('button',{staticClass:\"qq-upload-retry-selector qq-upload-retry\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-retry-icon\",attrs:{\"aria-label\":\"Retry\"}}),_vm._v(\" Retry\\n                    \")]),_vm._v(\" \"),_c('div',{staticClass:\"qq-file-info\"},[_c('div',{staticClass:\"qq-file-name\"},[_c('span',{staticClass:\"qq-upload-file-selector qq-upload-file\"}),_vm._v(\" \"),_c('span',{staticClass:\"qq-edit-filename-icon-selector qq-edit-filename-icon\",attrs:{\"aria-label\":\"Edit filename\"}})]),_vm._v(\" \"),_c('input',{staticClass:\"qq-edit-filename-selector qq-edit-filename\",attrs:{\"tabindex\":\"0\",\"type\":\"text\"}}),_vm._v(\" \"),_c('span',{staticClass:\"qq-upload-size-selector qq-upload-size\"}),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-delete-selector qq-upload-delete\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-delete-icon\",attrs:{\"aria-label\":\"Delete\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-pause-selector qq-upload-pause\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-pause-icon\",attrs:{\"aria-label\":\"Pause\"}})]),_vm._v(\" \"),_c('button',{staticClass:\"qq-btn qq-upload-continue-selector qq-upload-continue\",attrs:{\"type\":\"button\"}},[_c('span',{staticClass:\"qq-btn qq-continue-icon\",attrs:{\"aria-label\":\"Continue\"}})])])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"qq-upload-drop-area-selector qq-upload-drop-area\",attrs:{\"qq-hide-dropzone\":\"\"}},[_c('span',{staticClass:\"qq-upload-drop-area-text-selector\"})])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"qq-total-progress-bar-container-selector qq-total-progress-bar-container\"},[_c('div',{staticClass:\"qq-total-progress-bar-selector qq-progress-bar qq-total-progress-bar\",attrs:{\"role\":\"progressbar\",\"aria-valuenow\":\"0\",\"aria-valuemin\":\"0\",\"aria-valuemax\":\"100\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-0b4b4387\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/Uploader.vue\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}